# üì± Kromi - App Nativa Android

## üëã Bem-vindo, Desenvolvedor!

Este documento cont√©m **tudo** o que precisa para desenvolver a app nativa de detec√ß√£o de dorsais.

---

## üöÄ COME√áAR AQUI

### 1Ô∏è‚É£ **Guia Principal** (LER PRIMEIRO)

üìñ **[docs/NATIVE-APP-DEVELOPER-GUIDE.md](docs/NATIVE-APP-DEVELOPER-GUIDE.md)**

Este guia cont√©m:
- ‚úÖ QR Code scanning (obter configura√ß√£o do dispositivo)
- ‚úÖ Valida√ß√£o de PIN (opcional)
- ‚úÖ Captura de imagem da c√¢mera
- ‚úÖ Detec√ß√£o de dorsal (OCR - opcional)
- ‚úÖ Envio de dados para backend
- ‚úÖ Exemplos completos de c√≥digo Kotlin
- ‚úÖ Fluxo completo da aplica√ß√£o

**COMECE POR AQUI!** üëÜ

---

## üì∏ Formato de Imagem

### 2Ô∏è‚É£ **Guia R√°pido de Imagem**

‚ö° **[docs/IMAGE-FORMAT-QUICK-GUIDE.md](docs/IMAGE-FORMAT-QUICK-GUIDE.md)**

**Resumo ultra-r√°pido:**

```kotlin
// ‚úÖ CORRETO - Base64 JPEG puro (sem prefixo)
fun bitmapToBase64(bitmap: Bitmap, quality: Int): String {
    val outputStream = ByteArrayOutputStream()
    bitmap.compress(Bitmap.CompressFormat.JPEG, quality, outputStream)
    return Base64.encodeToString(outputStream.toByteArray(), Base64.NO_WRAP)
}

val imageDataAI = bitmapToBase64(bitmap, 70)      // 70% para AI
val imageDataDisplay = bitmapToBase64(bitmap, 90) // 90% para display

// Resultado deve come√ßar com: "/9j/4AAQ..." (assinatura JPEG)
```

**‚úÖ Sua app J√Å EST√Å ENVIANDO CORRETAMENTE!** Verificamos e o formato est√° perfeito.

---

## üìä Para Onde Enviar os Dados

### 3Ô∏è‚É£ **Destino dos Dados**

üìç **[docs/WHERE-APP-SENDS-DATA.md](docs/WHERE-APP-SENDS-DATA.md)**

A app envia para:
- **Fun√ß√£o:** `save_device_detection()`
- **Tabela:** `device_detections`
- **Backend:** Processa automaticamente

---

## üéØ Fluxo Completo da App

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. ESCANEAR QR CODE                                     ‚îÇ
‚îÇ    ‚Üí Obter access_code                                  ‚îÇ
‚îÇ    ‚Üí Chamar get_device_info_by_qr(access_code)         ‚îÇ
‚îÇ    ‚Üí Receber: event_id, device_id, checkpoint, etc.    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. VALIDAR PIN (opcional)                               ‚îÇ
‚îÇ    ‚Üí Se device_pin existe                               ‚îÇ
‚îÇ    ‚Üí Pedir PIN ao usu√°rio                               ‚îÇ
‚îÇ    ‚Üí Chamar validate_device_pin(access_code, pin)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. CAPTURAR IMAGEM                                      ‚îÇ
‚îÇ    ‚Üí Abrir c√¢mera                                        ‚îÇ
‚îÇ    ‚Üí Obter GPS (latitude, longitude, accuracy)          ‚îÇ
‚îÇ    ‚Üí Capturar Bitmap                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. PROCESSAR IMAGEM                                     ‚îÇ
‚îÇ    ‚Üí Comprimir JPEG 70% (AI)                            ‚îÇ
‚îÇ    ‚Üí Comprimir JPEG 90% (display)                       ‚îÇ
‚îÇ    ‚Üí Converter para Base64 (NO_WRAP)                    ‚îÇ
‚îÇ    ‚Üí Resultado: "/9j/4AAQ..." (base64 puro)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. DETECTAR DORSAL (opcional)                           ‚îÇ
‚îÇ    ‚Üí Usar OCR local (ML Kit, Tesseract)                ‚îÇ
‚îÇ    ‚Üí Se detectar: dorsal_number = 123                   ‚îÇ
‚îÇ    ‚Üí Se n√£o detectar: dorsal_number = null             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 6. ENVIAR PARA BACKEND                                  ‚îÇ
‚îÇ    ‚Üí Chamar save_device_detection()                     ‚îÇ
‚îÇ    ‚Üí Passar: access_code, image_data, GPS, timestamp    ‚îÇ
‚îÇ    ‚Üí Backend processa automaticamente                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üì¶ Dados para Enviar

### Campos Obrigat√≥rios ‚úÖ

```kotlin
val data = mapOf(
    // OBRIGAT√ìRIOS
    "access_code" to "ABC123",              // Do QR Code
    "session_id" to "unique-session-id",    // Gerar localmente
    "image_data" to imageDataAI,            // Base64 JPEG 70%
    "latitude" to 38.736946,                // GPS
    "longitude" to -9.142685,               // GPS
    "captured_at" to "2025-10-31T18:30:00Z", // Timestamp ISO 8601
    
    // OPCIONAIS
    "dorsal_number" to 123,                 // Se detectado, sen√£o null
    "display_image" to imageDataDisplay,    // Base64 JPEG 90%
    "accuracy" to 10.5,                     // Precis√£o GPS em metros
    "image_metadata" to mapOf(
        "width" to 1920,
        "height" to 1080,
        "device_type" to "android"
    )
)

// Enviar via RPC
supabase.rpc("save_device_detection", data)
```

---

## üîê Autentica√ß√£o Supabase

### Configura√ß√£o

```kotlin
// build.gradle.kts
dependencies {
    implementation("io.github.jan-tennert.supabase:postgrest-kt:2.0.0")
    implementation("io.github.jan-tennert.supabase:realtime-kt:2.0.0")
}

// C√≥digo
val supabase = createSupabaseClient(
    supabaseUrl = "https://lgpyarllyfrgdfzcjwnb.supabase.co",
    supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxncHlhcmxseWZyZ2RmemNqd25iIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzcwMzEwNTEsImV4cCI6MjA1MjYwNzA1MX0.0E-RvXMTZbS7g0JHUacPJTwAIxvzJ-2xnmSmQcEBMkg"
) {
    install(Postgrest)
}
```

---

## üß™ Como Testar

### 1. Verificar Formato de Imagem

```kotlin
fun testImageFormat(imageData: String) {
    // Teste 1: Deve come√ßar com /9j/ (JPEG)
    if (imageData.startsWith("/9j/")) {
        println("‚úÖ Formato JPEG correto!")
    } else {
        println("‚ùå ERRO: N√£o √© JPEG ou tem prefixo")
    }
    
    // Teste 2: N√£o deve ter prefixo
    if (imageData.contains("data:image")) {
        println("‚ùå ERRO: Tem prefixo data:image - remover!")
    } else {
        println("‚úÖ Base64 puro - correto!")
    }
    
    // Teste 3: Tamanho razo√°vel
    val sizeKB = imageData.length * 3 / 4 / 1024
    println("Tamanho: ${sizeKB}KB")
    if (sizeKB in 10..50) {
        println("‚úÖ Tamanho adequado")
    } else if (sizeKB > 100) {
        println("‚ö†Ô∏è Muito grande - considerar reduzir qualidade")
    } else {
        println("‚ö†Ô∏è Muito pequeno - qualidade pode estar baixa")
    }
}
```

### 2. Ver Imagens Enviadas

Aceder a: `http://localhost:1144/src/view-device-detection-image.html`

Esta p√°gina mostra todas as imagens enviadas pela app com:
- Visualiza√ß√£o da imagem
- Todos os metadados (GPS, timestamp, status)
- Navega√ß√£o entre registros

---

## üìö Documenta√ß√£o Completa

### √çndice de Todos os Documentos

üìë **[docs/NATIVE-APP-INDEX.md](docs/NATIVE-APP-INDEX.md)**

Cont√©m links organizados para:
- Guias por t√≥pico
- Busca por caso de uso
- Troubleshooting
- Scripts de teste

---

## ‚úÖ Checklist de Desenvolvimento

### Fase 1: Setup Inicial
- [ ] Configurar Supabase SDK
- [ ] Testar conex√£o com backend
- [ ] Implementar permiss√µes (c√¢mera, GPS)

### Fase 2: QR Code
- [ ] Implementar scanner QR Code
- [ ] Chamar `get_device_info_by_qr()`
- [ ] Armazenar configura√ß√£o do dispositivo

### Fase 3: C√¢mera e GPS
- [ ] Implementar captura de imagem (CameraX)
- [ ] Implementar obten√ß√£o de GPS
- [ ] Testar qualidade e tamanho das imagens

### Fase 4: Processamento
- [ ] Implementar compress√£o JPEG (70% e 90%)
- [ ] Implementar convers√£o Base64 (NO_WRAP)
- [ ] Validar formato (come√ßa com `/9j/`)

### Fase 5: OCR (Opcional)
- [ ] Integrar ML Kit ou Tesseract
- [ ] Detectar dorsais na imagem
- [ ] Validar n√∫meros detectados

### Fase 6: Envio de Dados
- [ ] Implementar chamada `save_device_detection()`
- [ ] Enviar todos os campos obrigat√≥rios
- [ ] Tratar erros e retry

### Fase 7: Testes
- [ ] Testar com QR Code real
- [ ] Verificar imagens na p√°gina de visualiza√ß√£o
- [ ] Testar detec√ß√£o de dorsais
- [ ] Validar GPS em tempo real

---

## üÜò Troubleshooting

### "Access code inv√°lido"
‚Üí Verificar QR Code escaneado  
‚Üí Confirmar que dispositivo est√° em `event_devices`

### "Imagem n√£o aparece no backend"
‚Üí Verificar formato (deve come√ßar com `/9j/`)  
‚Üí Usar `Base64.NO_WRAP` (n√£o `DEFAULT`)  
‚Üí Ver **[docs/IMAGE-FORMAT-QUICK-GUIDE.md](docs/IMAGE-FORMAT-QUICK-GUIDE.md)**

### "Erro de GPS"
‚Üí GPS √© obrigat√≥rio  
‚Üí Pedir permiss√£o `ACCESS_FINE_LOCATION`  
‚Üí Enviar mesmo que accuracy seja baixa

### "Erro de UUID"
‚Üí J√° corrigido no backend  
‚Üí Reiniciar servidor se persistir

---

## üìû Contato e Suporte

- **Documenta√ß√£o Principal:** `docs/NATIVE-APP-DEVELOPER-GUIDE.md`
- **Formato de Imagem:** `docs/IMAGE-FORMAT-QUICK-GUIDE.md`
- **√çndice Completo:** `docs/NATIVE-APP-INDEX.md`

---

## üéâ Nota Final

**Parab√©ns!** O formato de imagem que est√° a enviar **J√Å EST√Å CORRETO**. Verific√°mos e tudo est√° perfeito:

- ‚úÖ Base64 puro (sem prefixo `data:image`)
- ‚úÖ JPEG comprimido
- ‚úÖ Come√ßa com `/9j/` (assinatura JPEG)
- ‚úÖ Tamanho adequado (~19KB)

Continue assim! üöÄ

---

**Boa sorte com o desenvolvimento!** üí™

Se tiver d√∫vidas, consulte a documenta√ß√£o detalhada nos links acima.

