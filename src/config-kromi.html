<!DOCTYPE html>
<html lang="pt-PT" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configura√ß√µes do Evento - Kromi.online</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#fc6b03">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Kromi.online">
    <meta name="description" content="Sistema de detec√ß√£o de dorsais Kromi.online">
    
    <!-- KROMI Design System -->
    <link rel="stylesheet" href="/kromi-design-system.css">
    <link rel="stylesheet" href="/kromi-layout-fixes.css">
    
    <!-- Sistema de Navega√ß√£o Unificado -->
    <link rel="stylesheet" href="/navigation-component.css?v=2025102601">
    <link rel="stylesheet" href="/unified-sidebar-styles.css?v=2025102601">
    <link rel="stylesheet" href="/logo-integration.css?v=2025012701">
    
    <!-- Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <style>
        /* Layout with Sidebar Structure */
        .layout-with-sidebar {
            display: flex;
            min-height: 100vh;
            background: var(--bg-primary);
            position: relative;
        }
        
        /* Sidebar styles */
        .layout-with-sidebar .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            z-index: 1050;
            overflow-y: auto;
            transition: transform var(--transition-slow);
        }
        
        /* Header styles */
        .layout-with-sidebar .header {
            position: fixed;
            top: 0;
            left: 280px;
            right: 0;
            height: 60px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            z-index: 1040;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-5);
            transition: left var(--transition-slow);
        }
        
        /* Main content area */
        .layout-with-sidebar .main {
            margin-left: 280px;
            margin-top: 60px;
            width: calc(100% - 280px);
            min-height: calc(100vh - 60px);
            transition: margin-left var(--transition-slow), width var(--transition-slow);
        }
        
        /* Mobile adjustments */
        /* Sidebar toggle functionality */
        .sidebar-hidden {
            transform: translateX(-100%) !important;
        }
        
        .main-expanded {
            margin-left: 0 !important;
            width: 100% !important;
        }
        
        .header-expanded {
            left: 0 !important;
        }
        
        /* Mobile menu button */
        #menuToggle {
            display: none;
        }
        
        @media (max-width: 768px) {
            #menuToggle {
                display: flex !important;
            }
        }
        
        @media (max-width: 1024px) {
            body {
                overflow-x: hidden;
            }
            
            .layout-with-sidebar .sidebar {
                transform: translateX(-100%);
            }
            
            .layout-with-sidebar .sidebar.sidebar-open {
                transform: translateX(0);
            }
            
            .layout-with-sidebar .header {
                left: 0;
            }
            
            .layout-with-sidebar .main {
                margin-left: 0 !important;
                margin-top: 60px !important;
                width: 100% !important;
                min-height: calc(100vh - 60px) !important;
                padding-bottom: 80px !important;
            }
            
            /* Ensure content fills the screen */
            #mainContent {
                min-height: calc(100vh - 60px - 80px);
                padding: var(--spacing-4);
            }
            
            #menuToggle {
                display: block !important;
            }
            
            .app-bottom-nav {
                display: flex !important;
            }
        }
        
        /* Config page specific styles */
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--spacing-4);
            margin-bottom: var(--spacing-6);
        }
        
        .config-section {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: var(--spacing-5);
            border: 1px solid var(--border-color);
        }
        
        .config-section h3 {
            margin: 0 0 var(--spacing-4) 0;
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
        }
        
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--spacing-4);
        }
        
        .form-label {
            font-weight: 500;
            color: var(--text-primary);
            font-size: var(--font-size-sm);
        }
        
        .form-input, .form-select, .form-textarea {
            padding: var(--spacing-3);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-base);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: var(--font-size-sm);
            transition: all 0.2s ease;
            font-family: var(--font-family-base);
        }
        
        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(252, 107, 3, 0.1);
        }
        
        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .action-buttons {
            display: flex;
            gap: var(--spacing-3);
            margin-top: var(--spacing-5);
            padding-top: var(--spacing-4);
            border-top: 1px solid var(--border-color);
            flex-wrap: wrap;
        }
        
        .event-info-display {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: var(--spacing-4);
            margin-bottom: var(--spacing-5);
            border: 1px solid var(--border-color);
        }
        
        .event-info-display h3 {
            margin: 0 0 var(--spacing-3) 0;
            color: var(--primary);
            font-size: var(--font-size-lg);
        }
        
        .event-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-3);
        }
        
        .info-item {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-1);
        }
        
        .info-label {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .info-value {
            font-size: var(--font-size-base);
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .checkbox-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-3);
            margin-top: var(--spacing-2);
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
            padding: var(--spacing-3);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-base);
            background: var(--bg-primary);
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .checkbox-item:hover {
            background: rgba(252, 107, 3, 0.05);
            border-color: var(--primary);
        }
        
        .checkbox-item input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        
        .checkbox-item label {
            margin: 0;
            cursor: pointer;
            flex: 1;
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
        }
        
        .category-icon {
            font-size: var(--font-size-xl);
            line-height: 1;
        }
        
        .category-info {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-1);
        }
        
        .category-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: var(--font-size-sm);
        }
        
        .category-details {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-12);
            text-align: center;
            color: var(--text-secondary);
        }
        
        .empty-state-icon {
            font-size: 64px;
            margin-bottom: var(--spacing-4);
            opacity: 0.5;
        }
        
        .empty-state h3 {
            color: var(--text-primary);
            margin-bottom: var(--spacing-2);
        }
        
        .empty-state p {
            color: var(--text-secondary);
            max-width: 400px;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .config-grid {
                grid-template-columns: 1fr;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .action-buttons .btn {
                width: 100%;
                justify-content: center;
            }
            
            .checkbox-grid {
                grid-template-columns: 1fr;
            }
            
            .event-info-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Header actions responsive */
        @media (max-width: 640px) {
            #headerActions {
                display: none !important;
            }
        }
        
        /* Processor Configuration Styles */
        .processor-info-card {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-4);
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .processor-info-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .processor-info-card.selected {
            border-color: var(--primary);
            background: var(--primary-light);
        }
        
        .processor-icon {
            font-size: var(--font-size-3xl);
            margin-bottom: var(--spacing-2);
        }
        
        .processor-name {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-1);
        }
        
        .processor-desc {
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
            margin-bottom: var(--spacing-3);
        }
        
        .processor-stats {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-1);
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-size-sm);
        }
        
        .stat-label {
            color: var(--text-secondary);
        }
        
        .stat-value {
            font-weight: 600;
        }
        
        .stat-value.high {
            color: var(--success);
        }
        
        .stat-value.medium {
            color: var(--warning);
        }
        
        .stat-value.low {
            color: var(--danger);
        }
        
        .stat-value.perfect {
            color: var(--primary);
        }
        
        .stat-value.fast {
            color: var(--success);
        }
        
        .stat-value.slow {
            color: var(--warning);
        }
        
        .stat-value.manual {
            color: var(--text-secondary);
        }
        
        .stat-value.free {
            color: var(--success);
        }
        
        .range-value {
            text-align: center;
            margin-top: var(--spacing-1);
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
        }
        
        .nomenclature-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
            padding: var(--spacing-3);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-base);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .nomenclature-option:hover {
            border-color: var(--primary);
            background: rgba(252, 107, 3, 0.05);
        }
        
        .nomenclature-option input[type="radio"]:checked + div {
            color: var(--primary);
        }
    </style>
</head>
<body data-theme="dark">
    <!-- App Container -->
    <div class="layout-with-sidebar">
        <!-- Sidebar (renderizada automaticamente pelo NavigationComponent) -->
        <!-- Sidebar (renderizada automaticamente pelo NavigationComponent) -->
        <div class="sidebar" id="sidebar"></div>
        
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <h1 class="header-title">‚öôÔ∏è Configura√ß√µes do Evento</h1>
            </div>
            <div class="header-right">
                <button class="btn btn-sm btn-primary" id="saveConfig">
                    <i>üíæ</i> Guardar Configura√ß√µes
                </button>
                <button class="btn btn-sm btn-secondary" id="resetConfig">
                    <i>üîÑ</i> Repor
                </button>
            </div>
        </header>
        
        <!-- Main Content -->
        <main class="main">
            <div style="flex: 1; overflow-y: auto; padding: var(--spacing-5);" id="mainContent">
                
                <!-- Event Selector -->
                <div class="config-grid event-selector-container">
                    <div class="config-section">
                        <h3>üìã Selecionar Evento</h3>
                        <div class="form-group">
                            <label class="form-label" for="eventSelect">Evento:</label>
                            <select id="eventSelect" class="form-select">
                                <option value="">-- Selecionar Evento --</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Event Info Display -->
                <div class="event-info-display event-info-container" id="eventInfoDisplay" style="display: none;">
                    <h3>‚ÑπÔ∏è Informa√ß√µes do Evento</h3>
                    <div class="event-info-grid">
                        <div class="info-item">
                            <div class="info-label">Nome</div>
                            <div class="info-value" id="displayEventName">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Data</div>
                            <div class="info-value" id="displayEventDate">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Local</div>
                            <div class="info-value" id="displayEventLocation">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Status</div>
                            <div class="info-value" id="displayEventStatus">--</div>
                        </div>
                    </div>
                </div>
                
                <!-- Event Configuration -->
                <div class="config-grid" id="configSections" style="display: none;">
                    
                    <!-- Basic Info -->
                    <div class="config-section">
                        <h3>üìù Informa√ß√µes B√°sicas</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" for="eventName">Nome do Evento:</label>
                                <input type="text" id="eventName" class="form-input" placeholder="Ex: Maratona Lisboa 2024">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventDate">Data:</label>
                                <input type="date" id="eventDate" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventTime">Hora de In√≠cio:</label>
                                <input type="time" id="eventTime" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventLocation">Local:</label>
                                <input type="text" id="eventLocation" class="form-input" placeholder="Ex: Parque das Na√ß√µes">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Event Settings -->
                    <div class="config-section">
                        <h3>üèÉ Configura√ß√µes do Evento</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" for="eventType">Tipo de Evento:</label>
                                <select id="eventType" class="form-select">
                                    <option value="running">Corrida</option>
                                    <option value="cycling">Ciclismo</option>
                                    <option value="triathlon">Triatlo</option>
                                    <option value="walking">Caminhada</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventDistance">Dist√¢ncia (km):</label>
                                <input type="number" id="eventDistance" class="form-input" placeholder="10.0" step="0.1" min="0">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventStatus">Status:</label>
                                <select id="eventStatus" class="form-select">
                                    <option value="active">Ativo</option>
                                    <option value="paused">Pausado</option>
                                    <option value="completed">Conclu√≠do</option>
                                    <option value="cancelled">Cancelado</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="hasCategories">Categorias:</label>
                                <select id="hasCategories" class="form-select">
                                    <option value="true">Sim</option>
                                    <option value="false">N√£o</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Categories Configuration -->
                    <div class="config-section">
                        <h3>üèÖ Configura√ß√£o de Categorias</h3>
                        <div class="form-group">
                            <label class="form-label">Categorias Habilitadas:</label>
                            <div id="categoriesConfig" class="checkbox-grid">
                                <!-- Ser√° preenchido dinamicamente -->
                            </div>
                        </div>
                        <div class="form-group">
                            <button class="btn btn-sm btn-secondary" id="addCustomCategory">
                                <i>‚ûï</i> Adicionar Categoria Personalizada
                            </button>
                        </div>
                    </div>
                    
                    <!-- Nomenclatura/Formato dos Dorsais (UNIFICADO) -->
                    <div class="config-section">
                        <h3>üè∑Ô∏è Nomenclatura dos Dorsais (Formato para IA)</h3>
                        <p style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--spacing-4);">
                            Configure o formato dos n√∫meros de dorsal usados no evento. Isto ajuda a IA a detectar corretamente os diferentes tipos de numera√ß√£o.
                        </p>
                        
                        <div style="background: linear-gradient(135deg, #3b82f6, #2563eb); border-radius: var(--radius-lg); padding: var(--spacing-4); color: white; margin-bottom: var(--spacing-4);">
                            <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                <span style="font-size: var(--font-size-xl);">üí°</span>
                                <h4 style="margin: 0; font-size: var(--font-size-lg);">Importante</h4>
                            </div>
                            <div style="font-size: var(--font-size-sm); line-height: 1.6;">
                                <p style="margin: 0 0 var(--spacing-2) 0;">
                                    <strong>Para Calibra√ß√£o:</strong> A IA usar√° estas configura√ß√µes para detectar dorsais com mais precis√£o.
                                </p>
                                <p style="margin: 0;">
                                    <strong>Para GPS Tracking:</strong> Os QR codes usar√£o o c√≥digo do participante (participant_code).
                                </p>
                            </div>
                        </div>
                        
                        <!-- Tipo de Nomenclatura -->
                        <div style="margin-bottom: var(--spacing-5);">
                            <label style="display: block; margin-bottom: var(--spacing-3); font-weight: 600;">
                                Tipo de Nomenclatura:
                            </label>
                            
                            <div style="display: grid; gap: var(--spacing-3);">
                                <label class="nomenclature-option" data-type="numeric">
                                    <input type="radio" name="nomenclatureType" value="numeric" checked onchange="handleNomenclatureChange('numeric')">
                                    <div>
                                        <div style="font-weight: 600;">üî¢ Num√©rico (Padr√£o)</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">N√∫meros simples: 1, 2, 3, ..., 9999</div>
                                    </div>
                                </label>
                                
                                <label class="nomenclature-option" data-type="prefix">
                                    <input type="radio" name="nomenclatureType" value="prefix" onchange="handleNomenclatureChange('prefix')">
                                    <div>
                                        <div style="font-weight: 600;">üìù Com Prefixo</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Ex: M-407, F-156, PRO-023</div>
                                    </div>
                                </label>
                                
                                <label class="nomenclature-option" data-type="suffix">
                                    <input type="radio" name="nomenclatureType" value="suffix" onchange="handleNomenclatureChange('suffix')">
                                    <div>
                                        <div style="font-weight: 600;">üìù Com Sufixo</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Ex: 407-M, 156-F, 023-PRO</div>
                                    </div>
                                </label>
                                
                                <label class="nomenclature-option" data-type="prefix-suffix">
                                    <input type="radio" name="nomenclatureType" value="prefix-suffix" onchange="handleNomenclatureChange('prefix-suffix')">
                                    <div>
                                        <div style="font-weight: 600;">üìù Prefixo + Sufixo</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Ex: M-407-F, PRO-023-ELITE</div>
                                    </div>
                                </label>
                                
                                <label class="nomenclature-option" data-type="markers">
                                    <input type="radio" name="nomenclatureType" value="markers" onchange="handleNomenclatureChange('markers')">
                                    <div>
                                        <div style="font-weight: 600;">üé® Marcadores de Cor</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Cores antes/depois: üü¢407üî¥</div>
                                    </div>
                                </label>
                                
                                <label class="nomenclature-option" data-type="custom">
                                    <input type="radio" name="nomenclatureType" value="custom" onchange="handleNomenclatureChange('custom')">
                                    <div>
                                        <div style="font-weight: 600;">‚öôÔ∏è Personalizado (Regex)</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Padr√£o customizado com express√£o regular</div>
                                    </div>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Config Num√©rico -->
                        <div id="numericNomenclatureConfig" style="display:block;">
                            <h4 style="margin-bottom: var(--spacing-3);">üìä Configura√ß√£o Num√©rica</h4>
                            
                            <!-- Modo de Atribui√ß√£o -->
                            <div class="form-group" style="background:rgba(252,107,3,0.1);border:1px solid rgba(252,107,3,0.3);border-radius:8px;padding:12px;margin-bottom:16px;">
                                <label class="form-label" style="color:#fc6b03;font-weight:600;">üéØ Modo de Atribui√ß√£o:</label>
                                <select id="nomenclatureNumericMode" class="form-select">
                                    <option value="sequential">Sequencial (1, 2, 3...)</option>
                                    <option value="random">Aleat√≥rio (sorteia dentro do range)</option>
                                </select>
                                <small class="text-secondary">Como novos dorsais s√£o atribu√≠dos via formul√°rio</small>
                            </div>
                            
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">N√∫mero M√≠nimo:</label>
                                    <input type="number" id="nomenclatureNumericMin" class="form-input" value="1" min="1" max="9999">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">N√∫mero M√°ximo:</label>
                                    <input type="number" id="nomenclatureNumericMax" class="form-input" value="9999" min="1" max="9999">
                                </div>
                                <div class="form-group">
                                    <label style="display: flex; align-items: center; gap: var(--spacing-2);">
                                        <input type="checkbox" id="nomenclatureUsePadding">
                                        Usar zeros √† esquerda (001, 002, 003)
                                    </label>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">D√≠gitos (com padding):</label>
                                    <input type="number" id="nomenclatureNumericDigits" class="form-input" value="3" min="1" max="6">
                                </div>
                            </div>
                            <div style="margin-top: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                <strong>Exemplo:</strong> <span id="nomenclatureNumericPreview">1, 2, 3, ..., 9999</span>
                            </div>
                        </div>
                        
                        <!-- Config Prefixo -->
                        <div id="prefixNomenclatureConfig" style="display:none;">
                            <h4 style="margin-bottom: var(--spacing-3);">üìù Configura√ß√£o com Prefixo</h4>
                            
                            <!-- Modo de Atribui√ß√£o -->
                            <div class="form-group" style="background:rgba(252,107,3,0.1);border:1px solid rgba(252,107,3,0.3);border-radius:8px;padding:12px;margin-bottom:16px;">
                                <label class="form-label" style="color:#fc6b03;font-weight:600;">üéØ Modo de Atribui√ß√£o:</label>
                                <select id="nomenclaturePrefixMode" class="form-select">
                                    <option value="sequential">Sequencial (M-1, M-2, F-1, F-2...)</option>
                                    <option value="random">Aleat√≥rio (sorteia prefixo e n√∫mero)</option>
                                </select>
                            </div>
                            
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">Prefixo(s) Permitidos:</label>
                                    <input type="text" id="nomenclaturePrefixText" class="form-input" placeholder="Ex: M, F, PRO" value="M,F">
                                    <small class="text-secondary">Separar m√∫ltiplos com v√≠rgula</small>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Separador:</label>
                                    <input type="text" id="nomenclaturePrefixSeparator" class="form-input" value="-" maxlength="3">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">N√∫mero M√≠nimo:</label>
                                    <input type="number" id="nomenclaturePrefixMin" class="form-input" value="1" min="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">N√∫mero M√°ximo:</label>
                                    <input type="number" id="nomenclaturePrefixMax" class="form-input" value="999" max="9999">
                                </div>
                            </div>
                            <div style="margin-top: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                <strong>Exemplo:</strong> <span id="nomenclaturePrefixPreview">M-1, M-2, F-1, F-2</span>
                            </div>
                        </div>
                        
                        <!-- Config Sufixo -->
                        <div id="suffixNomenclatureConfig" style="display:none;">
                            <h4 style="margin-bottom: var(--spacing-3);">üìù Configura√ß√£o com Sufixo</h4>
                            
                            <!-- Modo de Atribui√ß√£o -->
                            <div class="form-group" style="background:rgba(252,107,3,0.1);border:1px solid rgba(252,107,3,0.3);border-radius:8px;padding:12px;margin-bottom:16px;">
                                <label class="form-label" style="color:#fc6b03;font-weight:600;">üéØ Modo de Atribui√ß√£o:</label>
                                <select id="nomenclatureSuffixMode" class="form-select">
                                    <option value="sequential">Sequencial (1-M, 2-M, 1-F, 2-F...)</option>
                                    <option value="random">Aleat√≥rio (sorteia n√∫mero e sufixo)</option>
                                </select>
                            </div>
                            
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">Sufixo(s) Permitidos:</label>
                                    <input type="text" id="nomenclatureSuffixText" class="form-input" placeholder="Ex: M, F, PRO" value="M,F">
                                    <small class="text-secondary">Separar m√∫ltiplos com v√≠rgula</small>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Separador:</label>
                                    <input type="text" id="nomenclatureSuffixSeparator" class="form-input" value="-" maxlength="3">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">N√∫mero M√≠nimo:</label>
                                    <input type="number" id="nomenclatureSuffixMin" class="form-input" value="1" min="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">N√∫mero M√°ximo:</label>
                                    <input type="number" id="nomenclatureSuffixMax" class="form-input" value="999" max="9999">
                                </div>
                            </div>
                            <div style="margin-top: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                <strong>Exemplo:</strong> <span id="nomenclatureSuffixPreview">1-M, 2-M, 1-F, 2-F</span>
                            </div>
                        </div>
                        
                        <!-- Config Marcadores -->
                        <div id="markersNomenclatureConfig" style="display:none;">
                            <h4 style="margin-bottom: var(--spacing-3);">üé® Configura√ß√£o com Marcadores de Cor</h4>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">Cor de In√≠cio:</label>
                                    <input type="color" id="nomenclatureStartColor" class="form-input" value="#10b981" style="height:50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Cor de Fim:</label>
                                    <input type="color" id="nomenclatureEndColor" class="form-input" value="#ef4444" style="height:50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Toler√¢ncia de Cor (%):</label>
                                    <input type="range" id="nomenclatureColorTolerance" class="form-input" min="5" max="50" value="20">
                                    <div class="text-secondary text-center"><span id="nomenclatureToleranceValue">20</span>%</div>
                                </div>
                            </div>
                            <div style="margin-top: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                <strong>Exemplo:</strong> <span style="color:#10b981;">üü¢</span> 407 <span style="color:#ef4444;">üî¥</span>
                            </div>
                        </div>
                        
                        <!-- Config Custom Regex -->
                        <div id="customNomenclatureConfig" style="display:none;">
                            <h4 style="margin-bottom: var(--spacing-3);">‚öôÔ∏è Configura√ß√£o Personalizada (Regex)</h4>
                            <div class="form-group">
                                <label class="form-label">Express√£o Regular:</label>
                                <input type="text" id="nomenclatureCustomRegex" class="form-input" placeholder="Ex: ^[A-Z]\\d{3}$" style="font-family:monospace;">
                                <small class="text-secondary">Padr√£o para validar dorsais</small>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Exemplos (separar com v√≠rgula):</label>
                                <input type="text" id="nomenclatureCustomExamples" class="form-input" placeholder="Ex: A001, B002, C003">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Modalities Configuration -->
                    <div class="config-section">
                        <h3>üèÉ Configura√ß√£o de Modalidades</h3>
                        <div class="form-group">
                            <label class="form-label">Modalidades Habilitadas:</label>
                            <div id="modalitiesConfig" class="checkbox-grid">
                                <!-- Ser√° preenchido dinamicamente -->
                            </div>
                        </div>
                        <div class="form-group">
                            <button class="btn btn-sm btn-secondary" id="addCustomModality">
                                <i>‚ûï</i> Adicionar Modalidade Personalizada
                            </button>
                        </div>
                    </div>
                    
                    <!-- Multi-Modal Configuration -->
                    <div class="config-section" id="multimodalConfig" style="display: none;">
                        <h3>üèäüö¥üèÉ Configura√ß√£o Multi-Disciplinar</h3>
                        <p style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--spacing-4);">
                            Configure as atividades espec√≠ficas para eventos multi-disciplinares (Duatlo/Triatlo).
                        </p>
                        <div id="multimodalActivities">
                            <!-- Ser√° preenchido dinamicamente -->
                        </div>
                        <div id="multimodalValidation" style="display: none; margin-top: var(--spacing-3); padding: var(--spacing-3); background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); border-radius: var(--radius-base); color: var(--danger);">
                            <strong>‚ö†Ô∏è Valida√ß√£o:</strong> <span id="multimodalValidationText">Verificando configura√ß√£o...</span>
                        </div>
                    </div>
                    
                    <!-- Lap Counter Configuration -->
                    <div class="config-section">
                        <h3>üîÑ Configura√ß√£o de Contador de Voltas</h3>
                        <p style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--spacing-4);">
                            Configure se este evento utiliza contador de voltas. Quando ativado, o sistema calcular√° automaticamente estat√≠sticas de voltas.
                        </p>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" for="hasLapCounter">Contador de Voltas:</label>
                                <select id="hasLapCounter" class="form-select">
                                    <option value="false">Desativado</option>
                                    <option value="true">Ativado</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="lapDistance">Dist√¢ncia por Volta (km):</label>
                                <input type="number" id="lapDistance" class="form-input" placeholder="2.5" step="0.1" min="0" disabled>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="totalLaps">Total de Voltas Esperadas:</label>
                                <input type="number" id="totalLaps" class="form-input" placeholder="10" min="1" disabled>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="minLapsForClassification">M√≠nimo de Voltas para Classificar:</label>
                                <input type="number" id="minLapsForClassification" class="form-input" placeholder="1" min="1" disabled>
                            </div>
                        </div>
                        <div id="lapCounterValidation" style="display: none; margin-top: var(--spacing-3); padding: var(--spacing-3); background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); border-radius: var(--radius-base); color: var(--danger);">
                            <strong>‚ö†Ô∏è Valida√ß√£o:</strong> <span id="lapCounterValidationText">Verificando configura√ß√£o...</span>
                        </div>
                    </div>
                    
                    <!-- Checkpoint Types Configuration -->
                    <div class="config-section">
                        <h3>üìç Tipos de Checkpoints (Global)</h3>
                        <p style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--spacing-4);">
                            Configure os tipos de checkpoints dispon√≠veis para todos os eventos.
                        </p>
                        <div id="checkpointTypesConfig">
                            <!-- Ser√° preenchido dinamicamente -->
                        </div>
                        <div style="margin-top: var(--spacing-3);">
                            <button class="btn btn-sm btn-secondary" id="addCheckpointTypeBtn">
                                <i>‚ûï</i> Adicionar Tipo Personalizado
                            </button>
                            <button class="btn btn-sm btn-primary" id="refreshCheckpointTypesBtn">
                                <i>üîÑ</i> Atualizar
                            </button>
                        </div>
                    </div>
                    
                    <!-- Advanced Settings -->
                    <div class="config-section">
                        <h3>üîß Configura√ß√µes Avan√ßadas</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" for="autoStartEnabled">In√≠cio Autom√°tico:</label>
                                <select id="autoStartEnabled" class="form-select">
                                    <option value="true">Ativado</option>
                                    <option value="false">Desativado</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="scheduledStartTime">Hora Programada:</label>
                                <input type="datetime-local" id="scheduledStartTime" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventDescription">Descri√ß√£o:</label>
                                <textarea id="eventDescription" class="form-textarea" placeholder="Descri√ß√£o detalhada do evento..."></textarea>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Processor Configuration -->
                    <div class="config-section">
                        <h3>ü§ñ Configura√ß√£o do Processador de IA</h3>
                        <p style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--spacing-4);">
                            Escolha o tipo de processador de IA para detec√ß√£o de dorsais. Cada processador tem caracter√≠sticas espec√≠ficas de velocidade, precis√£o e custo.
                        </p>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" for="processorType">Tipo de Processador:</label>
                                <select id="processorType" class="form-select">
                                    <option value="gemini">ü§ñ Gemini AI (Recomendado)</option>
                                    <option value="openai">ü§ñ OpenAI GPT-4</option>
                                    <option value="deepseek">ü§ñ DeepSeek AI</option>
                                    <option value="google-vision">üëÅÔ∏è Google Vision API</option>
                                    <option value="ocr">üìÑ OCR Tradicional</option>
                                    <option value="hybrid">üîÑ H√≠brido (Gemini + OCR)</option>
                                    <option value="manual">‚úã Manual (Sem IA)</option>
                                </select>
                            </div>
                            <div class="form-group" id="geminiModelGroup" style="display: none;">
                                <label class="form-label" for="geminiModel">Modelo Gemini:</label>
                                <select id="geminiModel" class="form-select">
                                    <option value="">Carregando modelos...</option>
                                </select>
                                <button type="button" id="reloadGeminiModelsBtn" class="btn btn-secondary" style="margin-top: 8px;">
                                    üîÑ Recarregar Modelos
                                </button>
                            </div>
                            <div class="form-group" id="openaiModelGroup" style="display: none;">
                                <label class="form-label" for="openaiModel">Modelo OpenAI:</label>
                                <select id="openaiModel" class="form-select">
                                    <option value="">Carregando modelos...</option>
                                </select>
                                <button type="button" id="reloadModelsBtn" class="btn btn-secondary" style="margin-top: 8px;">
                                    üîÑ Recarregar Modelos
                                </button>
                            </div>
                            <div class="form-group" id="deepseekModelGroup" style="display: none;">
                                <label class="form-label" for="deepseekModel">Modelo DeepSeek:</label>
                                <select id="deepseekModel" class="form-select">
                                    <option value="">Carregando modelos...</option>
                                </select>
                                <button type="button" id="reloadDeepSeekModelsBtn" class="btn btn-secondary" style="margin-top: 8px;">
                                    üîÑ Recarregar Modelos
                                </button>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="processorSpeed">Velocidade de Processamento:</label>
                                <select id="processorSpeed" class="form-select">
                                    <option value="fast">‚ö° R√°pido (Menos Precis√£o)</option>
                                    <option value="balanced">‚öñÔ∏è Equilibrado (Padr√£o)</option>
                                    <option value="accurate">üéØ Preciso (Mais Lento)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="processorConfidence">Confian√ßa M√≠nima:</label>
                                <input type="range" id="processorConfidence" class="form-range" min="0.1" max="1.0" step="0.1" value="0.7">
                                <div class="range-value">
                                    <span id="confidenceValue">70%</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Processor Info Cards -->
                        <div class="processor-info-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--spacing-3); margin-top: var(--spacing-4);">
                            <div class="processor-info-card" data-processor="gemini">
                                <div class="processor-icon">ü§ñ</div>
                                <div class="processor-name">Gemini AI</div>
                                <div class="processor-desc">IA avan√ßada do Google</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precis√£o:</span>
                                        <span class="stat-value high">95%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value medium">2-5s</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value medium">M√©dio</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="processor-info-card" data-processor="openai">
                                <div class="processor-icon">ü§ñ</div>
                                <div class="processor-name">OpenAI</div>
                                <div class="processor-desc">GPT-4 Vision API</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precis√£o:</span>
                                        <span class="stat-value high">95%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value medium">2-5s</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value medium">M√©dio</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="processor-info-card" data-processor="google-vision">
                                <div class="processor-icon">üëÅÔ∏è</div>
                                <div class="processor-name">Google Vision</div>
                                <div class="processor-desc">OCR especializado</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precis√£o:</span>
                                        <span class="stat-value medium">85%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value fast">1-3s</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value low">Baixo</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="processor-info-card" data-processor="ocr">
                                <div class="processor-icon">üìÑ</div>
                                <div class="processor-name">OCR Tradicional</div>
                                <div class="processor-desc">Processamento local</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precis√£o:</span>
                                        <span class="stat-value low">70%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value fast">0.5-2s</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value free">Gratuito</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="processor-info-card" data-processor="hybrid">
                                <div class="processor-icon">üîÑ</div>
                                <div class="processor-name">H√≠brido</div>
                                <div class="processor-desc">Combina m√∫ltiplas IA</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precis√£o:</span>
                                        <span class="stat-value high">98%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value slow">5-10s</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value high">Alto</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="processor-info-card" data-processor="manual">
                                <div class="processor-icon">‚úã</div>
                                <div class="processor-name">Manual</div>
                                <div class="processor-desc">Sem processamento IA</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precis√£o:</span>
                                        <span class="stat-value perfect">100%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value manual">Manual</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value free">Gratuito</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="config-section">
                        <h3>üíæ A√ß√µes</h3>
                        <div class="action-buttons">
                            <button class="btn btn-primary" id="saveEventConfig">
                                <i>üíæ</i> Salvar Configura√ß√£o
                            </button>
                            <button class="btn btn-secondary" id="resetEventConfig">
                                <i>üîÑ</i> Resetar
                            </button>
                            <button class="btn btn-danger" id="deleteEvent">
                                <i>üóëÔ∏è</i> Excluir Evento
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Empty State -->
                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon">‚öôÔ∏è</div>
                    <h3>Selecione um evento para configurar</h3>
                    <p>Escolha um evento na lista acima para ver e editar suas configura√ß√µes.</p>
                </div>
            </div>
        </main>
        
        <!-- Bottom Navigation (Mobile) -->
        <nav class="app-bottom-nav" id="bottomNav">
            <!-- Ser√° preenchido por navigation.js -->
        </nav>
    </div> <!-- Fim .layout-with-sidebar -->
    
    <!-- Scripts de Autentica√ß√£o -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="/supabase.js?v=2025102605"></script>
    <script src="/auth-client.js?v=2025102610"></script>
    <script src="/auth-helper.js?v=2025102607"></script>
    
    <!-- Sistema de Navega√ß√£o Unificado -->
    <script src="/navigation-config.js?v=2025102601" defer></script>
    <script src="/navigation-service.js?v=2025102601" defer></script>
    <!-- Logo Loader (carregar ANTES da navega√ß√£o, SEM defer para garantir ordem) -->
    <script src="/logo-loader.js?v=2025012702"></script>
    <script src="/navigation-component.js?v=2025102601" defer></script>
    <script src="/navigation-init.js?v=2025102601" defer></script>
    
    <script src="/universal-route-protection.js?v=2025102607"></script>
    
    <!-- Configuration Logic -->
    <script>
        // Global variables
        let currentEvent = null;
        let events = [];
        
        // Fun√ß√£o para alternar sidebar
        // Aguardar navega√ß√£o estar pronta
        async function waitForNavigation() {
            return new Promise((resolve) => {
                if (window.NavigationUtils) {
                    resolve();
                } else {
                    window.addEventListener('navigationReady', resolve);
                }
            });
        }
        
        // Initialize page
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Verificar autentica√ß√£o
                const autenticado = await verificarAutenticacao(['admin', 'moderator', 'event_manager', 'user']);
                if (!autenticado) return;
                
                console.log('üöÄ Inicializando p√°gina config...');
                
                // Initialize Supabase first
                if (window.supabaseClient) {
                    console.log('üîë Inicializando Supabase...');
                    await window.supabaseClient.init();
                    console.log('‚úÖ Supabase inicializado:', window.supabaseClient.isConnected);
                } else {
                    console.error('‚ùå window.supabaseClient n√£o encontrado');
                }
                
                // Aguardar navega√ß√£o estar pronta
                await waitForNavigation();
                console.log('‚úÖ Navega√ß√£o pronta');
                
                // Obter eventId da URL
                const urlParams = new URLSearchParams(window.location.search);
                const eventId = urlParams.get('event');
                const eventName = urlParams.get('eventName');
                
                console.log('üìç Evento da URL:', eventId, eventName);
                
                // Atualizar contexto de evento no NavigationService
                if (eventId && window.navigationService) {
                    window.navigationService.setEventContext(eventId, eventName);
                }
                
                // Inicializar autocomplete do Google Maps
                await initGoogleMapsAutocomplete();
                
                if (eventId) {
                    console.log('üéØ Carregando evento automaticamente...');
                    // Se temos evento na URL, carregar automaticamente
                    await loadEventInfo(eventId);
                    
                    // Esconder dropdown de sele√ß√£o de evento
                    const eventSelectorContainer = document.querySelector('.event-selector-container');
                    if (eventSelectorContainer) {
                        eventSelectorContainer.style.display = 'none';
                    }
                    
                    // Mostrar info do evento selecionado
                    const eventInfoContainer = document.querySelector('.event-info-container');
                    if (eventInfoContainer) {
                        eventInfoContainer.style.display = 'block';
                    }
                } else {
                    // Sem evento na URL - mostrar mensagem para selecionar
                    console.warn('‚ö†Ô∏è Nenhum evento na URL');
                }
                
                // Setup event listeners
                setupEventListeners();
                
                // Load events
                console.log('üìã Carregando lista de eventos...');
                await loadEvents();
                console.log('‚úÖ P√°gina inicializada');
                
            } catch (error) {
                console.error('‚ùå Erro na inicializa√ß√£o:', error);
            }
        });
        
        function setupEventListeners() {
            // Event selector
            const eventSelect = document.getElementById('eventSelect');
            if (eventSelect) {
                eventSelect.addEventListener('change', (e) => {
                    if (e.target.value) {
                        loadEventInfo(e.target.value);
                    } else {
                        hideEventInfo();
                    }
                });
            }
            
            // Configuration buttons
            const saveEventConfigBtn = document.getElementById('saveEventConfig');
            const resetEventConfigBtn = document.getElementById('resetEventConfig');
            const deleteEventBtn = document.getElementById('deleteEvent');
            const saveConfigBtn = document.getElementById('saveConfig');
            const resetConfigBtn = document.getElementById('resetConfig');
            
            if (saveEventConfigBtn) saveEventConfigBtn.addEventListener('click', saveEventConfig);
            if (resetEventConfigBtn) resetEventConfigBtn.addEventListener('click', resetEventConfig);
            if (deleteEventBtn) deleteEventBtn.addEventListener('click', deleteEvent);
            if (saveConfigBtn) saveConfigBtn.addEventListener('click', saveEventConfig);
            if (resetConfigBtn) resetConfigBtn.addEventListener('click', resetEventConfig);
            
            // Lap counter configuration
            const hasLapCounter = document.getElementById('hasLapCounter');
            if (hasLapCounter) {
                hasLapCounter.addEventListener('change', handleLapCounterToggle);
            }
            
            // Dorsal assignment configuration
            const dorsalMode = document.getElementById('dorsalMode');
            if (dorsalMode) {
                dorsalMode.addEventListener('change', handleDorsalModeChange);
            }
            
            // Menu toggle mobile
            const menuToggle = document.getElementById('menuToggle');
            const sidebar = document.getElementById('sidebar');
            
            if (menuToggle && sidebar) {
                menuToggle.addEventListener('click', () => {
                    sidebar.classList.toggle('sidebar-open');
                });
            }
        }
        
        async function loadEvents() {
            try {
                console.log('üìã [loadEvents] Carregando lista de eventos via API...');
                
                // Usar API REST (bypassa RLS)
                const res = await fetch('/api/events/list', {
                    credentials: 'include'
                });
                
                if (!res.ok) {
                    if (res.status === 401) {
                        window.location.href = './login.html';
                        return;
                    }
                    throw new Error(`HTTP ${res.status}`);
                }
                
                const { success, events: eventsData, error } = await res.json();
                
                if (!success || error) {
                    console.error('‚ùå Erro ao carregar eventos:', error);
                    return;
                }
                
                console.log('‚úÖ [loadEvents] Eventos carregados:', eventsData?.length || 0);
                events = eventsData || [];
                
                // Update dropdown
                const selector = document.getElementById('eventSelect');
                if (selector) {
                    selector.innerHTML = '<option value="">-- Selecionar Evento --</option>';
                    events.forEach(event => {
                        const option = document.createElement('option');
                        option.value = event.id;
                        option.textContent = event.name;
                        selector.appendChild(option);
                    });
                    console.log('‚úÖ [loadEvents] Dropdown atualizado com', events.length, 'eventos');
                }
                
            } catch (error) {
                console.error('‚ùå [loadEvents] Erro:', error);
            }
        }
        
        // =====================================================
        // GOOGLE MAPS AUTocomplete
        // =====================================================
        
        let googleMapsAutocomplete = null;
        
        async function initGoogleMapsAutocomplete() {
            try {
                // Obter API key do backend
                const configResponse = await fetch('/api/config', {
                    credentials: 'include'
                });
                
                if (!configResponse.ok) {
                    console.warn('‚ö†Ô∏è N√£o foi poss√≠vel obter configura√ß√£o do Google Maps');
                    return;
                }
                
                const config = await configResponse.json();
                const apiKey = config.GOOGLE_MAPS_API_KEY;
                
                if (!apiKey) {
                    console.warn('‚ö†Ô∏è GOOGLE_MAPS_API_KEY n√£o configurada');
                    return;
                }
                
                console.log('üó∫Ô∏è Inicializando Google Maps Places Autocomplete...');
                
                // Carregar script do Google Maps Places API
                if (!window.google || !window.google.maps || !window.google.maps.places) {
                    await loadGoogleMapsScript(apiKey);
                }
                
                // Aguardar um pouco para garantir que a API est√° carregada
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Inicializar autocomplete no campo eventLocation
                const locationInput = document.getElementById('eventLocation');
                if (!locationInput) {
                    console.warn('‚ö†Ô∏è Elemento eventLocation n√£o encontrado');
                    return;
                }
                
                if (window.google && window.google.maps && window.google.maps.places) {
                    try {
                        const autocomplete = new google.maps.places.Autocomplete(locationInput, {
                            types: ['establishment', 'geocode'],
                            fields: ['formatted_address', 'geometry', 'name', 'address_components']
                        });
                        
                        autocomplete.addListener('place_changed', () => {
                            try {
                                const place = autocomplete.getPlace();
                                
                                if (place.formatted_address) {
                                    locationInput.value = place.formatted_address;
                                    console.log('üìç Local selecionado:', place.formatted_address);
                                }
                                
                                // Opcional: salvar coordenadas se necess√°rio
                                if (place.geometry && place.geometry.location) {
                                    const lat = place.geometry.location.lat();
                                    const lng = place.geometry.location.lng();
                                    console.log('üìç Coordenadas:', { lat, lng });
                                    // Voc√™ pode salvar essas coordenadas em um campo hidden se necess√°rio
                                }
                            } catch (error) {
                                console.warn('‚ö†Ô∏è Erro ao processar sele√ß√£o de local:', error);
                            }
                        });
                        
                        googleMapsAutocomplete = autocomplete;
                        console.log('‚úÖ Google Maps Autocomplete inicializado');
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Erro ao criar Autocomplete:', error);
                        console.warn('üí° O campo de localiza√ß√£o ainda funciona como texto normal');
                        // N√£o quebrar - o usu√°rio ainda pode digitar manualmente
                    }
                } else {
                    console.warn('‚ö†Ô∏è API do Google Maps n√£o carregada - o campo funciona como texto normal');
                    console.warn('üí° Para habilitar o autocomplete, verifique:');
                    console.warn('   1. A API key est√° configurada corretamente');
                    console.warn('   2. A API key tem permiss√µes para este dom√≠nio/IP');
                    console.warn('   3. A API "Places API" est√° habilitada no Google Cloud Console');
                }
                
            } catch (error) {
                console.error('‚ùå Erro ao inicializar Google Maps Autocomplete:', error);
                console.warn('üí° O campo de localiza√ß√£o ainda funciona como texto normal');
            }
        }
        
        function loadGoogleMapsScript(apiKey) {
            return new Promise((resolve) => {
                // Verificar se j√° est√° carregado
                if (window.google && window.google.maps && window.google.maps.places) {
                    resolve();
                    return;
                }
                
                // Verificar se o script j√° est√° sendo carregado
                if (document.querySelector('script[src*="maps.googleapis.com"]')) {
                    // Aguardar o script carregar
                    const checkInterval = setInterval(() => {
                        if (window.google && window.google.maps && window.google.maps.places) {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                    
                    setTimeout(() => {
                        clearInterval(checkInterval);
                        console.warn('‚ö†Ô∏è Timeout ao carregar Google Maps API - o campo funciona como texto normal');
                        resolve(); // Resolver mesmo assim para n√£o quebrar a p√°gina
                    }, 10000);
                    return;
                }
                
                // Handler de erro de autentica√ß√£o - n√£o quebrar a funcionalidade
                window.gm_authFailure = function() {
                    console.warn('‚ö†Ô∏è Erro de autentica√ß√£o do Google Maps (ApiTargetBlockedMapError)');
                    console.warn('üí° Poss√≠veis causas:');
                    console.warn('   1. A API key n√£o est√° configurada corretamente');
                    console.warn('   2. A API key n√£o tem permiss√µes para este dom√≠nio/IP');
                    console.warn('   3. A Places API n√£o est√° habilitada no Google Cloud Console');
                    console.warn('   4. As restri√ß√µes de HTTP referrer bloqueiam este dom√≠nio');
                    console.warn('üí° O campo de localiza√ß√£o ainda funciona como texto normal');
                    delete window.initGoogleMapsCallback;
                    resolve(); // N√£o rejeitar - permitir que continue
                };
                
                // Criar callback global
                window.initGoogleMapsCallback = () => {
                    try {
                        delete window.initGoogleMapsCallback;
                        if (window.google && window.google.maps && window.google.maps.places) {
                            resolve();
                        } else {
                            console.warn('‚ö†Ô∏è Google Maps API carregada mas Places n√£o dispon√≠vel');
                            resolve(); // Resolver mesmo assim
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Erro no callback do Google Maps:', error);
                        resolve(); // Resolver mesmo assim
                    }
                };
                
                // Criar e adicionar script
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places&callback=initGoogleMapsCallback`;
                script.async = true;
                script.defer = true;
                
                script.onerror = () => {
                    console.warn('‚ö†Ô∏è Erro ao carregar script do Google Maps - o campo funciona como texto normal');
                    delete window.initGoogleMapsCallback;
                    resolve(); // N√£o rejeitar - permitir que continue
                };
                
                document.head.appendChild(script);
            });
        }
        
        async function loadEventInfo(eventId) {
            try {
                console.log('üìä [loadEventInfo] Carregando evento via API:', eventId);
                
                // Carregar evento via API REST (bypassa RLS)
                const res = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!res.ok) {
                    if (res.status === 404) {
                        showError('Evento n√£o encontrado');
                        return;
                    }
                    if (res.status === 401) {
                        window.location.href = './login.html';
                        return;
                    }
                    throw new Error(`HTTP ${res.status}`);
                }
                
                const { success, event, error: apiError } = await res.json();
                
                if (!success || apiError) {
                    console.error('Erro ao carregar evento:', apiError);
                    showError(apiError || 'Erro ao carregar evento');
                    return;
                }
                
                console.log('‚úÖ [loadEventInfo] Evento carregado:', event.name);
                console.log('üìÖ [loadEventInfo] event_date da API:', event.event_date);
                console.log('üìè [loadEventInfo] distance_km da API:', event.distance_km, 'tipo:', typeof event.distance_km);
                
                // A API REST j√° retorna todos os campos da base de dados usando service role (bypass RLS)
                console.log('üìè distance_km carregado via API REST:', event.distance_km, 'tipo:', typeof event.distance_km);
                
                // Se a API retornou apenas data (sem hora), tentar buscar hora completa via API REST novamente
                if (event.event_date && event.event_date.length === 10 && !event.event_date.includes('T')) {
                    console.log('‚ö†Ô∏è API retornou apenas data, tentando buscar hora completa via API REST...');
                    try {
                        const apiRetryResponse = await fetch(`/api/events/${eventId}`, {
                            credentials: 'include'
                        });
                        
                        if (apiRetryResponse.ok) {
                            const apiRetryData = await apiRetryResponse.json();
                            if (apiRetryData.success && apiRetryData.event?.event_date) {
                                const retryDate = apiRetryData.event.event_date;
                                if (retryDate.includes('T') || retryDate.length > 10) {
                                    event.event_date = retryDate;
                                    currentEvent.event_date = retryDate;
                                    console.log('‚úÖ event_date completo encontrado via API REST (retry):', retryDate);
                                }
                            }
                        }
                    } catch (apiRetryErr) {
                        console.log('‚ÑπÔ∏è Erro ao buscar event_date via API REST (retry):', apiRetryErr.message);
                    }
                } else if (event.event_date && (event.event_date.includes('T') || event.event_date.length > 10)) {
                    console.log('‚úÖ event_date j√° vem com hora da API:', event.event_date);
                }
                
                currentEvent = event;
                
                // Update display info
                updateEventDisplay(event);
                
                // Update form fields
                updateFormFields(event);
                
                // Load categories, modalities and checkpoint types
                await loadCategories();
                await loadModalities();
                await loadCheckpointTypes();
                
                // Initialize processor configuration
                initializeProcessorConfig();
                
                // Load event-specific configurations
                const categoryConfig = await loadEventCategoryConfig(eventId);
                const modalityConfig = await loadEventModalityConfig(eventId);
                // Nota: loadDorsalConfig removido - a atribui√ß√£o agora est√° dentro da nomenclatura
                await loadDorsalNomenclatureConfig(eventId);
                
                // Update checkboxes based on event configuration
                updateCategoryCheckboxes(categoryConfig);
                updateModalityCheckboxes(modalityConfig);
                
                // Show config sections
                const configSections = document.getElementById('configSections');
                const emptyState = document.getElementById('emptyState');
                
                if (configSections) configSections.style.display = 'grid';
                if (emptyState) emptyState.style.display = 'none';
                
                // Update sidebar
                const eventInfoPanel = document.getElementById('eventInfoPanel');
                const currentEventInfo = document.getElementById('currentEventInfo');
                
                if (eventInfoPanel) eventInfoPanel.style.display = 'block';
                if (currentEventInfo) {
                    // Verificar se existe calibra√ß√£o
                    await updateCalibrationStatus(eventId, event, currentEventInfo);
                }
                
            } catch (error) {
                console.error('Erro ao carregar evento:', error);
                showError('Erro ao carregar evento');
            }
        }
        
        // Verificar status da calibra√ß√£o e atualizar display
        async function updateCalibrationStatus(eventId, event, container) {
            try {
                let calibrationStatus = '‚ùå Calibra√ß√£o ainda n√£o foi definida';
                
                if (window.supabaseClient && window.supabaseClient.supabase) {
                    // Usar RPC get_active_calibration em vez de event_configurations
                    const { data: calibrationData, error } = await window.supabaseClient.supabase
                        .rpc('get_active_calibration', { event_uuid: eventId });
                    
                    if (!error && calibrationData && calibrationData.length > 0) {
                        const calibration = calibrationData[0];
                        if (calibration.is_complete) {
                            calibrationStatus = '‚úÖ Calibra√ß√£o completa';
                        } else {
                            calibrationStatus = '‚è≥ Calibra√ß√£o em progresso';
                        }
                    }
                }
                
                if (container) {
                    container.innerHTML = `
                        <strong>${event.name}</strong><br>
                        Data: ${event.event_date ? new Date(event.event_date).toLocaleDateString('pt-PT') : 'N√£o definida'}<br>
                        Local: ${event.location || 'N√£o definido'}<br>
                        ${calibrationStatus}
                    `;
                }
            } catch (error) {
                console.error('‚ùå Erro ao verificar status da calibra√ß√£o:', error);
                // Em caso de erro, mostrar info b√°sica
                if (container) {
                    container.innerHTML = `
                        <strong>${event.name}</strong><br>
                        Data: ${event.event_date ? new Date(event.event_date).toLocaleDateString('pt-PT') : 'N√£o definida'}<br>
                        Local: ${event.location || 'N√£o definido'}
                    `;
                }
            }
        }
        
        function updateEventDisplay(event) {
            const displayEventName = document.getElementById('displayEventName');
            const displayEventDate = document.getElementById('displayEventDate');
            const displayEventLocation = document.getElementById('displayEventLocation');
            const displayEventStatus = document.getElementById('displayEventStatus');
            
            if (displayEventName) displayEventName.textContent = event.name || '--';
            if (displayEventDate) displayEventDate.textContent = event.event_date ? new Date(event.event_date).toLocaleDateString('pt-PT') : '--';
            if (displayEventLocation) displayEventLocation.textContent = event.location || '--';
            if (displayEventStatus) displayEventStatus.textContent = event.status || '--';
        }
        
        function updateFormFields(event) {
            const eventName = document.getElementById('eventName');
            const eventDate = document.getElementById('eventDate');
            const eventTime = document.getElementById('eventTime');
            const eventLocation = document.getElementById('eventLocation');
            const eventType = document.getElementById('eventType');
            const eventDistance = document.getElementById('eventDistance');
            const eventStatus = document.getElementById('eventStatus');
            const hasCategories = document.getElementById('hasCategories');
            const autoStartEnabled = document.getElementById('autoStartEnabled');
            const scheduledStartTime = document.getElementById('scheduledStartTime');
            const eventDescription = document.getElementById('eventDescription');
            
            if (eventName) eventName.value = event.name || '';
            
            // Processar event_date para extrair data e hora
            let dateValue = '';
            let timeValue = '';
            
            if (event.event_date) {
                if (typeof event.event_date === 'string') {
                    if (event.event_date.includes('T')) {
                        // Tem timestamp completo: "2025-11-02T09:00:00.000Z"
                        const parts = event.event_date.split('T');
                        dateValue = parts[0];
                        if (parts[1]) {
                            // Extrair hora: "09:00:00.000Z" -> "09:00"
                            timeValue = parts[1].substring(0, 5);
                        }
                    } else if (event.event_date.length === 10) {
                        // Apenas data: "2025-11-02"
                        dateValue = event.event_date;
                        timeValue = ''; // Sem hora dispon√≠vel
                    } else {
                        // Formato desconhecido, tentar extrair data
                        dateValue = event.event_date.substring(0, 10);
                    }
                } else if (event.event_date instanceof Date) {
                    // √â um objeto Date
                    dateValue = event.event_date.toISOString().split('T')[0];
                    const timePart = event.event_date.toISOString().split('T')[1];
                    if (timePart) {
                        timeValue = timePart.substring(0, 5);
                    }
                }
            }
            
            if (eventDate) eventDate.value = dateValue;
            if (eventTime) eventTime.value = timeValue;
            
            // Log para debug
            if (event.event_date) {
                console.log('üìÖ Preenchendo campos de data/hora:', {
                    original: event.event_date,
                    dateField: dateValue,
                    timeField: timeValue,
                    hasTime: !!timeValue
                });
            }
            if (eventLocation) eventLocation.value = event.location || '';
            if (eventType) eventType.value = event.event_type || 'running';
            
            // Atualizar distance_km - garantir que o valor √© tratado corretamente
            if (eventDistance) {
                let distanceValue = '';
                
                // Se event.distance_km existe, usar ele
                if (event.distance_km !== null && event.distance_km !== undefined) {
                    if (typeof event.distance_km === 'number') {
                        distanceValue = event.distance_km.toString();
                    } else if (typeof event.distance_km === 'string') {
                        distanceValue = event.distance_km;
                    } else {
                        distanceValue = String(event.distance_km);
                    }
                }
                
                // Aplicar valor no campo
                eventDistance.value = distanceValue;
                console.log('üìè Atualizando campo distance_km:', {
                    original: event.distance_km,
                    tipo: typeof event.distance_km,
                    valueSet: distanceValue,
                    campoId: eventDistance.id,
                    campoAtualAntes: eventDistance.value
                });
                
                // For√ßar atualiza√ß√£o visual se necess√°rio
                if (eventDistance.value !== distanceValue) {
                    console.warn('‚ö†Ô∏è Campo distance_km n√£o atualizado! Tentando for√ßar...');
                    eventDistance.setAttribute('value', distanceValue);
                    eventDistance.value = distanceValue;
                    // Trigger change event para garantir que qualquer listener seja notificado
                    eventDistance.dispatchEvent(new Event('input', { bubbles: true }));
                    eventDistance.dispatchEvent(new Event('change', { bubbles: true }));
                    console.log('üîÑ Campo distance_km for√ßado para:', eventDistance.value);
                }
            }
            
            if (eventStatus) eventStatus.value = event.status || 'active';
            if (hasCategories) hasCategories.value = event.has_categories ? 'true' : 'false';
            if (autoStartEnabled) autoStartEnabled.value = event.auto_start_enabled ? 'true' : 'false';
            if (scheduledStartTime) {
                if (event.scheduled_start_time) {
                    // Converter ISO string para formato datetime-local (YYYY-MM-DDTHH:mm)
                    // scheduled_start_time pode vir como ISO string completa ou apenas data+hora
                    const scheduledDate = new Date(event.scheduled_start_time);
                    if (!isNaN(scheduledDate.getTime())) {
                        // Formato datetime-local requer YYYY-MM-DDTHH:mm (sem segundos e sem timezone)
                        const year = scheduledDate.getFullYear();
                        const month = String(scheduledDate.getMonth() + 1).padStart(2, '0');
                        const day = String(scheduledDate.getDate()).padStart(2, '0');
                        const hours = String(scheduledDate.getHours()).padStart(2, '0');
                        const minutes = String(scheduledDate.getMinutes()).padStart(2, '0');
                        scheduledStartTime.value = `${year}-${month}-${day}T${hours}:${minutes}`;
                        console.log('‚è∞ [updateFormFields] scheduled_start_time preenchido:', {
                            original: event.scheduled_start_time,
                            formatoDatetimeLocal: scheduledStartTime.value
                        });
                    } else {
                        // Fallback: tentar substring se new Date falhar
                        scheduledStartTime.value = event.scheduled_start_time.substring(0, 16);
                    }
                } else {
                    scheduledStartTime.value = '';
                }
            }
            if (eventDescription) eventDescription.value = event.description || '';
            
            // Load lap counter configuration
            loadLapCounterConfig(event.id);
        }
        
        function hideEventInfo() {
            const configSections = document.getElementById('configSections');
            const emptyState = document.getElementById('emptyState');
            const eventInfoDisplay = document.getElementById('eventInfoDisplay');
            
            if (configSections) configSections.style.display = 'none';
            if (emptyState) emptyState.style.display = 'block';
            if (eventInfoDisplay) eventInfoDisplay.style.display = 'none';
            
            currentEvent = null;
        }
        
        // =====================================================
        // FUN√á√ïES PARA CATEGORIAS E MODALIDADES
        // =====================================================
        
        async function loadCategories() {
            try {
                console.log('üèÖ Carregando categorias via API REST...');
                const response = await fetch('/api/config/age-categories', {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const categories = result.categories || result.data || [];
                
                console.log('‚úÖ Categorias carregadas via API REST:', categories.length);
                renderCategoriesConfig(categories);
            } catch (error) {
                console.error('‚ùå Erro ao carregar categorias:', error);
                showError('Erro ao carregar categorias');
            }
        }
        
        async function loadModalities() {
            try {
                console.log('üèÉ Carregando modalidades via API REST...');
                const response = await fetch('/api/config/event-modalities', {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const modalities = result.modalities || result.data || [];
                
                console.log('‚úÖ Modalidades carregadas via API REST:', modalities.length);
                renderModalitiesConfig(modalities);
            } catch (error) {
                console.error('‚ùå Erro ao carregar modalidades:', error);
                showError('Erro ao carregar modalidades');
            }
        }
        
        async function loadEventCategoryConfig(eventId) {
            try {
                console.log('üîß Carregando configura√ß√£o de categorias do evento via API REST...');
                const response = await fetch(`/api/events/${eventId}/category-configs`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        // Endpoint pode n√£o existir ainda - retornar vazio
                        return [];
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const config = result.configs || result.data || [];
                
                console.log('‚úÖ Configura√ß√£o de categorias carregada via API REST:', config.length);
                return config;
            } catch (error) {
                console.error('‚ùå Erro ao carregar configura√ß√£o de categorias:', error);
                return [];
            }
        }
        
        async function loadEventModalityConfig(eventId) {
            try {
                console.log('üîß Carregando configura√ß√£o de modalidades do evento via API REST...');
                const response = await fetch(`/api/events/${eventId}/modality-configs`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        // Endpoint pode n√£o existir ainda - retornar vazio
                        return [];
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const config = result.configs || result.data || [];
                
                console.log('‚úÖ Configura√ß√£o de modalidades carregada via API REST:', config.length);
                return config;
            } catch (error) {
                console.error('‚ùå Erro ao carregar configura√ß√£o de modalidades:', error);
                return [];
            }
        }
        
        function renderCategoriesConfig(categories) {
            const container = document.getElementById('categoriesConfig');
            if (!container) return;
            
            let html = '';
            categories.forEach(category => {
                const genderText = category.gender === 'M' ? 'Masculino' : 
                                 category.gender === 'F' ? 'Feminino' : 'Misto';
                
                html += `
                    <div class="checkbox-item">
                        <input type="checkbox" 
                               id="category_${category.id}" 
                               value="${category.id}"
                               data-category='${JSON.stringify(category)}'>
                        <label for="category_${category.id}">
                            <span class="category-icon">${category.icon}</span>
                            <div class="category-info">
                                <div class="category-name">${category.name}</div>
                                <div class="category-details">${genderText} ‚Ä¢ ${category.min_age}-${category.max_age} anos</div>
                            </div>
                        </label>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function renderModalitiesConfig(modalities) {
            const container = document.getElementById('modalitiesConfig');
            if (!container) return;
            
            let html = '';
            modalities.forEach(modality => {
                html += `
                    <div class="checkbox-item">
                        <input type="checkbox" 
                               id="modality_${modality.id}" 
                               value="${modality.id}"
                               data-modality='${JSON.stringify(modality)}'
                               onchange="handleModalityChange('${modality.id}', '${modality.name}')">
                        <label for="modality_${modality.id}">
                            <span class="category-icon">${modality.icon}</span>
                            <div class="category-info">
                                <div class="category-name">${modality.name}</div>
                                <div class="category-details">${modality.description || ''}</div>
                            </div>
                        </label>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function updateCategoryCheckboxes(categoryConfig) {
            // Clear all checkboxes first
            const checkboxes = document.querySelectorAll('#categoriesConfig input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Check enabled categories
            categoryConfig.forEach(config => {
                if (config.is_enabled) {
                    const checkbox = document.getElementById(`category_${config.age_category_id}`);
                    if (checkbox) {
                        checkbox.checked = true;
                    }
                }
            });
        }
        
        function updateModalityCheckboxes(modalityConfig) {
            // Clear all checkboxes first
            const checkboxes = document.querySelectorAll('#modalitiesConfig input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Check enabled modalities
            modalityConfig.forEach(config => {
                if (config.is_enabled) {
                    const checkbox = document.getElementById(`modality_${config.modality_id}`);
                    if (checkbox) {
                        checkbox.checked = true;
                    }
                }
            });
        }
        
        async function saveCategoryConfigurations(eventId) {
            try {
                console.log('üíæ Salvando configura√ß√µes de categorias via API REST...');
                
                // Get all checked categories
                const checkedCategories = document.querySelectorAll('#categoriesConfig input[type="checkbox"]:checked');
                
                    const configs = Array.from(checkedCategories).map(checkbox => ({
                        event_id: eventId,
                        age_category_id: checkbox.value,
                        is_enabled: true
                    }));
                    
                // Usar API REST para salvar configura√ß√µes de categorias
                const response = await fetch(`/api/events/${eventId}/category-configs`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ configs })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ Configura√ß√µes de categorias salvas via API REST:', checkedCategories.length);
                return result;
            } catch (error) {
                console.error('‚ùå Erro ao salvar configura√ß√µes de categorias:', error);
                throw error;
            }
        }
        
        async function saveModalityConfigurations(eventId) {
            try {
                console.log('üíæ Salvando configura√ß√µes de modalidades via API REST...');
                
                // Get all checked modalities
                const checkedModalities = document.querySelectorAll('#modalitiesConfig input[type="checkbox"]:checked');
                
                    const configs = Array.from(checkedModalities).map(checkbox => ({
                        event_id: eventId,
                        modality_id: checkbox.value,
                        is_enabled: true
                    }));
                    
                // Usar API REST para salvar configura√ß√µes de modalidades
                const response = await fetch(`/api/events/${eventId}/modality-configs`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ configs })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ Configura√ß√µes de modalidades salvas via API REST:', checkedModalities.length);
                return result;
            } catch (error) {
                console.error('‚ùå Erro ao salvar configura√ß√µes de modalidades:', error);
                throw error;
            }
        }
        
        async function saveEventConfig() {
            if (!currentEvent || !currentEvent.id) {
                showError('Nenhum evento selecionado');
                return;
            }
            
            try {
                const eventName = document.getElementById('eventName')?.value?.trim() || '';
                const eventDate = document.getElementById('eventDate')?.value || '';
                const eventTime = document.getElementById('eventTime')?.value || '';
                const eventLocation = document.getElementById('eventLocation')?.value?.trim() || '';
                const eventType = document.getElementById('eventType')?.value || 'running';
                const eventDistance = document.getElementById('eventDistance')?.value || '';
                console.log('üìä Valores do formul√°rio:', {
                    eventDistance: eventDistance,
                    eventDistanceType: typeof eventDistance,
                    eventDistanceParsed: eventDistance ? parseFloat(eventDistance) : null
                });
                const eventStatus = document.getElementById('eventStatus')?.value || 'active';
                const hasCategories = document.getElementById('hasCategories')?.value === 'true';
                const autoStartEnabled = document.getElementById('autoStartEnabled')?.value === 'true';
                const scheduledStartTimeElement = document.getElementById('scheduledStartTime');
                const scheduledStartTime = scheduledStartTimeElement?.value || '';
                const eventDescription = document.getElementById('eventDescription')?.value?.trim() || '';
                
                console.log('‚è∞ [saveEventConfig] Campo scheduledStartTime:', {
                    elemento: scheduledStartTimeElement,
                    valor: scheduledStartTime,
                    tipo: typeof scheduledStartTime,
                    isEmpty: !scheduledStartTime,
                    valorAtualNoFormulario: scheduledStartTimeElement?.value
                });
                
                // Validar nome obrigat√≥rio
                if (!eventName) {
                    showError('O nome do evento √© obrigat√≥rio');
                    document.getElementById('eventName')?.focus();
                    return;
                }
                
                // Combine date and time
                let eventDateTime = null;
                
                // Determinar qual data usar (do formul√°rio ou do evento atual)
                let dateToUse = eventDate;
                if (!dateToUse && currentEvent?.event_date) {
                    // Se n√£o h√° data no formul√°rio, usar a data atual do evento
                    dateToUse = currentEvent.event_date.split('T')[0];
                }
                
                // Se tem data E hora, combinar ambos
                if (dateToUse && eventTime) {
                    const localDateTime = new Date(`${dateToUse}T${eventTime}`);
                    if (!isNaN(localDateTime.getTime())) {
                        eventDateTime = localDateTime.toISOString();
                        console.log('‚úÖ Data e hora combinadas:', {
                            date: dateToUse,
                            time: eventTime,
                            result: eventDateTime
                        });
                    }
                } else if (dateToUse && !eventTime) {
                    // Se s√≥ tem data, preservar hora atual do evento ou usar 00:00
                    let timeToUse = '00:00:00';
                    if (currentEvent?.event_date) {
                        const timePart = currentEvent.event_date.split('T')[1];
                        if (timePart) {
                            timeToUse = timePart.substring(0, 8); // HH:mm:ss
                        }
                    }
                    const localDate = new Date(`${dateToUse}T${timeToUse}`);
                    if (!isNaN(localDate.getTime())) {
                        eventDateTime = localDate.toISOString();
                        console.log('‚úÖ Apenas data atualizada (hora preservada):', eventDateTime);
                    }
                } else if (eventTime && !dateToUse) {
                    // Se s√≥ tem hora (sem data), usar data de hoje
                    const today = new Date().toISOString().split('T')[0];
                    const localDateTime = new Date(`${today}T${eventTime}`);
                    if (!isNaN(localDateTime.getTime())) {
                        eventDateTime = localDateTime.toISOString();
                        console.log('‚ö†Ô∏è Apenas hora preenchida - usando data de hoje:', eventDateTime);
                    }
                }
                
                // Log para debug
                console.log('üìÖ Processamento de data/hora:', {
                    eventDateFromForm: eventDate,
                    eventTimeFromForm: eventTime,
                    dateToUse: dateToUse,
                    eventDateTime: eventDateTime,
                    currentEventDate: currentEvent?.event_date,
                    hasDateTime: !!eventDateTime
                });
                
                // Preparar dados para API (campos b√°sicos suportados pela API)
                const apiUpdateData = {
                    name: eventName,
                    description: eventDescription || null,
                    location: eventLocation || null,
                    status: eventStatus,
                    distance_km: eventDistance ? parseFloat(eventDistance) : null,
                    event_type: eventType,
                    has_categories: hasCategories === 'true'
                };
                
                // Incluir event_date apenas se foi calculado
                if (eventDateTime) {
                    apiUpdateData.event_date = eventDateTime;
                    console.log('üì§ Enviando event_date para API:', eventDateTime);
                } else if (eventTime || eventDate) {
                    // Se o usu√°rio preencheu hora ou data mas eventDateTime √© null, avisar
                    console.warn('‚ö†Ô∏è Hora/data preenchida mas eventDateTime √© null:', { eventDate, eventTime });
                }
                
                // Incluir scheduled_start_time se foi preenchido
                if (scheduledStartTime && scheduledStartTime.trim() !== '') {
                    try {
                        // scheduledStartTime vem no formato datetime-local (YYYY-MM-DDTHH:mm)
                        // new Date() precisa converter corretamente considerando timezone local
                        const scheduledTimeISO = new Date(scheduledStartTime).toISOString();
                        apiUpdateData.scheduled_start_time = scheduledTimeISO;
                        console.log('üì§ [saveEventConfig] Enviando scheduled_start_time para API:', {
                            valorOriginal: scheduledStartTime,
                            valorISO: scheduledTimeISO,
                            valorAtualNaBD: currentEvent?.scheduled_start_time
                        });
                    } catch (error) {
                        console.error('‚ùå [saveEventConfig] Erro ao converter scheduled_start_time:', error);
                        console.warn('‚ö†Ô∏è [saveEventConfig] scheduled_start_time ignorado devido a erro de convers√£o');
                    }
                } else {
                    console.log('‚ÑπÔ∏è [saveEventConfig] scheduled_start_time n√£o preenchido ou vazio - n√£o ser√° enviado');
                    // Se estava preenchido antes mas agora est√° vazio, enviar null para limpar
                    if (currentEvent?.scheduled_start_time) {
                        apiUpdateData.scheduled_start_time = null;
                        console.log('üóëÔ∏è [saveEventConfig] Limpando scheduled_start_time (estava preenchido mas agora est√° vazio)');
                    }
                }
                
                // Preparar dados completos para Supabase (fallback)
                const supabaseUpdateData = {
                    name: eventName,
                    event_date: eventDateTime,
                    location: eventLocation || null,
                    event_type: eventType,
                    distance_km: eventDistance ? parseFloat(eventDistance) : null,
                    status: eventStatus,
                    has_categories: hasCategories,
                    auto_start_enabled: autoStartEnabled,
                    scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : null,
                    description: eventDescription || null,
                    updated_at: new Date().toISOString()
                };
                
                console.log('üíæ Salvando evento:', {
                    id: currentEvent.id,
                    apiData: apiUpdateData,
                    supabaseData: supabaseUpdateData,
                    distance_km_enviado: apiUpdateData.distance_km,
                    distance_km_tipo: typeof apiUpdateData.distance_km
                });
                
                // Usar API REST que bypassa RLS e garante permiss√µes adequadas
                try {
                    const response = await fetch(`/api/events/${currentEvent.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        credentials: 'include',
                        body: JSON.stringify(apiUpdateData)
                    });
                    
                    const apiResult = await response.json();
                    
                    if (!response.ok || !apiResult.success) {
                        const errorMsg = apiResult.error || `Erro HTTP ${response.status}`;
                        console.error('‚ùå Erro na API:', errorMsg);
                        throw new Error(errorMsg);
                    }
                    
                    console.log('‚úÖ Evento atualizado via API com sucesso:', apiResult.event);
                    console.log('üì• event_date retornado pela API:', apiResult.event?.event_date);
                    console.log('üì• distance_km retornado pela API:', apiResult.event?.distance_km, 'tipo:', typeof apiResult.event?.distance_km);
                    console.log('üì• event_type retornado pela API:', apiResult.event?.event_type);
                    console.log('üì• scheduled_start_time retornado pela API:', apiResult.event?.scheduled_start_time, 'tipo:', typeof apiResult.event?.scheduled_start_time);
                    
                    // Verificar se scheduled_start_time foi atualizado corretamente
                    if (apiUpdateData.scheduled_start_time !== undefined) {
                        const sentScheduledTime = apiUpdateData.scheduled_start_time;
                        const returnedScheduledTime = apiResult.event?.scheduled_start_time || null;
                        
                        // Comparar valores (normalizar para ISO string)
                        const sentISO = sentScheduledTime ? new Date(sentScheduledTime).toISOString() : null;
                        const returnedISO = returnedScheduledTime ? new Date(returnedScheduledTime).toISOString() : null;
                        
                        console.log('üîç Verificando scheduled_start_time:', {
                            enviado: sentScheduledTime,
                            enviadoISO: sentISO,
                            retornado: returnedScheduledTime,
                            retornadoISO: returnedISO,
                            saoDiferentes: sentISO !== returnedISO
                        });
                        
                        if (sentISO !== returnedISO && sentScheduledTime) {
                            console.warn('‚ö†Ô∏è scheduled_start_time retornado pela API difere do enviado. Atualizando novamente via API REST...');
                            try {
                                const scheduledTimeUpdateResponse = await fetch(`/api/events/${currentEvent.id}`, {
                                    method: 'PUT',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    credentials: 'include',
                                    body: JSON.stringify({ scheduled_start_time: sentScheduledTime })
                                });
                                
                                if (scheduledTimeUpdateResponse.ok) {
                                    const scheduledTimeUpdateResult = await scheduledTimeUpdateResponse.json();
                                    console.log('‚úÖ scheduled_start_time atualizado via API REST:', sentScheduledTime);
                                    if (apiResult.event && scheduledTimeUpdateResult.event) {
                                        apiResult.event.scheduled_start_time = scheduledTimeUpdateResult.event.scheduled_start_time || sentScheduledTime;
                                    }
                                } else {
                                    console.error('‚ùå Erro ao atualizar scheduled_start_time via API REST:', scheduledTimeUpdateResponse.status);
                                }
                            } catch (scheduledTimeUpdateErr) {
                                console.error('‚ùå Erro ao atualizar scheduled_start_time via API REST:', scheduledTimeUpdateErr);
                            }
                        } else if (sentISO === returnedISO) {
                            console.log('‚úÖ scheduled_start_time j√° est√° correto no resultado da API:', returnedISO);
                        }
                    }
                    
                    // Verificar se a hora foi preservada
                    if (apiResult.event?.event_date && eventDateTime) {
                        const returnedDate = apiResult.event.event_date;
                        const hasTime = returnedDate.includes('T') || returnedDate.includes(' ') || returnedDate.length > 10;
                        console.log('üîç Verifica√ß√£o de hora:', {
                            returnedDate,
                            hasTime,
                            returnedLength: returnedDate.length,
                            originalSent: eventDateTime
                        });
                        
                        // Se a hora foi perdida, atualizar diretamente via Supabase
                        if (!hasTime && eventTime) {
                            console.warn('‚ö†Ô∏è A hora foi perdida na resposta da API! Atualizando via API REST...');
                            try {
                                const dateUpdateResponse = await fetch(`/api/events/${currentEvent.id}`, {
                                    method: 'PUT',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    credentials: 'include',
                                    body: JSON.stringify({ event_date: eventDateTime })
                                });
                                
                                if (dateUpdateResponse.ok) {
                                    const dateUpdateResult = await dateUpdateResponse.json();
                                    console.log('‚úÖ event_date atualizado via API REST com hora:', eventDateTime);
                                    if (apiResult.event && dateUpdateResult.event) {
                                        apiResult.event.event_date = dateUpdateResult.event.event_date || eventDateTime;
                                    }
                                } else {
                                    console.error('‚ùå Erro ao atualizar event_date via API REST:', dateUpdateResponse.status);
                                }
                            } catch (dateUpdateErr) {
                                console.error('‚ùå Erro ao atualizar event_date via API REST:', dateUpdateErr);
                            }
                        }
                    }
                    
                    // Se h√° hora preenchida, garantir que est√° salva corretamente via API REST
                    if (eventDateTime && eventTime) {
                        console.log('üîÑ Garantindo que event_date com hora est√° salvo via API REST...');
                        try {
                            const dateConfirmResponse = await fetch(`/api/events/${currentEvent.id}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                credentials: 'include',
                                body: JSON.stringify({ event_date: eventDateTime })
                            });
                            
                            if (dateConfirmResponse.ok) {
                                const dateConfirmResult = await dateConfirmResponse.json();
                                console.log('‚úÖ event_date com hora confirmado via API REST:', eventDateTime);
                                if (apiResult.event && dateConfirmResult.event) {
                                    apiResult.event.event_date = dateConfirmResult.event.event_date || eventDateTime;
                                }
                            } else {
                                console.warn('‚ö†Ô∏è Erro ao confirmar event_date via API REST:', dateConfirmResponse.status);
                            }
                        } catch (dateConfirmErr) {
                            console.warn('‚ö†Ô∏è Erro ao confirmar event_date via API REST:', dateConfirmErr);
                        }
                    }
                    
                    // SEMPRE atualizar distance_km via Supabase ap√≥s a API (garantia de persist√™ncia)
                    // A API pode n√£o salvar corretamente devido a RLS ou outros problemas
                    if (eventDistance) {
                        const distanceEnviado = parseFloat(eventDistance);
                        const distanceRetornado = apiResult.event?.distance_km;
                        
                        console.log('üîç Verificando distance_km:', {
                            enviado: distanceEnviado,
                            retornado: distanceRetornado,
                            saoDiferentes: distanceEnviado !== distanceRetornado
                        });
                        
                        // Se o valor retornado pela API √© diferente do enviado, fazer UPDATE novamente via API REST
                        // A API REST usa service role e bypassa RLS, ent√£o deve funcionar
                        if (distanceEnviado !== distanceRetornado) {
                            console.log('üîÑ distance_km diferente do enviado, atualizando novamente via API REST...');
                            try {
                                const apiUpdateResponse = await fetch(`/api/events/${currentEvent.id}`, {
                                    method: 'PUT',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    credentials: 'include',
                                    body: JSON.stringify({ distance_km: distanceEnviado })
                                });
                                
                                if (apiUpdateResponse.ok) {
                                    const apiUpdateResult = await apiUpdateResponse.json();
                                    if (apiUpdateResult.success && apiUpdateResult.event?.distance_km) {
                                        const distanceFinal = apiUpdateResult.event.distance_km;
                                        console.log('‚úÖ distance_km atualizado via API REST (2¬™ tentativa):', distanceFinal);
                                        
                                        // Atualizar apiResult.event com o valor confirmado
                                        if (apiResult.event) {
                                            apiResult.event.distance_km = distanceFinal;
                                        }
                                    } else {
                                        console.warn('‚ö†Ô∏è API REST retornou sucesso mas distance_km n√£o foi atualizado');
                                        // Mesmo assim, usar o valor enviado
                                        if (apiResult.event) {
                                            apiResult.event.distance_km = distanceEnviado;
                                        }
                                    }
                                } else {
                                    const errorText = await apiUpdateResponse.text();
                                    console.warn('‚ö†Ô∏è Erro ao atualizar distance_km via API REST (2¬™ tentativa):', apiUpdateResponse.status, errorText);
                                    // Mesmo assim, usar o valor enviado no apiResult
                                    if (apiResult.event) {
                                        apiResult.event.distance_km = distanceEnviado;
                                    }
                                }
                            } catch (apiUpdateErr) {
                                console.warn('‚ö†Ô∏è Exce√ß√£o ao atualizar distance_km via API REST (2¬™ tentativa):', apiUpdateErr);
                                // Mesmo assim, usar o valor enviado no apiResult
                                if (apiResult.event) {
                                    apiResult.event.distance_km = distanceEnviado;
                                }
                            }
                        } else {
                            console.log('‚úÖ distance_km j√° est√° correto no resultado da API:', distanceRetornado);
                        }
                    }
                    
                    // Atualizar outros campos adicionais via API REST se necess√°rio
                    const needsAdditionalUpdate = eventType !== apiResult.event?.event_type ||
                                              hasCategories !== apiResult.event?.has_categories ||
                                              autoStartEnabled !== apiResult.event?.auto_start_enabled ||
                                              (scheduledStartTime ? new Date(scheduledStartTime).toISOString() : null) !== (apiResult.event?.scheduled_start_time || null);
                    
                    if (needsAdditionalUpdate) {
                        console.log('üîÑ Atualizando outros campos adicionais via API REST...');
                        try {
                            const additionalUpdateResponse = await fetch(`/api/events/${currentEvent.id}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                credentials: 'include',
                                body: JSON.stringify({
                                    event_type: eventType,
                                    has_categories: hasCategories,
                                    auto_start_enabled: autoStartEnabled,
                                    scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : null
                                })
                            });
                            
                            if (additionalUpdateResponse.ok) {
                                const additionalUpdateResult = await additionalUpdateResponse.json();
                                console.log('‚úÖ Campos adicionais atualizados via API REST:', additionalUpdateResult.event);
                            } else {
                                console.warn('‚ö†Ô∏è Erro ao atualizar campos adicionais via API REST:', additionalUpdateResponse.status);
                            }
                        } catch (additionalUpdateErr) {
                            console.warn('‚ö†Ô∏è Erro ao atualizar campos adicionais via API REST:', additionalUpdateErr);
                        }
                    }
                    
                    // Atualizar currentEvent com os dados retornados
                    // IMPORTANTE: Garantir que event_date inclua a hora se foi fornecida
                    if (apiResult.event) {
                        // Se enviamos hora mas API retornou s√≥ data, usar a hora que enviamos
                        if (eventDateTime && eventTime && apiResult.event.event_date && 
                            apiResult.event.event_date.length === 10 && 
                            !apiResult.event.event_date.includes('T')) {
                            console.log('üîß Corrigindo event_date no currentEvent com a hora enviada');
                            apiResult.event.event_date = eventDateTime;
                        }
                        
                        // Garantir que distance_km est√° inclu√≠do no objeto atualizado
                        // Se o valor retornado √© diferente do enviado, usar o valor enviado
                        const distanceEnviado = eventDistance ? parseFloat(eventDistance) : null;
                        const distanceRetornado = apiResult.event.distance_km;
                        
                        if (distanceEnviado !== null && distanceEnviado !== distanceRetornado) {
                            console.warn('‚ö†Ô∏è distance_km retornado pela API (', distanceRetornado, ') difere do enviado (', distanceEnviado, '). Usando valor enviado.');
                            apiResult.event.distance_km = distanceEnviado;
                        } else if (distanceEnviado !== null && apiResult.event.distance_km === undefined) {
                            console.log('üîß Adicionando distance_km ao resultado da API:', distanceEnviado);
                            apiResult.event.distance_km = distanceEnviado;
                        }
                        
                        // Garantir que event_type est√° inclu√≠do
                        if (eventType && apiResult.event.event_type === undefined) {
                            console.log('üîß Adicionando event_type ao resultado da API:', eventType);
                            apiResult.event.event_type = eventType;
                        } else if (eventType && apiResult.event.event_type !== eventType) {
                            console.warn('‚ö†Ô∏è event_type retornado pela API difere do enviado. Usando valor enviado.');
                            apiResult.event.event_type = eventType;
                        }
                        
                        currentEvent = { ...currentEvent, ...apiResult.event };
                        console.log('üìù currentEvent atualizado:', {
                            event_date: currentEvent.event_date,
                            distance_km: currentEvent.distance_km,
                            event_type: currentEvent.event_type,
                            location: currentEvent.location,
                            scheduled_start_time: currentEvent.scheduled_start_time
                        });
                    }
                    
                } catch (apiError) {
                    console.error('‚ùå Erro ao chamar API:', apiError);
                    
                    // N√£o fazer fallback para Supabase direto - mostrar erro ao usu√°rio
                    showError(`Erro ao salvar configura√ß√µes: ${apiError.message || 'Erro desconhecido'}`);
                    return;
                }
                
                // Save category configurations
                try {
                await saveCategoryConfigurations(currentEvent.id);
                } catch (err) {
                    console.warn('‚ö†Ô∏è Erro ao salvar categorias:', err);
                }
                
                // Save modality configurations
                try {
                await saveModalityConfigurations(currentEvent.id);
                } catch (err) {
                    console.warn('‚ö†Ô∏è Erro ao salvar modalidades:', err);
                }
                
                // Save lap counter configuration
                try {
                await saveLapCounterConfig(currentEvent.id);
                } catch (err) {
                    console.warn('‚ö†Ô∏è Erro ao salvar configura√ß√£o de voltas:', err);
                }
                
                // Save dorsal nomenclature configuration (includes assignment mode)
                try {
                await saveDorsalNomenclatureConfig(currentEvent.id);
                } catch (err) {
                    console.warn('‚ö†Ô∏è Erro ao salvar configura√ß√£o de dorsais:', err);
                }
                
                showSuccess('Configura√ß√µes salvas com sucesso!');
                
                // Atualizar campos do formul√°rio diretamente com os dados salvos
                // (evitar reload que pode perder a hora por causa da API)
                // Garantir que currentEvent tem a hora correta antes de atualizar o formul√°rio
                if (eventDateTime && eventTime && currentEvent?.event_date && 
                    currentEvent.event_date.length === 10 && 
                    !currentEvent.event_date.includes('T')) {
                    currentEvent.event_date = eventDateTime;
                    console.log('üîß Corrigindo currentEvent.event_date antes de atualizar formul√°rio:', currentEvent.event_date);
                }
                
                // Atualizar apenas os campos do formul√°rio sem recarregar tudo da API
                // Isso preserva a hora que acabamos de salvar
                // IMPORTANTE: Preservar tamb√©m o distance_km que foi enviado
                if (currentEvent) {
                    // Garantir que distance_km preserva o valor enviado se foi diferente do retornado
                    if (eventDistance) {
                        const distanceEnviado = parseFloat(eventDistance);
                        if (currentEvent.distance_km !== distanceEnviado) {
                            console.log('üîß Corrigindo currentEvent.distance_km com valor enviado:', distanceEnviado);
                            currentEvent.distance_km = distanceEnviado;
                        }
                    }
                    
                    updateFormFields(currentEvent);
                    updateEventDisplay(currentEvent);
                    console.log('‚úÖ Formul√°rio atualizado localmente (preservando hora, dist√¢ncia e scheduled_start_time salvas):', {
                        event_date: currentEvent.event_date,
                        distance_km: currentEvent.distance_km,
                        scheduled_start_time: currentEvent.scheduled_start_time
                    });
                }
                
            } catch (error) {
                console.error('‚ùå Erro ao salvar evento:', error);
                showError(`Erro ao salvar configura√ß√µes: ${error.message || 'Erro desconhecido'}`);
            }
        }
        
        function resetEventConfig() {
            if (currentEvent) {
                updateFormFields(currentEvent);
                showSuccess('Formul√°rio resetado');
            }
        }
        
        async function deleteEvent() {
            if (!currentEvent) {
                showError('Nenhum evento selecionado');
                return;
            }
            
            if (!confirm(`Tem certeza que deseja excluir o evento "${currentEvent.name}"? Esta a√ß√£o n√£o pode ser desfeita.`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/events/${currentEvent.id}`, {
                    method: 'DELETE',
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                showSuccess('Evento exclu√≠do com sucesso!');
                
                // Reset form
                hideEventInfo();
                
                // Reload events
                await loadEvents();
                
            } catch (error) {
                console.error('Erro ao excluir evento:', error);
                showError(`Erro ao excluir evento: ${error.message || 'Erro desconhecido'}`);
            }
        }
        
        // =====================================================
        // FUN√á√ïES PARA CHECKPOINT TYPES (GLOBAL)
        // =====================================================
        
        async function loadCheckpointTypes() {
            try {
                console.log('üìç Carregando tipos de checkpoints via API REST...');
                const response = await fetch('/api/config/checkpoint-types', {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const types = result.types || result.data || [];
                
                console.log('‚úÖ Tipos de checkpoints carregados via API REST:', types.length);
                renderCheckpointTypesConfig(types);
            } catch (error) {
                console.error('‚ùå Erro ao carregar tipos:', error);
                const container = document.getElementById('checkpointTypesConfig');
                container.innerHTML = `
                    <div style="padding: var(--spacing-4); background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); border-radius: var(--radius-base); color: var(--danger);">
                        ‚ùå Erro ao carregar tipos. Execute <strong>create-checkpoint-types.sql</strong> no Supabase.
                    </div>
                `;
            }
        }
        
        function renderCheckpointTypesConfig(types) {
            const container = document.getElementById('checkpointTypesConfig');
            
            if (types.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary);">Nenhum tipo configurado</p>';
                return;
            }
            
            container.innerHTML = types.map(type => `
                <div style="display: flex; align-items: center; gap: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: var(--radius-base); margin-bottom: var(--spacing-2); border-left: 4px solid ${type.color};">
                    <div style="font-size: var(--font-size-2xl); flex-shrink: 0;">${type.icon}</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; color: var(--text-primary); margin-bottom: var(--spacing-1);">${type.name}</div>
                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">
                            ${type.description || ''} ‚Ä¢ 
                            ${type.is_start ? 'üèÅ In√≠cio' : ''}
                            ${type.is_finish ? 'üèÅ Meta' : ''}
                            ${type.is_intermediate ? 'üìç Interm√©dio' : ''} ‚Ä¢ 
                            Splits: ${type.requires_split ? '‚úì' : '‚úó'}
                        </div>
                    </div>
                    <div style="display: flex; gap: var(--spacing-1);">
                        <button class="btn btn-sm btn-ghost" onclick="toggleCheckpointType('${type.code}', ${!type.is_active})" title="${type.is_active ? 'Desativar' : 'Ativar'}">
                            ${type.is_active ? '‚úì' : '‚úó'}
                        </button>
                    </div>
                </div>
            `).join('');
        }
        
        async function toggleCheckpointType(code, activate) {
            try {
                const response = await fetch(`/api/config/checkpoint-types/${code}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ is_active: activate })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                showSuccess(`Tipo ${activate ? 'ativado' : 'desativado'}!`);
                await loadCheckpointTypes();
                
            } catch (error) {
                console.error('‚ùå Erro ao atualizar tipo:', error);
                showError(`Erro ao atualizar tipo: ${error.message}`);
            }
        }
        
        // Setup listeners for checkpoint types
        document.addEventListener('DOMContentLoaded', () => {
            const addCheckpointTypeBtn = document.getElementById('addCheckpointTypeBtn');
            const refreshCheckpointTypesBtn = document.getElementById('refreshCheckpointTypesBtn');
            
            if (addCheckpointTypeBtn) {
                addCheckpointTypeBtn.addEventListener('click', () => {
                    showSuccess('Funcionalidade em desenvolvimento. Use SQL para adicionar tipos personalizados.');
                });
            }
            
            if (refreshCheckpointTypesBtn) {
                refreshCheckpointTypesBtn.addEventListener('click', loadCheckpointTypes);
            }
        });
        
        function showError(message) {
            // Simple error display - you can enhance this with toast notifications
            alert(`‚ùå ${message}`);
        }
        
        function showSuccess(message) {
            // Simple success display - you can enhance this with toast notifications
            alert(`‚úÖ ${message}`);
        }
        
        // Processor Configuration Functions
        function initializeProcessorConfig() {
            console.log('ü§ñ Inicializando configura√ß√£o do processador...');
            
            // Processor type selection
            const processorTypeSelect = document.getElementById('processorType');
            if (processorTypeSelect) {
                processorTypeSelect.addEventListener('change', handleProcessorTypeChange);
            }
            
            // Processor speed selection
            const processorSpeedSelect = document.getElementById('processorSpeed');
            if (processorSpeedSelect) {
                processorSpeedSelect.addEventListener('change', handleProcessorSpeedChange);
            }
            
            // Confidence range
            const confidenceRange = document.getElementById('processorConfidence');
            if (confidenceRange) {
                confidenceRange.addEventListener('input', handleConfidenceChange);
            }
            
            // OpenAI model selection
            const openaiModelSelect = document.getElementById('openaiModel');
            if (openaiModelSelect) {
                openaiModelSelect.addEventListener('change', handleOpenAIModelChange);
            }
            
            // Gemini model selection
            const geminiModelSelect = document.getElementById('geminiModel');
            if (geminiModelSelect) {
                geminiModelSelect.addEventListener('change', saveProcessorConfig);
            }
            
            // Reload models button
            const reloadModelsBtn = document.getElementById('reloadModelsBtn');
            if (reloadModelsBtn) {
                reloadModelsBtn.addEventListener('click', () => {
                    loadOpenAIModels();
                });
            }
            
            // Reload Gemini models button
            const reloadGeminiModelsBtn = document.getElementById('reloadGeminiModelsBtn');
            if (reloadGeminiModelsBtn) {
                reloadGeminiModelsBtn.addEventListener('click', () => {
                    loadGeminiModels();
                });
            }
            
            // DeepSeek model reload button
            const reloadDeepSeekModelsBtn = document.getElementById('reloadDeepSeekModelsBtn');
            if (reloadDeepSeekModelsBtn) {
                reloadDeepSeekModelsBtn.addEventListener('click', () => {
                    loadDeepSeekModels();
                });
            }
            
            // DeepSeek model selection
            const deepseekModelSelect = document.getElementById('deepseekModel');
            if (deepseekModelSelect) {
                deepseekModelSelect.addEventListener('change', saveProcessorConfig);
            }
            
            // Processor info cards
            const processorCards = document.querySelectorAll('.processor-info-card');
            processorCards.forEach(card => {
                card.addEventListener('click', () => selectProcessorCard(card));
            });
            
            // Load saved processor config
            loadProcessorConfig();
        }
        
        function handleProcessorTypeChange(event) {
            const selectedType = event.target.value;
            console.log('üîß Tipo de processador alterado:', selectedType);
            
            // Update processor cards selection
            updateProcessorCardsSelection(selectedType);
            
            // Update processor speed options based on type
            updateProcessorSpeedOptions(selectedType);
            
            // Show/hide model selectors
            const openaiModelGroup = document.getElementById('openaiModelGroup');
            const geminiModelGroup = document.getElementById('geminiModelGroup');
            const deepseekModelGroup = document.getElementById('deepseekModelGroup');
            
            if (openaiModelGroup) {
                if (selectedType === 'openai') {
                    openaiModelGroup.style.display = 'block';
                    loadOpenAIModels();
                } else {
                    openaiModelGroup.style.display = 'none';
                }
            }
            
            if (geminiModelGroup) {
                if (selectedType === 'gemini') {
                    geminiModelGroup.style.display = 'block';
                    loadGeminiModels();
                } else {
                    geminiModelGroup.style.display = 'none';
                }
            }
            
            if (deepseekModelGroup) {
                if (selectedType === 'deepseek') {
                    deepseekModelGroup.style.display = 'block';
                    loadDeepSeekModels();
                } else {
                    deepseekModelGroup.style.display = 'none';
                }
            }
            
            // Save configuration
            saveProcessorConfig();
        }
        
        async function loadGeminiModels() {
            const geminiModelSelect = document.getElementById('geminiModel');
            if (!geminiModelSelect) return;
            
            try {
                geminiModelSelect.innerHTML = '<option value="">Carregando...</option>';
                
                const response = await fetch('/api/gemini/models');
                const data = await response.json();
                
                if (data.success && data.models) {
                    geminiModelSelect.innerHTML = '';
                    
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name} ($${model.pricing.input}/1M tokens)`;
                        geminiModelSelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Erro ao carregar modelos Gemini:', error);
                geminiModelSelect.innerHTML = '<option value="">Erro ao carregar modelos</option>';
            }
        }
        
        async function loadOpenAIModels() {
            const openaiModelSelect = document.getElementById('openaiModel');
            if (!openaiModelSelect) return;
            
            try {
                openaiModelSelect.innerHTML = '<option value="">Carregando...</option>';
                
                const response = await fetch('/api/openai/models');
                const data = await response.json();
                
                if (data.success && data.models) {
                    openaiModelSelect.innerHTML = '';
                    
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name} ($${model.pricing.input}/1K input, $${model.pricing.output}/1K output)`;
                        openaiModelSelect.appendChild(option);
                    });
                    
                    // Se h√° valor salvo, selecionar
                    const savedConfig = localStorage.getItem(`visionkrono_processor_config_${currentEvent?.id}`);
                    if (savedConfig) {
                        try {
                            const config = JSON.parse(savedConfig);
                            if (config.openaiModel) {
                                openaiModelSelect.value = config.openaiModel;
                            }
                        } catch (e) {
                            console.error('Erro ao carregar configura√ß√£o salva:', e);
                        }
                    }
                    
                    // Default para gpt-4o se n√£o houver sele√ß√£o
                    if (!openaiModelSelect.value && data.models.length > 0) {
                        const defaultModel = data.models.find(m => m.id.includes('gpt-4o')) || data.models[0];
                        openaiModelSelect.value = defaultModel.id;
                    }
                } else {
                    throw new Error(data.error || 'Erro ao carregar modelos');
                }
            } catch (error) {
                console.error('Erro ao carregar modelos OpenAI:', error);
                openaiModelSelect.innerHTML = '<option value="">Erro ao carregar modelos</option>';
            }
        }
        
        async function loadDeepSeekModels() {
            const deepseekModelSelect = document.getElementById('deepseekModel');
            if (!deepseekModelSelect) return;
            
            try {
                deepseekModelSelect.innerHTML = '<option value="">Carregando...</option>';
                
                const response = await fetch('/api/deepseek/models');
                const data = await response.json();
                
                if (data.success && data.models) {
                    deepseekModelSelect.innerHTML = '';
                    
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name} ($${model.pricing.input}/1M input, $${model.pricing.output}/1M output)`;
                        deepseekModelSelect.appendChild(option);
                    });
                    
                    // Se h√° valor salvo, selecionar
                    const savedConfig = localStorage.getItem(`visionkrono_processor_config_${currentEvent?.id}`);
                    if (savedConfig) {
                        try {
                            const config = JSON.parse(savedConfig);
                            if (config.deepseekModel) {
                                deepseekModelSelect.value = config.deepseekModel;
                            }
                        } catch (e) {
                            console.error('Erro ao carregar configura√ß√£o salva:', e);
                        }
                    }
                    
                    // Default para deepseek-chat se n√£o houver sele√ß√£o
                    if (!deepseekModelSelect.value && data.models.length > 0) {
                        const defaultModel = data.models.find(m => m.id.includes('deepseek-chat')) || data.models[0];
                        deepseekModelSelect.value = defaultModel.id;
                    }
                } else {
                    throw new Error(data.error || 'Erro ao carregar modelos');
                }
            } catch (error) {
                console.error('Erro ao carregar modelos DeepSeek:', error);
                deepseekModelSelect.innerHTML = '<option value="">Erro ao carregar modelos</option>';
            }
        }
        
        function handleProcessorSpeedChange(event) {
            const selectedSpeed = event.target.value;
            console.log('‚ö° Velocidade alterada:', selectedSpeed);
            saveProcessorConfig();
        }
        
        function handleOpenAIModelChange(event) {
            const selectedModel = event.target.value;
            console.log('ü§ñ Modelo OpenAI alterado:', selectedModel);
            saveProcessorConfig();
        }
        
        function handleConfidenceChange(event) {
            const confidence = event.target.value;
            const confidenceValue = document.getElementById('confidenceValue');
            if (confidenceValue) {
                confidenceValue.textContent = Math.round(confidence * 100) + '%';
            }
            console.log('üéØ Confian√ßa alterada:', confidence);
            saveProcessorConfig();
        }
        
        function selectProcessorCard(card) {
            const processorType = card.dataset.processor;
            console.log('üéØ Processador selecionado:', processorType);
            
            // Update select
            const processorTypeSelect = document.getElementById('processorType');
            if (processorTypeSelect) {
                processorTypeSelect.value = processorType;
            }
            
            // Update cards selection
            updateProcessorCardsSelection(processorType);
            
            // Update speed options
            updateProcessorSpeedOptions(processorType);
            
            // Save configuration
            saveProcessorConfig();
        }
        
        function updateProcessorCardsSelection(selectedType) {
            const processorCards = document.querySelectorAll('.processor-info-card');
            processorCards.forEach(card => {
                if (card.dataset.processor === selectedType) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });
        }
        
        function updateProcessorSpeedOptions(processorType) {
            const speedSelect = document.getElementById('processorSpeed');
            if (!speedSelect) return;
            
            // Clear existing options
            speedSelect.innerHTML = '';
            
            // Add options based on processor type
            const speedOptions = {
                'gemini': [
                    { value: 'fast', text: '‚ö° R√°pido (Menos Precis√£o)' },
                    { value: 'balanced', text: '‚öñÔ∏è Equilibrado (Padr√£o)' },
                    { value: 'accurate', text: 'üéØ Preciso (Mais Lento)' }
                ],
                'openai': [
                    { value: 'fast', text: '‚ö° R√°pido (Menos Precis√£o)' },
                    { value: 'balanced', text: '‚öñÔ∏è Equilibrado (Padr√£o)' },
                    { value: 'accurate', text: 'üéØ Preciso (Mais Lento)' }
                ],
                'google-vision': [
                    { value: 'fast', text: '‚ö° R√°pido (Menos Precis√£o)' },
                    { value: 'balanced', text: '‚öñÔ∏è Equilibrado (Padr√£o)' }
                ],
                'ocr': [
                    { value: 'fast', text: '‚ö° R√°pido (Menos Precis√£o)' },
                    { value: 'balanced', text: '‚öñÔ∏è Equilibrado (Padr√£o)' }
                ],
                'hybrid': [
                    { value: 'balanced', text: '‚öñÔ∏è Equilibrado (Padr√£o)' },
                    { value: 'accurate', text: 'üéØ Preciso (Mais Lento)' }
                ],
                'manual': [
                    { value: 'manual', text: '‚úã Manual (Sem IA)' }
                ]
            };
            
            const options = speedOptions[processorType] || speedOptions['gemini'];
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option.value;
                optionElement.textContent = option.text;
                speedSelect.appendChild(optionElement);
            });
            
            // Set default to balanced if available
            if (speedSelect.querySelector('option[value="balanced"]')) {
                speedSelect.value = 'balanced';
            } else {
                speedSelect.value = speedSelect.firstElementChild.value;
            }
        }
        
        function loadProcessorConfig() {
            if (!currentEvent) return;
            
            console.log('üì• Carregando configura√ß√£o do processador...');
            
            // Load from event configuration or use defaults
            const defaultConfig = {
                processorType: 'gemini',
                processorSpeed: 'balanced',
                processorConfidence: 0.7
            };
            
            // Apply configuration
            const processorTypeSelect = document.getElementById('processorType');
            const processorSpeedSelect = document.getElementById('processorSpeed');
            const confidenceRange = document.getElementById('processorConfidence');
            const confidenceValue = document.getElementById('confidenceValue');
            
            if (processorTypeSelect) {
                processorTypeSelect.value = defaultConfig.processorType;
                updateProcessorCardsSelection(defaultConfig.processorType);
                updateProcessorSpeedOptions(defaultConfig.processorType);
            }
            
            if (processorSpeedSelect) {
                processorSpeedSelect.value = defaultConfig.processorSpeed;
            }
            
            if (confidenceRange) {
                confidenceRange.value = defaultConfig.processorConfidence;
            }
            
            if (confidenceValue) {
                confidenceValue.textContent = Math.round(defaultConfig.processorConfidence * 100) + '%';
            }
        }
        
        function saveProcessorConfig() {
            if (!currentEvent) return;
            
            const config = {
                processorType: document.getElementById('processorType')?.value || 'gemini',
                processorSpeed: document.getElementById('processorSpeed')?.value || 'balanced',
                processorConfidence: parseFloat(document.getElementById('processorConfidence')?.value || '0.7'),
                openaiModel: document.getElementById('openaiModel')?.value || 'gpt-4o',
                geminiModel: document.getElementById('geminiModel')?.value || 'gemini-1.5-flash',
                deepseekModel: document.getElementById('deepseekModel')?.value || 'deepseek-chat'
            };
            
            console.log('üíæ Salvando configura√ß√£o do processador:', config);
            
            // Salvar no localStorage
            localStorage.setItem(`visionkrono_processor_config_${currentEvent.id}`, JSON.stringify(config));
            
            // Salvar no Supabase
            saveProcessorConfigToSupabase(config);
        }
        
        async function saveProcessorConfigToSupabase(config) {
            try {
                if (!currentEvent || !currentEvent.id) {
                    console.log('‚ö†Ô∏è Nenhum evento selecionado');
                    return;
                }
                
                const response = await fetch(`/api/events/${currentEvent.id}/processor-config`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        processor_type: config.processorType,
                        processor_speed: config.processorSpeed,
                        processor_confidence: config.processorConfidence,
                        openai_model: config.openaiModel || 'gpt-4o',
                        gemini_model: config.geminiModel || 'gemini-1.5-flash',
                        deepseek_model: config.deepseekModel || 'deepseek-chat'
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ Configura√ß√£o salva via API REST:', result);
                showSuccess('Configura√ß√£o do processador salva com sucesso!');
                
            } catch (error) {
                console.error('‚ùå Erro ao salvar configura√ß√£o:', error);
                showError(`Erro ao salvar configura√ß√£o no servidor: ${error.message}`);
            }
        }
        
        async function loadProcessorConfig() {
            if (!currentEvent) return;
            
            console.log('üì• Carregando configura√ß√£o do processador...');
            
            // Tentar carregar do Supabase primeiro
            let config = await loadProcessorConfigFromSupabase();
            
            // Se n√£o encontrar no Supabase, tentar localStorage
            if (!config) {
                const localConfig = localStorage.getItem(`visionkrono_processor_config_${currentEvent.id}`);
                if (localConfig) {
                    try {
                        config = JSON.parse(localConfig);
                        console.log('üì• Configura√ß√£o carregada do localStorage:', config);
                    } catch (error) {
                        console.error('‚ùå Erro ao carregar configura√ß√£o do localStorage:', error);
                    }
                }
            }
            
            // Usar configura√ß√£o padr√£o se n√£o encontrar nenhuma
            if (!config) {
                config = {
                    processorType: 'gemini',
                    processorSpeed: 'balanced',
                    processorConfidence: 0.7,
                    openaiModel: 'gpt-4o',
                    geminiModel: 'gemini-1.5-flash',
                    deepseekModel: 'deepseek-chat'
                };
                console.log('üì• Usando configura√ß√£o padr√£o:', config);
            }
            
            // Aplicar configura√ß√£o
            const processorTypeSelect = document.getElementById('processorType');
            const processorSpeedSelect = document.getElementById('processorSpeed');
            const confidenceRange = document.getElementById('processorConfidence');
            const confidenceValue = document.getElementById('confidenceValue');
            const openaiModelSelect = document.getElementById('openaiModel');
            const geminiModelSelect = document.getElementById('geminiModel');
            const deepseekModelSelect = document.getElementById('deepseekModel');
            
            if (processorTypeSelect) {
                processorTypeSelect.value = config.processorType;
                updateProcessorCardsSelection(config.processorType);
                updateProcessorSpeedOptions(config.processorType);
            }
            
            if (processorSpeedSelect) {
                processorSpeedSelect.value = config.processorSpeed;
            }
            
            if (confidenceRange) {
                confidenceRange.value = config.processorConfidence;
            }
            
            if (confidenceValue) {
                confidenceValue.textContent = Math.round(config.processorConfidence * 100) + '%';
            }
            
            if (openaiModelSelect && config.openaiModel) {
                openaiModelSelect.value = config.openaiModel;
            }
            
            if (geminiModelSelect && config.geminiModel) {
                geminiModelSelect.value = config.geminiModel;
            }
            
            if (deepseekModelSelect && config.deepseekModel) {
                deepseekModelSelect.value = config.deepseekModel;
            }
        }
        
        async function loadProcessorConfigFromSupabase() {
            try {
                if (!currentEvent || !currentEvent.id) {
                    return null;
                }
                
                const response = await fetch(`/api/events/${currentEvent.id}/processor-config`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        // Config n√£o existe ainda - retornar null
                    return null;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success && result.config) {
                    // Converter formato da API para formato esperado
                    const config = {
                        processorType: result.config.processor_type || result.config.processorType,
                        processorSpeed: result.config.processor_speed || result.config.processorSpeed,
                        processorConfidence: result.config.processor_confidence || result.config.processorConfidence,
                        openaiModel: result.config.openai_model || result.config.openaiModel || 'gpt-4o',
                        geminiModel: result.config.gemini_model || result.config.geminiModel || 'gemini-1.5-flash',
                        deepseekModel: result.config.deepseek_model || result.config.deepseekModel || 'deepseek-chat'
                    };
                    console.log('‚úÖ Configura√ß√£o carregada via API REST:', config);
                    return config;
                }
                
                return null;
            } catch (error) {
                console.error('‚ùå Erro ao carregar configura√ß√£o:', error);
                return null;
            }
        }
        
        // =====================================================
        // FUN√á√ïES PARA CONTADOR DE VOLTAS
        // =====================================================
        
        async function loadLapCounterConfig(eventId) {
            try {
                console.log('üîÑ Carregando configura√ß√£o de contador de voltas via API REST...');
                
                // Carregar configura√ß√£o do evento via API REST
                const eventResponse = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!eventResponse.ok) {
                    console.error('‚ùå Erro ao carregar configura√ß√£o do evento:', eventResponse.status);
                    return;
                }
                
                const eventResult = await eventResponse.json();
                const eventData = eventResult.event;
                
                if (!eventData) {
                    console.log('‚ÑπÔ∏è Evento n√£o encontrado ou sem configura√ß√£o de lap counter');
                    return;
                }
                
                // Carregar configura√ß√£o detalhada de voltas via API REST
                const lapResponse = await fetch(`/api/events/${eventId}/lap-config`, {
                    credentials: 'include'
                });
                
                let lapConfig = null;
                if (lapResponse.ok) {
                    const lapResult = await lapResponse.json();
                    lapConfig = lapResult.config || null;
                } else if (lapResponse.status !== 404) {
                    console.error('‚ùå Erro ao carregar configura√ß√£o de voltas:', lapResponse.status);
                }
                
                // Atualizar campos do formul√°rio
                const hasLapCounter = document.getElementById('hasLapCounter');
                const lapDistance = document.getElementById('lapDistance');
                const totalLaps = document.getElementById('totalLaps');
                const minLapsForClassification = document.getElementById('minLapsForClassification');
                
                if (hasLapCounter) {
                    hasLapCounter.value = eventData.has_lap_counter ? 'true' : 'false';
                }
                
                if (lapConfig) {
                    if (lapDistance) lapDistance.value = lapConfig.lap_distance_km || '';
                    if (totalLaps) totalLaps.value = lapConfig.total_laps || '';
                    if (minLapsForClassification) minLapsForClassification.value = lapConfig.min_laps_for_classification || 1;
                } else {
                    if (lapDistance) lapDistance.value = '';
                    if (totalLaps) totalLaps.value = '';
                    if (minLapsForClassification) minLapsForClassification.value = 1;
                }
                
                // Ativar/desativar campos baseado na configura√ß√£o
                handleLapCounterToggle();
                
                // Validar configura√ß√£o
                await validateLapCounterSetup(eventId);
                
            } catch (error) {
                console.error('‚ùå Erro ao carregar configura√ß√£o de voltas:', error);
            }
        }
        
        // Alternar visualiza√ß√£o conforme modo de dorsais
        function handleDorsalModeChange() {
            const mode = document.getElementById('dorsalMode').value;
            
            document.getElementById('dorsalSequentialConfig').style.display = 
                mode === 'sequential' ? 'block' : 'none';
            document.getElementById('dorsalCategoryConfig').style.display = 
                mode === 'per_category' ? 'block' : 'none';
            document.getElementById('dorsalRandomConfig').style.display = 
                mode === 'random' ? 'block' : 'none';
            
            console.log('üî¢ Modo de dorsais alterado:', mode);
        }
        
        // Salvar configura√ß√£o de dorsais
        async function saveDorsalConfig(eventId) {
            try {
                const modeEl = document.getElementById('dorsalMode');
                const startEl = document.getElementById('dorsalStartFrom');
                
                if (!modeEl || !startEl) {
                    console.warn('‚ö†Ô∏è Elementos de config de dorsais n√£o encontrados');
                    return;
                }
                
                const mode = modeEl.value;
                const startFrom = parseInt(startEl.value) || 1;
                
                const dorsalConfig = {
                    mode: mode,
                    start_from: startFrom
                };
                
                // Configura√ß√µes espec√≠ficas por modo
                if (mode === 'random') {
                    const maxEl = document.getElementById('dorsalRandomMax');
                    dorsalConfig.end_at = parseInt(maxEl?.value) || 999;
                } else if (mode === 'per_category') {
                    // TODO: Ler category_ranges dos inputs
                    dorsalConfig.category_ranges = {};
                }
                
                // Atualizar settings do evento via API REST
                const eventResponse = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!eventResponse.ok) {
                    throw new Error(`HTTP ${eventResponse.status}`);
                }
                
                const eventResult = await eventResponse.json();
                const event = eventResult.event;
                
                if (!event) {
                    console.warn('‚ö†Ô∏è Evento n√£o encontrado');
                    return;
                }
                
                const newSettings = {
                    ...(event.settings || {}),
                    dorsal_assignment: dorsalConfig
                };
                
                const updateResponse = await fetch(`/api/events/${eventId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ settings: newSettings })
                });
                
                if (!updateResponse.ok) {
                    const errorData = await updateResponse.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${updateResponse.status}`);
                }
                
                console.log('‚úÖ Configura√ß√£o de dorsais salva:', dorsalConfig);
                
            } catch (error) {
                console.error('‚ùå Erro ao salvar config de dorsais:', error);
                throw error;
            }
        }
        
        // Carregar configura√ß√£o de dorsais
        async function loadDorsalConfig(eventId) {
            try {
                const response = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        console.warn('‚ö†Ô∏è Evento n√£o encontrado para carregar config de dorsais');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const event = result.event;
                
                if (!event) {
                    console.warn('‚ö†Ô∏è Evento n√£o encontrado para carregar config de dorsais');
                    return;
                }
                
                const dorsalConfig = event.settings?.dorsal_assignment || {
                    mode: 'sequential',
                    start_from: 1
                };
                
                // Preencher form
                const modeSelect = document.getElementById('dorsalMode');
                const startFromInput = document.getElementById('dorsalStartFrom');
                
                if (modeSelect) modeSelect.value = dorsalConfig.mode || 'sequential';
                if (startFromInput) startFromInput.value = dorsalConfig.start_from || 1;
                
                if (dorsalConfig.mode === 'random') {
                    const randomMaxInput = document.getElementById('dorsalRandomMax');
                    if (randomMaxInput) randomMaxInput.value = dorsalConfig.end_at || 999;
                }
                
                // Atualizar visualiza√ß√£o
                handleDorsalModeChange();
                
                console.log('‚úÖ Configura√ß√£o de dorsais carregada:', dorsalConfig);
                
            } catch (error) {
                console.error('‚ùå Erro ao carregar config de dorsais:', error);
            }
        }
        
        // Adicionar range de categoria
        function addCategoryRange() {
            alert('Funcionalidade em desenvolvimento');
            // TODO: Adicionar inputs para categoria, start, end
        }
        
        // Alternar configura√ß√£o de nomenclatura
        function handleNomenclatureChange(type) {
            const configs = [
                'numericNomenclatureConfig', 
                'prefixNomenclatureConfig', 
                'suffixNomenclatureConfig', 
                'markersNomenclatureConfig',
                'customNomenclatureConfig'
            ];
            
            configs.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
            
            const targetConfig = type === 'prefix' ? 'prefixNomenclatureConfig' :
                                type === 'suffix' ? 'suffixNomenclatureConfig' :
                                type === 'prefix-suffix' ? 'prefixNomenclatureConfig' : // Mesmo que prefixo por enquanto
                                type === 'markers' ? 'markersNomenclatureConfig' :
                                type === 'custom' ? 'customNomenclatureConfig' :
                                'numericNomenclatureConfig';
            
            const el = document.getElementById(targetConfig);
            if (el) el.style.display = 'block';
            
            console.log('üè∑Ô∏è Nomenclatura alterada:', type);
        }
        
        // Salvar configura√ß√£o de nomenclatura (junto com dorsais)
        async function saveDorsalNomenclatureConfig(eventId) {
            try {
                if (!eventId) {
                    console.warn('‚ö†Ô∏è EventId n√£o fornecido para salvar nomenclatura');
                    return;
                }
                
                console.log('üíæ Salvando nomenclatura para evento:', eventId);
                
                const nomenclatureType = document.querySelector('input[name="nomenclatureType"]:checked')?.value || 'numeric';
                console.log('üìã Tipo de nomenclatura:', nomenclatureType);
                
                const nomenclatureConfig = {
                    type: nomenclatureType
                };
                
                // Configura√ß√µes por tipo (com modo de atribui√ß√£o)
                if (nomenclatureType === 'numeric') {
                    nomenclatureConfig.numeric = {
                        mode: document.getElementById('nomenclatureNumericMode')?.value || 'sequential',
                        min: parseInt(document.getElementById('nomenclatureNumericMin')?.value) || 1,
                        max: parseInt(document.getElementById('nomenclatureNumericMax')?.value) || 9999,
                        use_padding: document.getElementById('nomenclatureUsePadding')?.checked || false,
                        digits: parseInt(document.getElementById('nomenclatureNumericDigits')?.value) || 3
                    };
                } else if (nomenclatureType === 'prefix') {
                    nomenclatureConfig.prefix = {
                        mode: document.getElementById('nomenclaturePrefixMode')?.value || 'sequential',
                        prefixes: document.getElementById('nomenclaturePrefixText')?.value || 'M,F',
                        separator: document.getElementById('nomenclaturePrefixSeparator')?.value || '-',
                        min: parseInt(document.getElementById('nomenclaturePrefixMin')?.value) || 1,
                        max: parseInt(document.getElementById('nomenclaturePrefixMax')?.value) || 999
                    };
                } else if (nomenclatureType === 'suffix') {
                    nomenclatureConfig.suffix = {
                        mode: document.getElementById('nomenclatureSuffixMode')?.value || 'sequential',
                        suffixes: document.getElementById('nomenclatureSuffixText')?.value || 'M,F',
                        separator: document.getElementById('nomenclatureSuffixSeparator')?.value || '-',
                        min: parseInt(document.getElementById('nomenclatureSuffixMin')?.value) || 1,
                        max: parseInt(document.getElementById('nomenclatureSuffixMax')?.value) || 999
                    };
                } else if (nomenclatureType === 'markers') {
                    nomenclatureConfig.markers = {
                        start_color: document.getElementById('nomenclatureStartColor')?.value || '#10b981',
                        end_color: document.getElementById('nomenclatureEndColor')?.value || '#ef4444',
                        tolerance: parseInt(document.getElementById('nomenclatureColorTolerance')?.value) || 20
                    };
                } else if (nomenclatureType === 'custom') {
                    nomenclatureConfig.custom = {
                        regex: document.getElementById('nomenclatureCustomRegex')?.value || '',
                        examples: document.getElementById('nomenclatureCustomExamples')?.value || ''
                    };
                }
                
                // Buscar settings atuais via API REST antes de atualizar
                // (porque currentEvent.settings pode estar desatualizado)
                console.log('üîç Buscando settings atuais do evento antes de atualizar via API REST...');
                
                let currentEventData = null;
                try {
                    const fetchResponse = await fetch(`/api/events/${eventId}`, {
                        credentials: 'include'
                    });
                    
                    if (fetchResponse.ok) {
                        const fetchResult = await fetchResponse.json();
                        currentEventData = fetchResult.event;
                    } else {
                        console.error('‚ùå Erro ao buscar settings atuais:', fetchResponse.status);
                    }
                } catch (fetchErr) {
                    console.error('‚ùå Erro ao buscar settings atuais:', fetchErr);
                }
                
                const currentSettings = (currentEventData?.settings && typeof currentEventData.settings === 'object') 
                    ? currentEventData.settings 
                    : (currentEvent?.settings || {});
                
                console.log('‚úÖ Settings atual (do Supabase):', currentSettings);
                console.log('‚úÖ Settings atual (do currentEvent):', currentEvent?.settings);
                console.log('‚úÖ Settings que ser√° usado:', currentSettings);
                
                // Garantir que currentSettings √© um objeto v√°lido
                const validCurrentSettings = (currentSettings && typeof currentSettings === 'object' && !Array.isArray(currentSettings))
                    ? currentSettings 
                    : {};
                
                let newSettings = {
                    ...validCurrentSettings,
                    dorsal_nomenclature: nomenclatureConfig
                };
                
                console.log('üíæ Novos settings a guardar:', JSON.stringify(newSettings, null, 2));
                console.log('üíæ Tipo de newSettings:', typeof newSettings);
                console.log('üíæ Keys em newSettings:', Object.keys(newSettings));
                
                // Atualizar settings via API REST (bypassa RLS)
                console.log('üîÑ Executando UPDATE via API REST...');
                
                try {
                    const response = await fetch(`/api/events/${eventId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        credentials: 'include', // Incluir cookies para autentica√ß√£o
                        body: JSON.stringify({
                            // Apenas enviar settings (nome n√£o √© obrigat√≥rio se s√≥ atualizarmos settings)
                            settings: newSettings
                        })
                    });
                    
                    const apiResult = await response.json();
                    
                    if (!response.ok || !apiResult.success) {
                        const errorMsg = apiResult.error || 'Erro ao atualizar via API';
                        console.error('‚ùå Erro na API:', errorMsg);
                        throw new Error(errorMsg);
                    }
                    
                    console.log('‚úÖ Resultado do UPDATE via API:', apiResult);
                    console.log('‚úÖ Settings ap√≥s UPDATE (confirma√ß√£o):', apiResult.event?.settings);
                    
                    // Verificar se realmente foi guardado e usar os settings retornados pela API
                    if (apiResult.event?.settings && Object.keys(apiResult.event.settings).length > 0) {
                        // Usar os settings retornados pela API (s√£o os confirmados guardados)
                        newSettings = apiResult.event.settings;
                        console.log('‚úÖ Usando settings confirmados da API');
                    } else {
                        console.warn('‚ö†Ô∏è UPDATE via API n√£o retornou settings. Verificando diretamente...');
                        const verifyResponse = await fetch(`/api/events/${eventId}`, {
                            credentials: 'include'
                        });
                        const verifyResult = await verifyResponse.json();
                        
                        if (verifyResult.success && verifyResult.event?.settings && Object.keys(verifyResult.event.settings).length > 0) {
                            console.log('‚úÖ Verifica√ß√£o direta - settings guardado:', verifyResult.event.settings);
                            newSettings = verifyResult.event.settings;
                        } else {
                            console.error('‚ùå ATEN√á√ÉO: Settings n√£o foi guardado corretamente!');
                        }
                    }
                    
                } catch (apiError) {
                    console.error('‚ùå Erro ao atualizar via API REST:', apiError);
                    // N√£o fazer fallback para Supabase - mostrar erro
                    throw apiError;
                }
                
                // Atualizar currentEvent tamb√©m
                if (currentEvent) {
                    currentEvent.settings = newSettings;
                    console.log('‚úÖ currentEvent.settings atualizado localmente');
                }
                
                console.log('‚úÖ Nomenclatura de dorsais salva com sucesso:', nomenclatureConfig);
                
            } catch (error) {
                console.error('‚ùå Erro ao salvar nomenclatura:', error);
                throw error;
            }
        }
        
        // Carregar configura√ß√£o de nomenclatura
        async function loadDorsalNomenclatureConfig(eventId) {
            try {
                const response = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const event = result.event;
                
                if (!event) return;
                
                const nomenclatureConfig = event.settings?.dorsal_nomenclature || {
                    type: 'numeric',
                    numeric: { min: 1, max: 9999, use_padding: false, digits: 3 }
                };
                
                // Selecionar tipo
                const radioInput = document.querySelector(`input[name="nomenclatureType"][value="${nomenclatureConfig.type}"]`);
                if (radioInput) {
                    radioInput.checked = true;
                    handleNomenclatureChange(nomenclatureConfig.type);
                }
                
                // Preencher campos num√©ricos
                if (nomenclatureConfig.numeric) {
                    const minInput = document.getElementById('nomenclatureNumericMin');
                    const maxInput = document.getElementById('nomenclatureNumericMax');
                    const paddingInput = document.getElementById('nomenclatureUsePadding');
                    const digitsInput = document.getElementById('nomenclatureNumericDigits');
                    
                    if (minInput) minInput.value = nomenclatureConfig.numeric.min || 1;
                    if (maxInput) maxInput.value = nomenclatureConfig.numeric.max || 9999;
                    if (paddingInput) paddingInput.checked = nomenclatureConfig.numeric.use_padding || false;
                    if (digitsInput) digitsInput.value = nomenclatureConfig.numeric.digits || 3;
                }
                
                console.log('‚úÖ Nomenclatura carregada:', nomenclatureConfig);
                
            } catch (error) {
                console.error('‚ùå Erro ao carregar nomenclatura:', error);
            }
        }
        
        function handleLapCounterToggle() {
            const hasLapCounter = document.getElementById('hasLapCounter');
            const lapDistance = document.getElementById('lapDistance');
            const totalLaps = document.getElementById('totalLaps');
            const minLapsForClassification = document.getElementById('minLapsForClassification');
            
            const isEnabled = hasLapCounter && hasLapCounter.value === 'true';
            
            if (lapDistance) lapDistance.disabled = !isEnabled;
            if (totalLaps) totalLaps.disabled = !isEnabled;
            if (minLapsForClassification) minLapsForClassification.disabled = !isEnabled;
            
            // Limpar campos se desativado
            if (!isEnabled) {
                if (lapDistance) lapDistance.value = '';
                if (totalLaps) totalLaps.value = '';
                if (minLapsForClassification) minLapsForClassification.value = 1;
            }
            
            // Validar configura√ß√£o
            if (currentEvent) {
                validateLapCounterSetup(currentEvent.id);
            }
        }
        
        async function validateLapCounterSetup(eventId) {
            try {
                const hasLapCounter = document.getElementById('hasLapCounter');
                const validationDiv = document.getElementById('lapCounterValidation');
                const validationText = document.getElementById('lapCounterValidationText');
                
                if (!hasLapCounter || !validationDiv || !validationText) return;
                
                const isEnabled = hasLapCounter.value === 'true';
                
                if (!isEnabled) {
                    validationDiv.style.display = 'none';
                    return;
                }
                
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    validationText.textContent = 'Erro: Supabase n√£o dispon√≠vel';
                    validationDiv.style.display = 'block';
                    return;
                }
                
                // Verificar se tem dispositivos necess√°rios
                const { data: lapDevices, error: lapError } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .select(`
                        *,
                        checkpoint_types!inner(code, is_finish)
                    `)
                    .eq('event_id', eventId);
                
                if (lapError) {
                    validationText.textContent = 'Erro ao verificar dispositivos';
                    validationDiv.style.display = 'block';
                    return;
                }
                
                const lapCounterDevices = lapDevices.filter(d => d.checkpoint_types.code === 'lap_counter');
                const finishDevices = lapDevices.filter(d => d.checkpoint_types.is_finish);
                
                if (lapCounterDevices.length === 0) {
                    validationText.textContent = 'Necess√°rio pelo menos 1 dispositivo com checkpoint "Contador de Voltas"';
                    validationDiv.style.display = 'block';
                } else if (finishDevices.length === 0) {
                    validationText.textContent = 'Necess√°rio pelo menos 1 dispositivo com checkpoint "Meta"';
                    validationDiv.style.display = 'block';
                } else {
                    validationText.textContent = `‚úÖ Configura√ß√£o v√°lida: ${lapCounterDevices.length} contador(es) de voltas, ${finishDevices.length} meta(s)`;
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = 'rgba(34, 197, 94, 0.1)';
                    validationDiv.style.borderColor = 'var(--success)';
                    validationDiv.style.color = 'var(--success)';
                }
                
            } catch (error) {
                console.error('‚ùå Erro ao validar configura√ß√£o de voltas:', error);
                const validationText = document.getElementById('lapCounterValidationText');
                if (validationText) {
                    validationText.textContent = 'Erro ao validar configura√ß√£o';
                }
            }
        }
        
        async function saveLapCounterConfig(eventId) {
            try {
                console.log('üíæ Salvando configura√ß√£o de contador de voltas via API REST...');
                
                const hasLapCounter = document.getElementById('hasLapCounter');
                const lapDistance = document.getElementById('lapDistance');
                const totalLaps = document.getElementById('totalLaps');
                const minLapsForClassification = document.getElementById('minLapsForClassification');
                
                const isEnabled = hasLapCounter && hasLapCounter.value === 'true';
                const distance = lapDistance && lapDistance.value ? parseFloat(lapDistance.value) : null;
                const totalLapsValue = totalLaps && totalLaps.value ? parseInt(totalLaps.value) : null;
                const minLaps = minLapsForClassification && minLapsForClassification.value ? parseInt(minLapsForClassification.value) : 1;
                
                console.log('üíæ [saveLapCounterConfig] Valores coletados:', {
                    isEnabled,
                    distance,
                    totalLapsValue,
                    minLaps,
                    hasLapCounterValue: hasLapCounter?.value
                });
                
                // Atualizar evento com has_lap_counter (sempre enviar este campo)
                // IMPORTANTE: Enviar como boolean true/false expl√≠cito
                // Converter de string 'true'/'false' para boolean
                let hasLapCounterValue = false; // Default: false
                if (hasLapCounter) {
                    const value = hasLapCounter.value;
                    hasLapCounterValue = (value === 'true' || value === true || value === '1');
                }
                console.log('üíæ [saveLapCounterConfig] Enviando has_lap_counter:', {
                    valorOriginal: hasLapCounter?.value,
                    valorConvertido: hasLapCounterValue,
                    tipo: typeof hasLapCounterValue,
                    isEnabled,
                    payload: JSON.stringify({ has_lap_counter: hasLapCounterValue })
                });
                
                const eventUpdateResponse = await fetch(`/api/events/${eventId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ has_lap_counter: hasLapCounterValue })
                });
                
                if (!eventUpdateResponse.ok) {
                    const errorText = await eventUpdateResponse.text();
                    let errorData;
                    try {
                        errorData = JSON.parse(errorText);
                    } catch {
                        errorData = { error: errorText || 'Erro desconhecido' };
                    }
                    console.error('‚ùå [saveLapCounterConfig] Erro ao atualizar has_lap_counter:', {
                        status: eventUpdateResponse.status,
                        error: errorData
                    });
                    throw new Error(errorData.error || `HTTP ${eventUpdateResponse.status}`);
                }
                
                const eventUpdateResult = await eventUpdateResponse.json();
                console.log('‚úÖ [saveLapCounterConfig] has_lap_counter atualizado:', eventUpdateResult);
                
                // Salvar configura√ß√£o detalhada via API REST apenas se o lap counter estiver ativado
                // ou se j√° existir uma configura√ß√£o para evitar erro de "campos vazios"
                if (isEnabled || distance !== null || totalLapsValue !== null) {
                const configData = {
                    has_lap_counter: isEnabled,
                    lap_distance_km: distance,
                    total_laps: totalLapsValue,
                        min_laps_for_classification: minLaps
                    };
                    
                    console.log('üíæ [saveLapCounterConfig] Enviando config detalhada:', configData);
                    
                    const lapResponse = await fetch(`/api/events/${eventId}/lap-config`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        credentials: 'include',
                        body: JSON.stringify(configData)
                    });
                    
                    if (!lapResponse.ok) {
                        const errorText = await lapResponse.text();
                        let errorData;
                        try {
                            errorData = JSON.parse(errorText);
                        } catch {
                            errorData = { error: errorText || 'Erro desconhecido' };
                        }
                        console.error('‚ùå [saveLapCounterConfig] Erro ao salvar config detalhada:', {
                            status: lapResponse.status,
                            error: errorData
                        });
                        throw new Error(errorData.error || `HTTP ${lapResponse.status}`);
                    }
                    
                    const result = await lapResponse.json();
                    console.log('‚úÖ Configura√ß√£o de voltas salva via API REST:', result);
                } else {
                    console.log('‚ÑπÔ∏è Lap counter desativado e sem dados - apenas has_lap_counter foi atualizado');
                }
                
            } catch (error) {
                console.error('‚ùå Erro ao salvar configura√ß√£o de voltas:', error);
                throw error;
            }
        }
        
        // =====================================================
        // FUN√á√ïES PARA MODALIDADES MULTI-DISCIPLINARES
        // =====================================================
        
        function handleModalityChange(modalityId, modalityName) {
            console.log('üîÑ Modalidade alterada:', modalityName);
            
            // Verificar se √© modalidade multi-disciplinar
            const isMultimodal = ['Duatlo', 'Triatlo'].includes(modalityName);
            const multimodalConfig = document.getElementById('multimodalConfig');
            
            if (isMultimodal) {
                if (multimodalConfig) multimodalConfig.style.display = 'block';
                loadMultimodalActivities(modalityId);
                if (currentEvent && currentEvent.id) {
                    validateMultimodalSetup(currentEvent.id);
                }
            } else {
                if (multimodalConfig) multimodalConfig.style.display = 'none';
            }
        }
        
        async function loadMultimodalActivities(modalityId) {
            try {
                console.log('üèäüö¥üèÉ Carregando atividades multi-disciplinares...');
                
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    console.log('‚ö†Ô∏è Supabase n√£o dispon√≠vel');
                    return;
                }
                
                // Carregar TODAS as atividades (ativas e inativas) para permitir reativa√ß√£o
                const { data: activities, error } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .select('*')
                    .eq('modality_id', modalityId)
                    .order('activity_order');
                
                if (error) {
                    console.error('‚ùå Erro ao carregar atividades:', error);
                    return;
                }
                
                renderMultimodalActivities(activities || []);
                
            } catch (error) {
                console.error('‚ùå Erro ao carregar atividades:', error);
            }
        }
        
        function renderMultimodalActivities(activities) {
            const container = document.getElementById('multimodalActivities');
            if (!container) return;
            
            if (activities.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); padding: var(--spacing-4); text-align: center;">Nenhuma atividade configurada para esta modalidade</p>';
                return;
            }
            
            // Ordenar atividades por ordem
            const sortedActivities = [...activities].sort((a, b) => a.activity_order - b.activity_order);
            
            let html = '<div class="form-grid">';
            sortedActivities.forEach((activity, index) => {
                // Estilo diferente para atividades ativas vs inativas
                const isActive = activity.is_active;
                const opacity = isActive ? '1' : '0.6';
                const backgroundOpacity = isActive ? '1' : '0.3';
                const borderColor = isActive ? activity.activity_color : '#6b7280';
                const isLastActivity = index === sortedActivities.length - 1;
                
                html += `
                    <div class="form-group">
                        <div style="display: flex; align-items: center; gap: var(--spacing-3); padding: var(--spacing-4); background: rgba(255, 255, 255, ${backgroundOpacity}); border: 1px solid var(--border-color); border-radius: var(--radius-base); border-left: 4px solid ${borderColor}; opacity: ${opacity};">
                            <div style="display: flex; flex-direction: column; align-items: center; gap: var(--spacing-1);">
                                <div style="font-size: var(--font-size-2xl); flex-shrink: 0;">${activity.activity_icon}</div>
                                <div style="font-size: var(--font-size-xs); color: var(--text-secondary); font-weight: 600;">#${activity.activity_order}</div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: var(--spacing-1);">
                                    ${activity.activity_name}
                                    ${!isActive ? '<span style="font-size: var(--font-size-xs); color: var(--danger); margin-left: var(--spacing-2);">(Desativada)</span>' : ''}
                                    ${isLastActivity ? '<span style="font-size: var(--font-size-xs); color: var(--primary); margin-left: var(--spacing-2);">(Final)</span>' : ''}
                                </div>
                                <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">
                                    Cor: ${activity.activity_color}
                                    ${isLastActivity ? ' ‚Ä¢ Conta tempo total da prova' : ''}
                                </div>
                            </div>
                            <div style="display: flex; gap: var(--spacing-1); align-items: center;">
                                ${index > 0 ? `
                                    <button class="btn btn-sm btn-ghost" onclick="moveActivity('${activity.id}', 'up')" title="Mover para cima" style="background: var(--primary); color: white; border: none; padding: var(--spacing-1);">
                                        ‚Üë
                                    </button>
                                ` : ''}
                                ${index < sortedActivities.length - 1 ? `
                                    <button class="btn btn-sm btn-ghost" onclick="moveActivity('${activity.id}', 'down')" title="Mover para baixo" style="background: var(--primary); color: white; border: none; padding: var(--spacing-1);">
                                        ‚Üì
                                    </button>
                                ` : ''}
                                <button class="btn btn-sm btn-ghost" onclick="toggleActivity('${activity.id}', ${!activity.is_active})" title="${activity.is_active ? 'Desativar atividade' : 'Ativar atividade'}" style="background: ${activity.is_active ? 'var(--success)' : 'var(--danger)'}; color: white; border: none; min-width: 40px;">
                                    ${activity.is_active ? '‚úì' : '‚úó'}
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            // Adicionar informa√ß√µes sobre checkpoints necess√°rios (apenas atividades ativas)
            const activeActivities = sortedActivities.filter(a => a.is_active);
            if (activeActivities.length > 0) {
                html += `
                    <div style="margin-top: var(--spacing-4); padding: var(--spacing-3); background: rgba(59, 130, 246, 0.1); border: 1px solid var(--primary); border-radius: var(--radius-base);">
                        <h4 style="color: var(--primary); margin-bottom: var(--spacing-2);">üìã Checkpoints Necess√°rios:</h4>
                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">
                            Para eventos multi-disciplinares, voc√™ precisa configurar dispositivos com os seguintes tipos de checkpoint:
                        </div>
                        <ul style="margin-top: var(--spacing-2); font-size: var(--font-size-sm); color: var(--text-secondary);">
                            ${activeActivities.map(activity => {
                                const checkpointType = activity.activity_name === 'Nata√ß√£o' ? 'Meta Nata√ß√£o' : 
                                                    activity.activity_name === 'Ciclismo' ? 'Meta Ciclismo' : 
                                                    activity.activity_name === 'Corrida' ? 'Meta Corrida' : '';
                                const isLast = activity.activity_order === Math.max(...activeActivities.map(a => a.activity_order));
                                return `<li>${activity.activity_icon} ${checkpointType} (${activity.activity_name})${isLast ? ' - Conta tempo total' : ''}</li>`;
                            }).join('')}
                        </ul>
                        <div style="margin-top: var(--spacing-2); padding: var(--spacing-2); background: rgba(34, 197, 94, 0.1); border-radius: var(--radius-sm); font-size: var(--font-size-sm); color: var(--success);">
                            <strong>üí° Dica:</strong> A √∫ltima atividade da ordem conta automaticamente o tempo total da prova. N√£o √© necess√°rio dispositivo de "Meta Final" separado.
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        async function moveActivity(activityId, direction) {
            try {
                console.log(`üîÑ Movendo atividade ${activityId} para ${direction}...`);
                
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    showError('Supabase n√£o dispon√≠vel');
                    return;
                }
                
                // Obter atividade atual
                const { data: currentActivity, error: getError } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .select('*')
                    .eq('id', activityId)
                    .single();
                
                if (getError) throw getError;
                
                // Obter todas as atividades da mesma modalidade
                const { data: allActivities, error: allError } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .select('*')
                    .eq('modality_id', currentActivity.modality_id)
                    .order('activity_order');
                
                if (allError) throw allError;
                
                // Encontrar posi√ß√£o atual
                const currentIndex = allActivities.findIndex(a => a.id === activityId);
                if (currentIndex === -1) {
                    showError('Atividade n√£o encontrada');
                    return;
                }
                
                // Calcular nova posi√ß√£o
                let newIndex;
                if (direction === 'up' && currentIndex > 0) {
                    newIndex = currentIndex - 1;
                } else if (direction === 'down' && currentIndex < allActivities.length - 1) {
                    newIndex = currentIndex + 1;
                } else {
                    showError('N√£o √© poss√≠vel mover nesta dire√ß√£o');
                    return;
                }
                
                // Trocar ordens
                const tempOrder = allActivities[currentIndex].activity_order;
                const newOrder = allActivities[newIndex].activity_order;
                
                // Atualizar ambas as atividades
                const { error: updateError1 } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .update({ activity_order: newOrder })
                    .eq('id', activityId);
                
                if (updateError1) throw updateError1;
                
                const { error: updateError2 } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .update({ activity_order: tempOrder })
                    .eq('id', allActivities[newIndex].id);
                
                if (updateError2) throw updateError2;
                
                showSuccess('Ordem das atividades atualizada!');
                
                // Recarregar atividades
                loadMultimodalActivities(currentActivity.modality_id);
                
            } catch (error) {
                console.error('‚ùå Erro ao mover atividade:', error);
                showError('Erro ao mover atividade');
            }
        }
        
        async function toggleActivity(activityId, activate) {
            try {
                console.log(`üîÑ ${activate ? 'Ativando' : 'Desativando'} atividade ${activityId}...`);
                
                const { error } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .update({ is_active: activate })
                    .eq('id', activityId);
                
                if (error) throw error;
                
                showSuccess(`Atividade ${activate ? 'ativada' : 'desativada'} com sucesso!`);
                
                // Recarregar atividades para mostrar mudan√ßas visuais
                const checkedModalities = document.querySelectorAll('#modalitiesConfig input[type="checkbox"]:checked');
                checkedModalities.forEach(checkbox => {
                    const modalityData = JSON.parse(checkbox.dataset.modality);
                    if (['Duatlo', 'Triatlo'].includes(modalityData.name)) {
                        loadMultimodalActivities(modalityData.id);
                    }
                });
                
                // Validar configura√ß√£o se h√° evento selecionado
                if (currentEvent && currentEvent.id) {
                    validateMultimodalSetup(currentEvent.id);
                }
                
            } catch (error) {
                console.error('‚ùå Erro ao atualizar atividade:', error);
                showError(`Erro ao ${activate ? 'ativar' : 'desativar'} atividade`);
            }
        }
        
        async function validateMultimodalSetup(eventId) {
            try {
                const validationDiv = document.getElementById('multimodalValidation');
                const validationText = document.getElementById('multimodalValidationText');
                
                if (!validationDiv || !validationText) return;
                
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    validationText.textContent = 'Erro: Supabase n√£o dispon√≠vel';
                    validationDiv.style.display = 'block';
                    return;
                }
                
                // Verificar se tem dispositivos necess√°rios para modalidades multi-disciplinares
                const { data: lapDevices, error: lapError } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .select(`
                        *,
                        checkpoint_types!inner(code, is_finish)
                    `)
                    .eq('event_id', eventId);
                
                if (lapError) {
                    validationText.textContent = 'Erro ao verificar dispositivos';
                    validationDiv.style.display = 'block';
                    return;
                }
                
                // Verificar checkpoints espec√≠ficos para modalidades multi-disciplinares
                const swimmingDevices = lapDevices.filter(d => d.checkpoint_types.code === 'swimming_finish');
                const cyclingDevices = lapDevices.filter(d => d.checkpoint_types.code === 'cycling_finish');
                const runningDevices = lapDevices.filter(d => d.checkpoint_types.code === 'running_finish');
                
                // Verificar se o evento √© multi-disciplinar
                const { data: event, error: eventError } = await window.supabaseClient.supabase
                    .from('events')
                    .select('event_type')
                    .eq('id', eventId)
                    .single();
                
                if (eventError) {
                    validationText.textContent = 'Erro ao verificar tipo de evento';
                    validationDiv.style.display = 'block';
                    return;
                }
                
                const isMultimodal = ['Duatlo', 'Triatlo'].includes(event.event_type);
                
                if (!isMultimodal) {
                    validationDiv.style.display = 'none';
                    return;
                }
                
                // Valida√ß√µes espec√≠ficas por modalidade (sem meta final)
                let validationMessage = '';
                let isValid = true;
                
                if (event.event_type === 'Triatlo') {
                    if (swimmingDevices.length === 0) {
                        validationMessage += 'Necess√°rio dispositivo "Meta Nata√ß√£o" ‚Ä¢ ';
                        isValid = false;
                    }
                    if (cyclingDevices.length === 0) {
                        validationMessage += 'Necess√°rio dispositivo "Meta Ciclismo" ‚Ä¢ ';
                        isValid = false;
                    }
                    if (runningDevices.length === 0) {
                        validationMessage += 'Necess√°rio dispositivo "Meta Corrida" (conta tempo total) ‚Ä¢ ';
                        isValid = false;
                    }
                } else if (event.event_type === 'Duatlo') {
                    if (cyclingDevices.length === 0) {
                        validationMessage += 'Necess√°rio dispositivo "Meta Ciclismo" ‚Ä¢ ';
                        isValid = false;
                    }
                    if (runningDevices.length === 0) {
                        validationMessage += 'Necess√°rio dispositivo "Meta Corrida" (conta tempo total) ‚Ä¢ ';
                        isValid = false;
                    }
                }
                
                if (isValid) {
                    validationMessage = `‚úÖ Configura√ß√£o v√°lida para ${event.event_type}`;
                    validationDiv.style.background = 'rgba(34, 197, 94, 0.1)';
                    validationDiv.style.borderColor = 'var(--success)';
                    validationDiv.style.color = 'var(--success)';
                } else {
                    validationMessage = validationMessage.slice(0, -3); // Remove √∫ltimo "‚Ä¢ "
                    validationDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                    validationDiv.style.borderColor = 'var(--danger)';
                    validationDiv.style.color = 'var(--danger)';
                }
                
                validationText.textContent = validationMessage;
                validationDiv.style.display = 'block';
                
            } catch (error) {
                console.error('‚ùå Erro ao validar configura√ß√£o multi-disciplinar:', error);
                const validationText = document.getElementById('multimodalValidationText');
                if (validationText) {
                    validationText.textContent = 'Erro ao validar configura√ß√£o';
                }
            }
        }
    </script>
</body>
</html>

