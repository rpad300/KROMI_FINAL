<!DOCTYPE html>
<html lang="pt-PT" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configurações do Evento - Kromi.online</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#fc6b03">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Kromi.online">
    <meta name="description" content="Sistema de detecção de dorsais Kromi.online">
    
    <!-- KROMI Design System -->
    <link rel="stylesheet" href="/kromi-design-system.css">
    <link rel="stylesheet" href="/kromi-layout-fixes.css">
    
    <!-- Sistema de Navegação Unificado -->
    <link rel="stylesheet" href="/navigation-component.css?v=2025102601">
    <link rel="stylesheet" href="/unified-sidebar-styles.css?v=2025102601">
    <link rel="stylesheet" href="/logo-integration.css?v=2025012701">
    
    <!-- Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <style>
        /* Layout with Sidebar Structure */
        .layout-with-sidebar {
            display: flex;
            min-height: 100vh;
            background: var(--bg-primary);
            position: relative;
        }
        
        /* Sidebar styles */
        .layout-with-sidebar .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            z-index: 1050;
            overflow-y: auto;
            transition: transform var(--transition-slow);
        }
        
        /* Header styles */
        .layout-with-sidebar .header {
            position: fixed;
            top: 0;
            left: 280px;
            right: 0;
            height: 60px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            z-index: 1040;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-5);
            transition: left var(--transition-slow);
        }
        
        /* Main content area */
        .layout-with-sidebar .main {
            margin-left: 280px;
            margin-top: 60px;
            width: calc(100% - 280px);
            min-height: calc(100vh - 60px);
            transition: margin-left var(--transition-slow), width var(--transition-slow);
        }
        
        /* Mobile adjustments */
        /* Sidebar toggle functionality */
        .sidebar-hidden {
            transform: translateX(-100%) !important;
        }
        
        .main-expanded {
            margin-left: 0 !important;
            width: 100% !important;
        }
        
        .header-expanded {
            left: 0 !important;
        }
        
        /* Mobile menu button */
        #menuToggle {
            display: none;
        }
        
        @media (max-width: 768px) {
            #menuToggle {
                display: flex !important;
            }
        }
        
        @media (max-width: 1024px) {
            body {
                overflow-x: hidden;
            }
            
            .layout-with-sidebar .sidebar {
                transform: translateX(-100%);
            }
            
            .layout-with-sidebar .sidebar.sidebar-open {
                transform: translateX(0);
            }
            
            .layout-with-sidebar .header {
                left: 0;
            }
            
            .layout-with-sidebar .main {
                margin-left: 0 !important;
                margin-top: 60px !important;
                width: 100% !important;
                min-height: calc(100vh - 60px) !important;
                padding-bottom: 80px !important;
            }
            
            /* Ensure content fills the screen */
            #mainContent {
                min-height: calc(100vh - 60px - 80px);
                padding: var(--spacing-4);
            }
            
            #menuToggle {
                display: block !important;
            }
            
            .app-bottom-nav {
                display: flex !important;
            }
        }
        
        /* Config page specific styles */
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--spacing-4);
            margin-bottom: var(--spacing-6);
        }
        
        .config-section {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: var(--spacing-5);
            border: 1px solid var(--border-color);
        }
        
        .config-section h3 {
            margin: 0 0 var(--spacing-4) 0;
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
        }
        
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--spacing-4);
        }
        
        .form-label {
            font-weight: 500;
            color: var(--text-primary);
            font-size: var(--font-size-sm);
        }
        
        .form-input, .form-select, .form-textarea {
            padding: var(--spacing-3);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-base);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: var(--font-size-sm);
            transition: all 0.2s ease;
            font-family: var(--font-family-base);
        }
        
        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(252, 107, 3, 0.1);
        }
        
        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .action-buttons {
            display: flex;
            gap: var(--spacing-3);
            margin-top: var(--spacing-5);
            padding-top: var(--spacing-4);
            border-top: 1px solid var(--border-color);
            flex-wrap: wrap;
        }
        
        .event-info-display {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: var(--spacing-4);
            margin-bottom: var(--spacing-5);
            border: 1px solid var(--border-color);
        }
        
        .event-info-display h3 {
            margin: 0 0 var(--spacing-3) 0;
            color: var(--primary);
            font-size: var(--font-size-lg);
        }
        
        .event-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-3);
        }
        
        .info-item {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-1);
        }
        
        .info-label {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .info-value {
            font-size: var(--font-size-base);
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .checkbox-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-3);
            margin-top: var(--spacing-2);
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
            padding: var(--spacing-3);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-base);
            background: var(--bg-primary);
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .checkbox-item:hover {
            background: rgba(252, 107, 3, 0.05);
            border-color: var(--primary);
        }
        
        .checkbox-item input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        
        .checkbox-item label {
            margin: 0;
            cursor: pointer;
            flex: 1;
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
        }
        
        .category-icon {
            font-size: var(--font-size-xl);
            line-height: 1;
        }
        
        .category-info {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-1);
        }
        
        .category-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: var(--font-size-sm);
        }
        
        .category-details {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-12);
            text-align: center;
            color: var(--text-secondary);
        }
        
        .empty-state-icon {
            font-size: 64px;
            margin-bottom: var(--spacing-4);
            opacity: 0.5;
        }
        
        .empty-state h3 {
            color: var(--text-primary);
            margin-bottom: var(--spacing-2);
        }
        
        .empty-state p {
            color: var(--text-secondary);
            max-width: 400px;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .config-grid {
                grid-template-columns: 1fr;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .action-buttons .btn {
                width: 100%;
                justify-content: center;
            }
            
            .checkbox-grid {
                grid-template-columns: 1fr;
            }
            
            .event-info-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Header actions responsive */
        @media (max-width: 640px) {
            #headerActions {
                display: none !important;
            }
        }
        
        /* Processor Configuration Styles */
        .processor-info-card {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-4);
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .processor-info-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .processor-info-card.selected {
            border-color: var(--primary);
            background: var(--primary-light);
        }
        
        .processor-icon {
            font-size: var(--font-size-3xl);
            margin-bottom: var(--spacing-2);
        }
        
        .processor-name {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-1);
        }
        
        .processor-desc {
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
            margin-bottom: var(--spacing-3);
        }
        
        .processor-stats {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-1);
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-size-sm);
        }
        
        .stat-label {
            color: var(--text-secondary);
        }
        
        .stat-value {
            font-weight: 600;
        }
        
        .stat-value.high {
            color: var(--success);
        }
        
        .stat-value.medium {
            color: var(--warning);
        }
        
        .stat-value.low {
            color: var(--danger);
        }
        
        .stat-value.perfect {
            color: var(--primary);
        }
        
        .stat-value.fast {
            color: var(--success);
        }
        
        .stat-value.slow {
            color: var(--warning);
        }
        
        .stat-value.manual {
            color: var(--text-secondary);
        }
        
        .stat-value.free {
            color: var(--success);
        }
        
        .range-value {
            text-align: center;
            margin-top: var(--spacing-1);
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
        }
        
        .nomenclature-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
            padding: var(--spacing-3);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-base);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .nomenclature-option:hover {
            border-color: var(--primary);
            background: rgba(252, 107, 3, 0.05);
        }
        
        .nomenclature-option input[type="radio"]:checked + div {
            color: var(--primary);
        }
    </style>
</head>
<body data-theme="dark">
    <!-- App Container -->
    <div class="layout-with-sidebar">
        <!-- Sidebar (renderizada automaticamente pelo NavigationComponent) -->
        <!-- Sidebar (renderizada automaticamente pelo NavigationComponent) -->
        <div class="sidebar" id="sidebar"></div>
        
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <h1 class="header-title">⚙️ Configurações do Evento</h1>
            </div>
            <div class="header-right">
                <button class="btn btn-sm btn-primary" id="saveConfig">
                    <i>💾</i> Guardar Configurações
                </button>
                <button class="btn btn-sm btn-secondary" id="resetConfig">
                    <i>🔄</i> Repor
                </button>
            </div>
        </header>
        
        <!-- Main Content -->
        <main class="main">
            <div style="flex: 1; overflow-y: auto; padding: var(--spacing-5);" id="mainContent">
                
                <!-- Event Selector -->
                <div class="config-grid event-selector-container">
                    <div class="config-section">
                        <h3>📋 Selecionar Evento</h3>
                        <div class="form-group">
                            <label class="form-label" for="eventSelect">Evento:</label>
                            <select id="eventSelect" class="form-select">
                                <option value="">-- Selecionar Evento --</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Event Info Display -->
                <div class="event-info-display event-info-container" id="eventInfoDisplay" style="display: none;">
                    <h3>ℹ️ Informações do Evento</h3>
                    <div class="event-info-grid">
                        <div class="info-item">
                            <div class="info-label">Nome</div>
                            <div class="info-value" id="displayEventName">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Data</div>
                            <div class="info-value" id="displayEventDate">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Local</div>
                            <div class="info-value" id="displayEventLocation">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Status</div>
                            <div class="info-value" id="displayEventStatus">--</div>
                        </div>
                    </div>
                </div>
                
                <!-- Event Configuration -->
                <div class="config-grid" id="configSections" style="display: none;">
                    
                    <!-- Basic Info -->
                    <div class="config-section">
                        <h3>📝 Informações Básicas</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" for="eventName">Nome do Evento:</label>
                                <input type="text" id="eventName" class="form-input" placeholder="Ex: Maratona Lisboa 2024">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventDate">Data:</label>
                                <input type="date" id="eventDate" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventTime">Hora de Início:</label>
                                <input type="time" id="eventTime" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventLocation">Local:</label>
                                <input type="text" id="eventLocation" class="form-input" placeholder="Ex: Parque das Nações">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Event Settings -->
                    <div class="config-section">
                        <h3>🏃 Configurações do Evento</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" for="eventType">Tipo de Evento:</label>
                                <select id="eventType" class="form-select">
                                    <option value="running">Corrida</option>
                                    <option value="cycling">Ciclismo</option>
                                    <option value="triathlon">Triatlo</option>
                                    <option value="walking">Caminhada</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventDistance">Distância (km):</label>
                                <input type="number" id="eventDistance" class="form-input" placeholder="10.0" step="0.1" min="0">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventStatus">Status:</label>
                                <select id="eventStatus" class="form-select">
                                    <option value="active">Ativo</option>
                                    <option value="paused">Pausado</option>
                                    <option value="completed">Concluído</option>
                                    <option value="cancelled">Cancelado</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="hasCategories">Categorias:</label>
                                <select id="hasCategories" class="form-select">
                                    <option value="true">Sim</option>
                                    <option value="false">Não</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Categories Configuration -->
                    <div class="config-section">
                        <h3>🏅 Configuração de Categorias</h3>
                        <div class="form-group">
                            <label class="form-label">Categorias Habilitadas:</label>
                            <div id="categoriesConfig" class="checkbox-grid">
                                <!-- Será preenchido dinamicamente -->
                            </div>
                        </div>
                        <div class="form-group">
                            <button class="btn btn-sm btn-secondary" id="addCustomCategory">
                                <i>➕</i> Adicionar Categoria Personalizada
                            </button>
                        </div>
                    </div>
                    
                    <!-- Nomenclatura/Formato dos Dorsais (UNIFICADO) -->
                    <div class="config-section">
                        <h3>🏷️ Nomenclatura dos Dorsais (Formato para IA)</h3>
                        <p style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--spacing-4);">
                            Configure o formato dos números de dorsal usados no evento. Isto ajuda a IA a detectar corretamente os diferentes tipos de numeração.
                        </p>
                        
                        <div style="background: linear-gradient(135deg, #3b82f6, #2563eb); border-radius: var(--radius-lg); padding: var(--spacing-4); color: white; margin-bottom: var(--spacing-4);">
                            <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                <span style="font-size: var(--font-size-xl);">💡</span>
                                <h4 style="margin: 0; font-size: var(--font-size-lg);">Importante</h4>
                            </div>
                            <div style="font-size: var(--font-size-sm); line-height: 1.6;">
                                <p style="margin: 0 0 var(--spacing-2) 0;">
                                    <strong>Para Calibração:</strong> A IA usará estas configurações para detectar dorsais com mais precisão.
                                </p>
                                <p style="margin: 0;">
                                    <strong>Para GPS Tracking:</strong> Os QR codes usarão o código do participante (participant_code).
                                </p>
                            </div>
                        </div>
                        
                        <!-- Tipo de Nomenclatura -->
                        <div style="margin-bottom: var(--spacing-5);">
                            <label style="display: block; margin-bottom: var(--spacing-3); font-weight: 600;">
                                Tipo de Nomenclatura:
                            </label>
                            
                            <div style="display: grid; gap: var(--spacing-3);">
                                <label class="nomenclature-option" data-type="numeric">
                                    <input type="radio" name="nomenclatureType" value="numeric" checked onchange="handleNomenclatureChange('numeric')">
                                    <div>
                                        <div style="font-weight: 600;">🔢 Numérico (Padrão)</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Números simples: 1, 2, 3, ..., 9999</div>
                                    </div>
                                </label>
                                
                                <label class="nomenclature-option" data-type="prefix">
                                    <input type="radio" name="nomenclatureType" value="prefix" onchange="handleNomenclatureChange('prefix')">
                                    <div>
                                        <div style="font-weight: 600;">📝 Com Prefixo</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Ex: M-407, F-156, PRO-023</div>
                                    </div>
                                </label>
                                
                                <label class="nomenclature-option" data-type="suffix">
                                    <input type="radio" name="nomenclatureType" value="suffix" onchange="handleNomenclatureChange('suffix')">
                                    <div>
                                        <div style="font-weight: 600;">📝 Com Sufixo</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Ex: 407-M, 156-F, 023-PRO</div>
                                    </div>
                                </label>
                                
                                <label class="nomenclature-option" data-type="prefix-suffix">
                                    <input type="radio" name="nomenclatureType" value="prefix-suffix" onchange="handleNomenclatureChange('prefix-suffix')">
                                    <div>
                                        <div style="font-weight: 600;">📝 Prefixo + Sufixo</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Ex: M-407-F, PRO-023-ELITE</div>
                                    </div>
                                </label>
                                
                                <label class="nomenclature-option" data-type="markers">
                                    <input type="radio" name="nomenclatureType" value="markers" onchange="handleNomenclatureChange('markers')">
                                    <div>
                                        <div style="font-weight: 600;">🎨 Marcadores de Cor</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Cores antes/depois: 🟢407🔴</div>
                                    </div>
                                </label>
                                
                                <label class="nomenclature-option" data-type="custom">
                                    <input type="radio" name="nomenclatureType" value="custom" onchange="handleNomenclatureChange('custom')">
                                    <div>
                                        <div style="font-weight: 600;">⚙️ Personalizado (Regex)</div>
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Padrão customizado com expressão regular</div>
                                    </div>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Config Numérico -->
                        <div id="numericNomenclatureConfig" style="display:block;">
                            <h4 style="margin-bottom: var(--spacing-3);">📊 Configuração Numérica</h4>
                            
                            <!-- Modo de Atribuição -->
                            <div class="form-group" style="background:rgba(252,107,3,0.1);border:1px solid rgba(252,107,3,0.3);border-radius:8px;padding:12px;margin-bottom:16px;">
                                <label class="form-label" style="color:#fc6b03;font-weight:600;">🎯 Modo de Atribuição:</label>
                                <select id="nomenclatureNumericMode" class="form-select">
                                    <option value="sequential">Sequencial (1, 2, 3...)</option>
                                    <option value="random">Aleatório (sorteia dentro do range)</option>
                                </select>
                                <small class="text-secondary">Como novos dorsais são atribuídos via formulário</small>
                            </div>
                            
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">Número Mínimo:</label>
                                    <input type="number" id="nomenclatureNumericMin" class="form-input" value="1" min="1" max="9999">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Número Máximo:</label>
                                    <input type="number" id="nomenclatureNumericMax" class="form-input" value="9999" min="1" max="9999">
                                </div>
                                <div class="form-group">
                                    <label style="display: flex; align-items: center; gap: var(--spacing-2);">
                                        <input type="checkbox" id="nomenclatureUsePadding">
                                        Usar zeros à esquerda (001, 002, 003)
                                    </label>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Dígitos (com padding):</label>
                                    <input type="number" id="nomenclatureNumericDigits" class="form-input" value="3" min="1" max="6">
                                </div>
                            </div>
                            <div style="margin-top: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                <strong>Exemplo:</strong> <span id="nomenclatureNumericPreview">1, 2, 3, ..., 9999</span>
                            </div>
                        </div>
                        
                        <!-- Config Prefixo -->
                        <div id="prefixNomenclatureConfig" style="display:none;">
                            <h4 style="margin-bottom: var(--spacing-3);">📝 Configuração com Prefixo</h4>
                            
                            <!-- Modo de Atribuição -->
                            <div class="form-group" style="background:rgba(252,107,3,0.1);border:1px solid rgba(252,107,3,0.3);border-radius:8px;padding:12px;margin-bottom:16px;">
                                <label class="form-label" style="color:#fc6b03;font-weight:600;">🎯 Modo de Atribuição:</label>
                                <select id="nomenclaturePrefixMode" class="form-select">
                                    <option value="sequential">Sequencial (M-1, M-2, F-1, F-2...)</option>
                                    <option value="random">Aleatório (sorteia prefixo e número)</option>
                                </select>
                            </div>
                            
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">Prefixo(s) Permitidos:</label>
                                    <input type="text" id="nomenclaturePrefixText" class="form-input" placeholder="Ex: M, F, PRO" value="M,F">
                                    <small class="text-secondary">Separar múltiplos com vírgula</small>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Separador:</label>
                                    <input type="text" id="nomenclaturePrefixSeparator" class="form-input" value="-" maxlength="3">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Número Mínimo:</label>
                                    <input type="number" id="nomenclaturePrefixMin" class="form-input" value="1" min="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Número Máximo:</label>
                                    <input type="number" id="nomenclaturePrefixMax" class="form-input" value="999" max="9999">
                                </div>
                            </div>
                            <div style="margin-top: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                <strong>Exemplo:</strong> <span id="nomenclaturePrefixPreview">M-1, M-2, F-1, F-2</span>
                            </div>
                        </div>
                        
                        <!-- Config Sufixo -->
                        <div id="suffixNomenclatureConfig" style="display:none;">
                            <h4 style="margin-bottom: var(--spacing-3);">📝 Configuração com Sufixo</h4>
                            
                            <!-- Modo de Atribuição -->
                            <div class="form-group" style="background:rgba(252,107,3,0.1);border:1px solid rgba(252,107,3,0.3);border-radius:8px;padding:12px;margin-bottom:16px;">
                                <label class="form-label" style="color:#fc6b03;font-weight:600;">🎯 Modo de Atribuição:</label>
                                <select id="nomenclatureSuffixMode" class="form-select">
                                    <option value="sequential">Sequencial (1-M, 2-M, 1-F, 2-F...)</option>
                                    <option value="random">Aleatório (sorteia número e sufixo)</option>
                                </select>
                            </div>
                            
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">Sufixo(s) Permitidos:</label>
                                    <input type="text" id="nomenclatureSuffixText" class="form-input" placeholder="Ex: M, F, PRO" value="M,F">
                                    <small class="text-secondary">Separar múltiplos com vírgula</small>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Separador:</label>
                                    <input type="text" id="nomenclatureSuffixSeparator" class="form-input" value="-" maxlength="3">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Número Mínimo:</label>
                                    <input type="number" id="nomenclatureSuffixMin" class="form-input" value="1" min="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Número Máximo:</label>
                                    <input type="number" id="nomenclatureSuffixMax" class="form-input" value="999" max="9999">
                                </div>
                            </div>
                            <div style="margin-top: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                <strong>Exemplo:</strong> <span id="nomenclatureSuffixPreview">1-M, 2-M, 1-F, 2-F</span>
                            </div>
                        </div>
                        
                        <!-- Config Marcadores -->
                        <div id="markersNomenclatureConfig" style="display:none;">
                            <h4 style="margin-bottom: var(--spacing-3);">🎨 Configuração com Marcadores de Cor</h4>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label class="form-label">Cor de Início:</label>
                                    <input type="color" id="nomenclatureStartColor" class="form-input" value="#10b981" style="height:50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Cor de Fim:</label>
                                    <input type="color" id="nomenclatureEndColor" class="form-input" value="#ef4444" style="height:50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Tolerância de Cor (%):</label>
                                    <input type="range" id="nomenclatureColorTolerance" class="form-input" min="5" max="50" value="20">
                                    <div class="text-secondary text-center"><span id="nomenclatureToleranceValue">20</span>%</div>
                                </div>
                            </div>
                            <div style="margin-top: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                <strong>Exemplo:</strong> <span style="color:#10b981;">🟢</span> 407 <span style="color:#ef4444;">🔴</span>
                            </div>
                        </div>
                        
                        <!-- Config Custom Regex -->
                        <div id="customNomenclatureConfig" style="display:none;">
                            <h4 style="margin-bottom: var(--spacing-3);">⚙️ Configuração Personalizada (Regex)</h4>
                            <div class="form-group">
                                <label class="form-label">Expressão Regular:</label>
                                <input type="text" id="nomenclatureCustomRegex" class="form-input" placeholder="Ex: ^[A-Z]\\d{3}$" style="font-family:monospace;">
                                <small class="text-secondary">Padrão para validar dorsais</small>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Exemplos (separar com vírgula):</label>
                                <input type="text" id="nomenclatureCustomExamples" class="form-input" placeholder="Ex: A001, B002, C003">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Modalities Configuration -->
                    <div class="config-section">
                        <h3>🏃 Configuração de Modalidades</h3>
                        <div class="form-group">
                            <label class="form-label">Modalidades Habilitadas:</label>
                            <div id="modalitiesConfig" class="checkbox-grid">
                                <!-- Será preenchido dinamicamente -->
                            </div>
                        </div>
                        <div class="form-group">
                            <button class="btn btn-sm btn-secondary" id="addCustomModality">
                                <i>➕</i> Adicionar Modalidade Personalizada
                            </button>
                        </div>
                    </div>
                    
                    <!-- Multi-Modal Configuration -->
                    <div class="config-section" id="multimodalConfig" style="display: none;">
                        <h3>🏊🚴🏃 Configuração Multi-Disciplinar</h3>
                        <p style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--spacing-4);">
                            Configure as atividades específicas para eventos multi-disciplinares (Duatlo/Triatlo).
                        </p>
                        <div id="multimodalActivities">
                            <!-- Será preenchido dinamicamente -->
                        </div>
                        <div id="multimodalValidation" style="display: none; margin-top: var(--spacing-3); padding: var(--spacing-3); background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); border-radius: var(--radius-base); color: var(--danger);">
                            <strong>⚠️ Validação:</strong> <span id="multimodalValidationText">Verificando configuração...</span>
                        </div>
                    </div>
                    
                    <!-- Lap Counter Configuration -->
                    <div class="config-section">
                        <h3>🔄 Configuração de Contador de Voltas</h3>
                        <p style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--spacing-4);">
                            Configure se este evento utiliza contador de voltas. Quando ativado, o sistema calculará automaticamente estatísticas de voltas.
                        </p>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" for="hasLapCounter">Contador de Voltas:</label>
                                <select id="hasLapCounter" class="form-select">
                                    <option value="false">Desativado</option>
                                    <option value="true">Ativado</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="lapDistance">Distância por Volta (km):</label>
                                <input type="number" id="lapDistance" class="form-input" placeholder="2.5" step="0.1" min="0" disabled>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="totalLaps">Total de Voltas Esperadas:</label>
                                <input type="number" id="totalLaps" class="form-input" placeholder="10" min="1" disabled>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="minLapsForClassification">Mínimo de Voltas para Classificar:</label>
                                <input type="number" id="minLapsForClassification" class="form-input" placeholder="1" min="1" disabled>
                            </div>
                        </div>
                        <div id="lapCounterValidation" style="display: none; margin-top: var(--spacing-3); padding: var(--spacing-3); background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); border-radius: var(--radius-base); color: var(--danger);">
                            <strong>⚠️ Validação:</strong> <span id="lapCounterValidationText">Verificando configuração...</span>
                        </div>
                    </div>
                    
                    <!-- Checkpoint Types Configuration -->
                    <div class="config-section">
                        <h3>📍 Tipos de Checkpoints (Global)</h3>
                        <p style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--spacing-4);">
                            Configure os tipos de checkpoints disponíveis para todos os eventos.
                        </p>
                        <div id="checkpointTypesConfig">
                            <!-- Será preenchido dinamicamente -->
                        </div>
                        <div style="margin-top: var(--spacing-3);">
                            <button class="btn btn-sm btn-secondary" id="addCheckpointTypeBtn">
                                <i>➕</i> Adicionar Tipo Personalizado
                            </button>
                            <button class="btn btn-sm btn-primary" id="refreshCheckpointTypesBtn">
                                <i>🔄</i> Atualizar
                            </button>
                        </div>
                    </div>
                    
                    <!-- Advanced Settings -->
                    <div class="config-section">
                        <h3>🔧 Configurações Avançadas</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" for="autoStartEnabled">Início Automático:</label>
                                <select id="autoStartEnabled" class="form-select">
                                    <option value="true">Ativado</option>
                                    <option value="false">Desativado</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="scheduledStartTime">Hora Programada:</label>
                                <input type="datetime-local" id="scheduledStartTime" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="eventDescription">Descrição:</label>
                                <textarea id="eventDescription" class="form-textarea" placeholder="Descrição detalhada do evento..."></textarea>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Processor Configuration -->
                    <div class="config-section">
                        <h3>🤖 Configuração do Processador de IA</h3>
                        <p style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--spacing-4);">
                            Escolha o tipo de processador de IA para detecção de dorsais. Cada processador tem características específicas de velocidade, precisão e custo.
                        </p>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" for="processorType">Tipo de Processador:</label>
                                <select id="processorType" class="form-select">
                                    <option value="gemini">🤖 Gemini AI (Recomendado)</option>
                                    <option value="openai">🤖 OpenAI GPT-4</option>
                                    <option value="deepseek">🤖 DeepSeek AI</option>
                                    <option value="google-vision">👁️ Google Vision API</option>
                                    <option value="ocr">📄 OCR Tradicional</option>
                                    <option value="hybrid">🔄 Híbrido (Gemini + OCR)</option>
                                    <option value="manual">✋ Manual (Sem IA)</option>
                                </select>
                            </div>
                            <div class="form-group" id="geminiModelGroup" style="display: none;">
                                <label class="form-label" for="geminiModel">Modelo Gemini:</label>
                                <select id="geminiModel" class="form-select">
                                    <option value="">Carregando modelos...</option>
                                </select>
                                <button type="button" id="reloadGeminiModelsBtn" class="btn btn-secondary" style="margin-top: 8px;">
                                    🔄 Recarregar Modelos
                                </button>
                            </div>
                            <div class="form-group" id="openaiModelGroup" style="display: none;">
                                <label class="form-label" for="openaiModel">Modelo OpenAI:</label>
                                <select id="openaiModel" class="form-select">
                                    <option value="">Carregando modelos...</option>
                                </select>
                                <button type="button" id="reloadModelsBtn" class="btn btn-secondary" style="margin-top: 8px;">
                                    🔄 Recarregar Modelos
                                </button>
                            </div>
                            <div class="form-group" id="deepseekModelGroup" style="display: none;">
                                <label class="form-label" for="deepseekModel">Modelo DeepSeek:</label>
                                <select id="deepseekModel" class="form-select">
                                    <option value="">Carregando modelos...</option>
                                </select>
                                <button type="button" id="reloadDeepSeekModelsBtn" class="btn btn-secondary" style="margin-top: 8px;">
                                    🔄 Recarregar Modelos
                                </button>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="processorSpeed">Velocidade de Processamento:</label>
                                <select id="processorSpeed" class="form-select">
                                    <option value="fast">⚡ Rápido (Menos Precisão)</option>
                                    <option value="balanced">⚖️ Equilibrado (Padrão)</option>
                                    <option value="accurate">🎯 Preciso (Mais Lento)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="processorConfidence">Confiança Mínima:</label>
                                <input type="range" id="processorConfidence" class="form-range" min="0.1" max="1.0" step="0.1" value="0.7">
                                <div class="range-value">
                                    <span id="confidenceValue">70%</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Processor Info Cards -->
                        <div class="processor-info-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--spacing-3); margin-top: var(--spacing-4);">
                            <div class="processor-info-card" data-processor="gemini">
                                <div class="processor-icon">🤖</div>
                                <div class="processor-name">Gemini AI</div>
                                <div class="processor-desc">IA avançada do Google</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precisão:</span>
                                        <span class="stat-value high">95%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value medium">2-5s</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value medium">Médio</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="processor-info-card" data-processor="openai">
                                <div class="processor-icon">🤖</div>
                                <div class="processor-name">OpenAI</div>
                                <div class="processor-desc">GPT-4 Vision API</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precisão:</span>
                                        <span class="stat-value high">95%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value medium">2-5s</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value medium">Médio</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="processor-info-card" data-processor="google-vision">
                                <div class="processor-icon">👁️</div>
                                <div class="processor-name">Google Vision</div>
                                <div class="processor-desc">OCR especializado</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precisão:</span>
                                        <span class="stat-value medium">85%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value fast">1-3s</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value low">Baixo</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="processor-info-card" data-processor="ocr">
                                <div class="processor-icon">📄</div>
                                <div class="processor-name">OCR Tradicional</div>
                                <div class="processor-desc">Processamento local</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precisão:</span>
                                        <span class="stat-value low">70%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value fast">0.5-2s</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value free">Gratuito</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="processor-info-card" data-processor="hybrid">
                                <div class="processor-icon">🔄</div>
                                <div class="processor-name">Híbrido</div>
                                <div class="processor-desc">Combina múltiplas IA</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precisão:</span>
                                        <span class="stat-value high">98%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value slow">5-10s</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value high">Alto</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="processor-info-card" data-processor="manual">
                                <div class="processor-icon">✋</div>
                                <div class="processor-name">Manual</div>
                                <div class="processor-desc">Sem processamento IA</div>
                                <div class="processor-stats">
                                    <div class="stat">
                                        <span class="stat-label">Precisão:</span>
                                        <span class="stat-value perfect">100%</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Velocidade:</span>
                                        <span class="stat-value manual">Manual</span>
                                    </div>
                                    <div class="stat">
                                        <span class="stat-label">Custo:</span>
                                        <span class="stat-value free">Gratuito</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="config-section">
                        <h3>💾 Ações</h3>
                        <div class="action-buttons">
                            <button class="btn btn-primary" id="saveEventConfig">
                                <i>💾</i> Salvar Configuração
                            </button>
                            <button class="btn btn-secondary" id="resetEventConfig">
                                <i>🔄</i> Resetar
                            </button>
                            <button class="btn btn-danger" id="deleteEvent">
                                <i>🗑️</i> Excluir Evento
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Empty State -->
                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon">⚙️</div>
                    <h3>Selecione um evento para configurar</h3>
                    <p>Escolha um evento na lista acima para ver e editar suas configurações.</p>
                </div>
            </div>
        </main>
        
        <!-- Bottom Navigation (Mobile) -->
        <nav class="app-bottom-nav" id="bottomNav">
            <!-- Será preenchido por navigation.js -->
        </nav>
    </div> <!-- Fim .layout-with-sidebar -->
    
    <!-- Scripts de Autenticação -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="/supabase.js?v=2025102605"></script>
    <script src="/auth-client.js?v=2025102610"></script>
    <script src="/auth-helper.js?v=2025102607"></script>
    
    <!-- Sistema de Navegação Unificado -->
    <script src="/navigation-config.js?v=2025102601" defer></script>
    <script src="/navigation-service.js?v=2025102601" defer></script>
    <!-- Logo Loader (carregar ANTES da navegação, SEM defer para garantir ordem) -->
    <script src="/logo-loader.js?v=2025012702"></script>
    <script src="/navigation-component.js?v=2025102601" defer></script>
    <script src="/navigation-init.js?v=2025102601" defer></script>
    
    <script src="/universal-route-protection.js?v=2025102607"></script>
    
    <!-- Configuration Logic -->
    <script>
        // Global variables
        let currentEvent = null;
        let events = [];
        
        // Função para alternar sidebar
        // Aguardar navegação estar pronta
        async function waitForNavigation() {
            return new Promise((resolve) => {
                if (window.NavigationUtils) {
                    resolve();
                } else {
                    window.addEventListener('navigationReady', resolve);
                }
            });
        }
        
        // Initialize page
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Verificar autenticação
                const autenticado = await verificarAutenticacao(['admin', 'moderator', 'event_manager', 'user']);
                if (!autenticado) return;
                
                console.log('🚀 Inicializando página config...');
                
                // Initialize Supabase first
                if (window.supabaseClient) {
                    console.log('🔑 Inicializando Supabase...');
                    await window.supabaseClient.init();
                    console.log('✅ Supabase inicializado:', window.supabaseClient.isConnected);
                } else {
                    console.error('❌ window.supabaseClient não encontrado');
                }
                
                // Aguardar navegação estar pronta
                await waitForNavigation();
                console.log('✅ Navegação pronta');
                
                // Obter eventId da URL
                const urlParams = new URLSearchParams(window.location.search);
                const eventId = urlParams.get('event');
                const eventName = urlParams.get('eventName');
                
                console.log('📍 Evento da URL:', eventId, eventName);
                
                // Atualizar contexto de evento no NavigationService
                if (eventId && window.navigationService) {
                    window.navigationService.setEventContext(eventId, eventName);
                }
                
                // Inicializar autocomplete do Google Maps
                await initGoogleMapsAutocomplete();
                
                if (eventId) {
                    console.log('🎯 Carregando evento automaticamente...');
                    // Se temos evento na URL, carregar automaticamente
                    await loadEventInfo(eventId);
                    
                    // Esconder dropdown de seleção de evento
                    const eventSelectorContainer = document.querySelector('.event-selector-container');
                    if (eventSelectorContainer) {
                        eventSelectorContainer.style.display = 'none';
                    }
                    
                    // Mostrar info do evento selecionado
                    const eventInfoContainer = document.querySelector('.event-info-container');
                    if (eventInfoContainer) {
                        eventInfoContainer.style.display = 'block';
                    }
                } else {
                    // Sem evento na URL - mostrar mensagem para selecionar
                    console.warn('⚠️ Nenhum evento na URL');
                }
                
                // Setup event listeners
                setupEventListeners();
                
                // Load events
                console.log('📋 Carregando lista de eventos...');
                await loadEvents();
                console.log('✅ Página inicializada');
                
            } catch (error) {
                console.error('❌ Erro na inicialização:', error);
            }
        });
        
        function setupEventListeners() {
            // Event selector
            const eventSelect = document.getElementById('eventSelect');
            if (eventSelect) {
                eventSelect.addEventListener('change', (e) => {
                    if (e.target.value) {
                        loadEventInfo(e.target.value);
                    } else {
                        hideEventInfo();
                    }
                });
            }
            
            // Configuration buttons
            const saveEventConfigBtn = document.getElementById('saveEventConfig');
            const resetEventConfigBtn = document.getElementById('resetEventConfig');
            const deleteEventBtn = document.getElementById('deleteEvent');
            const saveConfigBtn = document.getElementById('saveConfig');
            const resetConfigBtn = document.getElementById('resetConfig');
            
            if (saveEventConfigBtn) saveEventConfigBtn.addEventListener('click', saveEventConfig);
            if (resetEventConfigBtn) resetEventConfigBtn.addEventListener('click', resetEventConfig);
            if (deleteEventBtn) deleteEventBtn.addEventListener('click', deleteEvent);
            if (saveConfigBtn) saveConfigBtn.addEventListener('click', saveEventConfig);
            if (resetConfigBtn) resetConfigBtn.addEventListener('click', resetEventConfig);
            
            // Lap counter configuration
            const hasLapCounter = document.getElementById('hasLapCounter');
            if (hasLapCounter) {
                hasLapCounter.addEventListener('change', handleLapCounterToggle);
            }
            
            // Dorsal assignment configuration
            const dorsalMode = document.getElementById('dorsalMode');
            if (dorsalMode) {
                dorsalMode.addEventListener('change', handleDorsalModeChange);
            }
            
            // Menu toggle mobile
            const menuToggle = document.getElementById('menuToggle');
            const sidebar = document.getElementById('sidebar');
            
            if (menuToggle && sidebar) {
                menuToggle.addEventListener('click', () => {
                    sidebar.classList.toggle('sidebar-open');
                });
            }
        }
        
        async function loadEvents() {
            try {
                console.log('📋 [loadEvents] Carregando lista de eventos via API...');
                
                // Usar API REST (bypassa RLS)
                const res = await fetch('/api/events/list', {
                    credentials: 'include'
                });
                
                if (!res.ok) {
                    if (res.status === 401) {
                        window.location.href = './login.html';
                        return;
                    }
                    throw new Error(`HTTP ${res.status}`);
                }
                
                const { success, events: eventsData, error } = await res.json();
                
                if (!success || error) {
                    console.error('❌ Erro ao carregar eventos:', error);
                    return;
                }
                
                console.log('✅ [loadEvents] Eventos carregados:', eventsData?.length || 0);
                events = eventsData || [];
                
                // Update dropdown
                const selector = document.getElementById('eventSelect');
                if (selector) {
                    selector.innerHTML = '<option value="">-- Selecionar Evento --</option>';
                    events.forEach(event => {
                        const option = document.createElement('option');
                        option.value = event.id;
                        option.textContent = event.name;
                        selector.appendChild(option);
                    });
                    console.log('✅ [loadEvents] Dropdown atualizado com', events.length, 'eventos');
                }
                
            } catch (error) {
                console.error('❌ [loadEvents] Erro:', error);
            }
        }
        
        // =====================================================
        // GOOGLE MAPS AUTocomplete
        // =====================================================
        
        let googleMapsAutocomplete = null;
        
        async function initGoogleMapsAutocomplete() {
            try {
                // Obter API key do backend
                const configResponse = await fetch('/api/config', {
                    credentials: 'include'
                });
                
                if (!configResponse.ok) {
                    console.warn('⚠️ Não foi possível obter configuração do Google Maps');
                    return;
                }
                
                const config = await configResponse.json();
                const apiKey = config.GOOGLE_MAPS_API_KEY;
                
                if (!apiKey) {
                    console.warn('⚠️ GOOGLE_MAPS_API_KEY não configurada');
                    return;
                }
                
                console.log('🗺️ Inicializando Google Maps Places Autocomplete...');
                
                // Carregar script do Google Maps Places API
                if (!window.google || !window.google.maps || !window.google.maps.places) {
                    await loadGoogleMapsScript(apiKey);
                }
                
                // Aguardar um pouco para garantir que a API está carregada
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Inicializar autocomplete no campo eventLocation
                const locationInput = document.getElementById('eventLocation');
                if (!locationInput) {
                    console.warn('⚠️ Elemento eventLocation não encontrado');
                    return;
                }
                
                if (window.google && window.google.maps && window.google.maps.places) {
                    try {
                        const autocomplete = new google.maps.places.Autocomplete(locationInput, {
                            types: ['establishment', 'geocode'],
                            fields: ['formatted_address', 'geometry', 'name', 'address_components']
                        });
                        
                        autocomplete.addListener('place_changed', () => {
                            try {
                                const place = autocomplete.getPlace();
                                
                                if (place.formatted_address) {
                                    locationInput.value = place.formatted_address;
                                    console.log('📍 Local selecionado:', place.formatted_address);
                                }
                                
                                // Opcional: salvar coordenadas se necessário
                                if (place.geometry && place.geometry.location) {
                                    const lat = place.geometry.location.lat();
                                    const lng = place.geometry.location.lng();
                                    console.log('📍 Coordenadas:', { lat, lng });
                                    // Você pode salvar essas coordenadas em um campo hidden se necessário
                                }
                            } catch (error) {
                                console.warn('⚠️ Erro ao processar seleção de local:', error);
                            }
                        });
                        
                        googleMapsAutocomplete = autocomplete;
                        console.log('✅ Google Maps Autocomplete inicializado');
                    } catch (error) {
                        console.warn('⚠️ Erro ao criar Autocomplete:', error);
                        console.warn('💡 O campo de localização ainda funciona como texto normal');
                        // Não quebrar - o usuário ainda pode digitar manualmente
                    }
                } else {
                    console.warn('⚠️ API do Google Maps não carregada - o campo funciona como texto normal');
                    console.warn('💡 Para habilitar o autocomplete, verifique:');
                    console.warn('   1. A API key está configurada corretamente');
                    console.warn('   2. A API key tem permissões para este domínio/IP');
                    console.warn('   3. A API "Places API" está habilitada no Google Cloud Console');
                }
                
            } catch (error) {
                console.error('❌ Erro ao inicializar Google Maps Autocomplete:', error);
                console.warn('💡 O campo de localização ainda funciona como texto normal');
            }
        }
        
        function loadGoogleMapsScript(apiKey) {
            return new Promise((resolve) => {
                // Verificar se já está carregado
                if (window.google && window.google.maps && window.google.maps.places) {
                    resolve();
                    return;
                }
                
                // Verificar se o script já está sendo carregado
                if (document.querySelector('script[src*="maps.googleapis.com"]')) {
                    // Aguardar o script carregar
                    const checkInterval = setInterval(() => {
                        if (window.google && window.google.maps && window.google.maps.places) {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                    
                    setTimeout(() => {
                        clearInterval(checkInterval);
                        console.warn('⚠️ Timeout ao carregar Google Maps API - o campo funciona como texto normal');
                        resolve(); // Resolver mesmo assim para não quebrar a página
                    }, 10000);
                    return;
                }
                
                // Handler de erro de autenticação - não quebrar a funcionalidade
                window.gm_authFailure = function() {
                    console.warn('⚠️ Erro de autenticação do Google Maps (ApiTargetBlockedMapError)');
                    console.warn('💡 Possíveis causas:');
                    console.warn('   1. A API key não está configurada corretamente');
                    console.warn('   2. A API key não tem permissões para este domínio/IP');
                    console.warn('   3. A Places API não está habilitada no Google Cloud Console');
                    console.warn('   4. As restrições de HTTP referrer bloqueiam este domínio');
                    console.warn('💡 O campo de localização ainda funciona como texto normal');
                    delete window.initGoogleMapsCallback;
                    resolve(); // Não rejeitar - permitir que continue
                };
                
                // Criar callback global
                window.initGoogleMapsCallback = () => {
                    try {
                        delete window.initGoogleMapsCallback;
                        if (window.google && window.google.maps && window.google.maps.places) {
                            resolve();
                        } else {
                            console.warn('⚠️ Google Maps API carregada mas Places não disponível');
                            resolve(); // Resolver mesmo assim
                        }
                    } catch (error) {
                        console.warn('⚠️ Erro no callback do Google Maps:', error);
                        resolve(); // Resolver mesmo assim
                    }
                };
                
                // Criar e adicionar script
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places&callback=initGoogleMapsCallback`;
                script.async = true;
                script.defer = true;
                
                script.onerror = () => {
                    console.warn('⚠️ Erro ao carregar script do Google Maps - o campo funciona como texto normal');
                    delete window.initGoogleMapsCallback;
                    resolve(); // Não rejeitar - permitir que continue
                };
                
                document.head.appendChild(script);
            });
        }
        
        async function loadEventInfo(eventId) {
            try {
                console.log('📊 [loadEventInfo] Carregando evento via API:', eventId);
                
                // Carregar evento via API REST (bypassa RLS)
                const res = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!res.ok) {
                    if (res.status === 404) {
                        showError('Evento não encontrado');
                        return;
                    }
                    if (res.status === 401) {
                        window.location.href = './login.html';
                        return;
                    }
                    throw new Error(`HTTP ${res.status}`);
                }
                
                const { success, event, error: apiError } = await res.json();
                
                if (!success || apiError) {
                    console.error('Erro ao carregar evento:', apiError);
                    showError(apiError || 'Erro ao carregar evento');
                    return;
                }
                
                console.log('✅ [loadEventInfo] Evento carregado:', event.name);
                console.log('📅 [loadEventInfo] event_date da API:', event.event_date);
                console.log('📏 [loadEventInfo] distance_km da API:', event.distance_km, 'tipo:', typeof event.distance_km);
                
                // A API REST já retorna todos os campos da base de dados usando service role (bypass RLS)
                console.log('📏 distance_km carregado via API REST:', event.distance_km, 'tipo:', typeof event.distance_km);
                
                // Se a API retornou apenas data (sem hora), tentar buscar hora completa via API REST novamente
                if (event.event_date && event.event_date.length === 10 && !event.event_date.includes('T')) {
                    console.log('⚠️ API retornou apenas data, tentando buscar hora completa via API REST...');
                    try {
                        const apiRetryResponse = await fetch(`/api/events/${eventId}`, {
                            credentials: 'include'
                        });
                        
                        if (apiRetryResponse.ok) {
                            const apiRetryData = await apiRetryResponse.json();
                            if (apiRetryData.success && apiRetryData.event?.event_date) {
                                const retryDate = apiRetryData.event.event_date;
                                if (retryDate.includes('T') || retryDate.length > 10) {
                                    event.event_date = retryDate;
                                    currentEvent.event_date = retryDate;
                                    console.log('✅ event_date completo encontrado via API REST (retry):', retryDate);
                                }
                            }
                        }
                    } catch (apiRetryErr) {
                        console.log('ℹ️ Erro ao buscar event_date via API REST (retry):', apiRetryErr.message);
                    }
                } else if (event.event_date && (event.event_date.includes('T') || event.event_date.length > 10)) {
                    console.log('✅ event_date já vem com hora da API:', event.event_date);
                }
                
                currentEvent = event;
                
                // Update display info
                updateEventDisplay(event);
                
                // Update form fields
                updateFormFields(event);
                
                // Load categories, modalities and checkpoint types
                await loadCategories();
                await loadModalities();
                await loadCheckpointTypes();
                
                // Initialize processor configuration
                initializeProcessorConfig();
                
                // Load event-specific configurations
                const categoryConfig = await loadEventCategoryConfig(eventId);
                const modalityConfig = await loadEventModalityConfig(eventId);
                // Nota: loadDorsalConfig removido - a atribuição agora está dentro da nomenclatura
                await loadDorsalNomenclatureConfig(eventId);
                
                // Update checkboxes based on event configuration
                updateCategoryCheckboxes(categoryConfig);
                updateModalityCheckboxes(modalityConfig);
                
                // Show config sections
                const configSections = document.getElementById('configSections');
                const emptyState = document.getElementById('emptyState');
                
                if (configSections) configSections.style.display = 'grid';
                if (emptyState) emptyState.style.display = 'none';
                
                // Update sidebar
                const eventInfoPanel = document.getElementById('eventInfoPanel');
                const currentEventInfo = document.getElementById('currentEventInfo');
                
                if (eventInfoPanel) eventInfoPanel.style.display = 'block';
                if (currentEventInfo) {
                    // Verificar se existe calibração
                    await updateCalibrationStatus(eventId, event, currentEventInfo);
                }
                
            } catch (error) {
                console.error('Erro ao carregar evento:', error);
                showError('Erro ao carregar evento');
            }
        }
        
        // Verificar status da calibração e atualizar display
        async function updateCalibrationStatus(eventId, event, container) {
            try {
                let calibrationStatus = '❌ Calibração ainda não foi definida';
                
                if (window.supabaseClient && window.supabaseClient.supabase) {
                    // Usar RPC get_active_calibration em vez de event_configurations
                    const { data: calibrationData, error } = await window.supabaseClient.supabase
                        .rpc('get_active_calibration', { event_uuid: eventId });
                    
                    if (!error && calibrationData && calibrationData.length > 0) {
                        const calibration = calibrationData[0];
                        if (calibration.is_complete) {
                            calibrationStatus = '✅ Calibração completa';
                        } else {
                            calibrationStatus = '⏳ Calibração em progresso';
                        }
                    }
                }
                
                if (container) {
                    container.innerHTML = `
                        <strong>${event.name}</strong><br>
                        Data: ${event.event_date ? new Date(event.event_date).toLocaleDateString('pt-PT') : 'Não definida'}<br>
                        Local: ${event.location || 'Não definido'}<br>
                        ${calibrationStatus}
                    `;
                }
            } catch (error) {
                console.error('❌ Erro ao verificar status da calibração:', error);
                // Em caso de erro, mostrar info básica
                if (container) {
                    container.innerHTML = `
                        <strong>${event.name}</strong><br>
                        Data: ${event.event_date ? new Date(event.event_date).toLocaleDateString('pt-PT') : 'Não definida'}<br>
                        Local: ${event.location || 'Não definido'}
                    `;
                }
            }
        }
        
        function updateEventDisplay(event) {
            const displayEventName = document.getElementById('displayEventName');
            const displayEventDate = document.getElementById('displayEventDate');
            const displayEventLocation = document.getElementById('displayEventLocation');
            const displayEventStatus = document.getElementById('displayEventStatus');
            
            if (displayEventName) displayEventName.textContent = event.name || '--';
            if (displayEventDate) displayEventDate.textContent = event.event_date ? new Date(event.event_date).toLocaleDateString('pt-PT') : '--';
            if (displayEventLocation) displayEventLocation.textContent = event.location || '--';
            if (displayEventStatus) displayEventStatus.textContent = event.status || '--';
        }
        
        function updateFormFields(event) {
            const eventName = document.getElementById('eventName');
            const eventDate = document.getElementById('eventDate');
            const eventTime = document.getElementById('eventTime');
            const eventLocation = document.getElementById('eventLocation');
            const eventType = document.getElementById('eventType');
            const eventDistance = document.getElementById('eventDistance');
            const eventStatus = document.getElementById('eventStatus');
            const hasCategories = document.getElementById('hasCategories');
            const autoStartEnabled = document.getElementById('autoStartEnabled');
            const scheduledStartTime = document.getElementById('scheduledStartTime');
            const eventDescription = document.getElementById('eventDescription');
            
            if (eventName) eventName.value = event.name || '';
            
            // Processar event_date para extrair data e hora
            let dateValue = '';
            let timeValue = '';
            
            if (event.event_date) {
                if (typeof event.event_date === 'string') {
                    if (event.event_date.includes('T')) {
                        // Tem timestamp completo: "2025-11-02T09:00:00.000Z"
                        const parts = event.event_date.split('T');
                        dateValue = parts[0];
                        if (parts[1]) {
                            // Extrair hora: "09:00:00.000Z" -> "09:00"
                            timeValue = parts[1].substring(0, 5);
                        }
                    } else if (event.event_date.length === 10) {
                        // Apenas data: "2025-11-02"
                        dateValue = event.event_date;
                        timeValue = ''; // Sem hora disponível
                    } else {
                        // Formato desconhecido, tentar extrair data
                        dateValue = event.event_date.substring(0, 10);
                    }
                } else if (event.event_date instanceof Date) {
                    // É um objeto Date
                    dateValue = event.event_date.toISOString().split('T')[0];
                    const timePart = event.event_date.toISOString().split('T')[1];
                    if (timePart) {
                        timeValue = timePart.substring(0, 5);
                    }
                }
            }
            
            if (eventDate) eventDate.value = dateValue;
            if (eventTime) eventTime.value = timeValue;
            
            // Log para debug
            if (event.event_date) {
                console.log('📅 Preenchendo campos de data/hora:', {
                    original: event.event_date,
                    dateField: dateValue,
                    timeField: timeValue,
                    hasTime: !!timeValue
                });
            }
            if (eventLocation) eventLocation.value = event.location || '';
            if (eventType) eventType.value = event.event_type || 'running';
            
            // Atualizar distance_km - garantir que o valor é tratado corretamente
            if (eventDistance) {
                let distanceValue = '';
                
                // Se event.distance_km existe, usar ele
                if (event.distance_km !== null && event.distance_km !== undefined) {
                    if (typeof event.distance_km === 'number') {
                        distanceValue = event.distance_km.toString();
                    } else if (typeof event.distance_km === 'string') {
                        distanceValue = event.distance_km;
                    } else {
                        distanceValue = String(event.distance_km);
                    }
                }
                
                // Aplicar valor no campo
                eventDistance.value = distanceValue;
                console.log('📏 Atualizando campo distance_km:', {
                    original: event.distance_km,
                    tipo: typeof event.distance_km,
                    valueSet: distanceValue,
                    campoId: eventDistance.id,
                    campoAtualAntes: eventDistance.value
                });
                
                // Forçar atualização visual se necessário
                if (eventDistance.value !== distanceValue) {
                    console.warn('⚠️ Campo distance_km não atualizado! Tentando forçar...');
                    eventDistance.setAttribute('value', distanceValue);
                    eventDistance.value = distanceValue;
                    // Trigger change event para garantir que qualquer listener seja notificado
                    eventDistance.dispatchEvent(new Event('input', { bubbles: true }));
                    eventDistance.dispatchEvent(new Event('change', { bubbles: true }));
                    console.log('🔄 Campo distance_km forçado para:', eventDistance.value);
                }
            }
            
            if (eventStatus) eventStatus.value = event.status || 'active';
            if (hasCategories) hasCategories.value = event.has_categories ? 'true' : 'false';
            if (autoStartEnabled) autoStartEnabled.value = event.auto_start_enabled ? 'true' : 'false';
            if (scheduledStartTime) {
                if (event.scheduled_start_time) {
                    // Converter ISO string para formato datetime-local (YYYY-MM-DDTHH:mm)
                    // scheduled_start_time pode vir como ISO string completa ou apenas data+hora
                    const scheduledDate = new Date(event.scheduled_start_time);
                    if (!isNaN(scheduledDate.getTime())) {
                        // Formato datetime-local requer YYYY-MM-DDTHH:mm (sem segundos e sem timezone)
                        const year = scheduledDate.getFullYear();
                        const month = String(scheduledDate.getMonth() + 1).padStart(2, '0');
                        const day = String(scheduledDate.getDate()).padStart(2, '0');
                        const hours = String(scheduledDate.getHours()).padStart(2, '0');
                        const minutes = String(scheduledDate.getMinutes()).padStart(2, '0');
                        scheduledStartTime.value = `${year}-${month}-${day}T${hours}:${minutes}`;
                        console.log('⏰ [updateFormFields] scheduled_start_time preenchido:', {
                            original: event.scheduled_start_time,
                            formatoDatetimeLocal: scheduledStartTime.value
                        });
                    } else {
                        // Fallback: tentar substring se new Date falhar
                        scheduledStartTime.value = event.scheduled_start_time.substring(0, 16);
                    }
                } else {
                    scheduledStartTime.value = '';
                }
            }
            if (eventDescription) eventDescription.value = event.description || '';
            
            // Load lap counter configuration
            loadLapCounterConfig(event.id);
        }
        
        function hideEventInfo() {
            const configSections = document.getElementById('configSections');
            const emptyState = document.getElementById('emptyState');
            const eventInfoDisplay = document.getElementById('eventInfoDisplay');
            
            if (configSections) configSections.style.display = 'none';
            if (emptyState) emptyState.style.display = 'block';
            if (eventInfoDisplay) eventInfoDisplay.style.display = 'none';
            
            currentEvent = null;
        }
        
        // =====================================================
        // FUNÇÕES PARA CATEGORIAS E MODALIDADES
        // =====================================================
        
        async function loadCategories() {
            try {
                console.log('🏅 Carregando categorias via API REST...');
                const response = await fetch('/api/config/age-categories', {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const categories = result.categories || result.data || [];
                
                console.log('✅ Categorias carregadas via API REST:', categories.length);
                renderCategoriesConfig(categories);
            } catch (error) {
                console.error('❌ Erro ao carregar categorias:', error);
                showError('Erro ao carregar categorias');
            }
        }
        
        async function loadModalities() {
            try {
                console.log('🏃 Carregando modalidades via API REST...');
                const response = await fetch('/api/config/event-modalities', {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const modalities = result.modalities || result.data || [];
                
                console.log('✅ Modalidades carregadas via API REST:', modalities.length);
                renderModalitiesConfig(modalities);
            } catch (error) {
                console.error('❌ Erro ao carregar modalidades:', error);
                showError('Erro ao carregar modalidades');
            }
        }
        
        async function loadEventCategoryConfig(eventId) {
            try {
                console.log('🔧 Carregando configuração de categorias do evento via API REST...');
                const response = await fetch(`/api/events/${eventId}/category-configs`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        // Endpoint pode não existir ainda - retornar vazio
                        return [];
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const config = result.configs || result.data || [];
                
                console.log('✅ Configuração de categorias carregada via API REST:', config.length);
                return config;
            } catch (error) {
                console.error('❌ Erro ao carregar configuração de categorias:', error);
                return [];
            }
        }
        
        async function loadEventModalityConfig(eventId) {
            try {
                console.log('🔧 Carregando configuração de modalidades do evento via API REST...');
                const response = await fetch(`/api/events/${eventId}/modality-configs`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        // Endpoint pode não existir ainda - retornar vazio
                        return [];
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const config = result.configs || result.data || [];
                
                console.log('✅ Configuração de modalidades carregada via API REST:', config.length);
                return config;
            } catch (error) {
                console.error('❌ Erro ao carregar configuração de modalidades:', error);
                return [];
            }
        }
        
        function renderCategoriesConfig(categories) {
            const container = document.getElementById('categoriesConfig');
            if (!container) return;
            
            let html = '';
            categories.forEach(category => {
                const genderText = category.gender === 'M' ? 'Masculino' : 
                                 category.gender === 'F' ? 'Feminino' : 'Misto';
                
                html += `
                    <div class="checkbox-item">
                        <input type="checkbox" 
                               id="category_${category.id}" 
                               value="${category.id}"
                               data-category='${JSON.stringify(category)}'>
                        <label for="category_${category.id}">
                            <span class="category-icon">${category.icon}</span>
                            <div class="category-info">
                                <div class="category-name">${category.name}</div>
                                <div class="category-details">${genderText} • ${category.min_age}-${category.max_age} anos</div>
                            </div>
                        </label>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function renderModalitiesConfig(modalities) {
            const container = document.getElementById('modalitiesConfig');
            if (!container) return;
            
            let html = '';
            modalities.forEach(modality => {
                html += `
                    <div class="checkbox-item">
                        <input type="checkbox" 
                               id="modality_${modality.id}" 
                               value="${modality.id}"
                               data-modality='${JSON.stringify(modality)}'
                               onchange="handleModalityChange('${modality.id}', '${modality.name}')">
                        <label for="modality_${modality.id}">
                            <span class="category-icon">${modality.icon}</span>
                            <div class="category-info">
                                <div class="category-name">${modality.name}</div>
                                <div class="category-details">${modality.description || ''}</div>
                            </div>
                        </label>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function updateCategoryCheckboxes(categoryConfig) {
            // Clear all checkboxes first
            const checkboxes = document.querySelectorAll('#categoriesConfig input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Check enabled categories
            categoryConfig.forEach(config => {
                if (config.is_enabled) {
                    const checkbox = document.getElementById(`category_${config.age_category_id}`);
                    if (checkbox) {
                        checkbox.checked = true;
                    }
                }
            });
        }
        
        function updateModalityCheckboxes(modalityConfig) {
            // Clear all checkboxes first
            const checkboxes = document.querySelectorAll('#modalitiesConfig input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Check enabled modalities
            modalityConfig.forEach(config => {
                if (config.is_enabled) {
                    const checkbox = document.getElementById(`modality_${config.modality_id}`);
                    if (checkbox) {
                        checkbox.checked = true;
                    }
                }
            });
        }
        
        async function saveCategoryConfigurations(eventId) {
            try {
                console.log('💾 Salvando configurações de categorias via API REST...');
                
                // Get all checked categories
                const checkedCategories = document.querySelectorAll('#categoriesConfig input[type="checkbox"]:checked');
                
                const configs = Array.from(checkedCategories).map(checkbox => ({
                    event_id: eventId,
                    age_category_id: checkbox.value,
                    is_enabled: true
                }));
                
                // Usar API REST para salvar configurações de categorias
                const response = await fetch(`/api/events/${eventId}/category-configs`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ configs })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log('✅ Configurações de categorias salvas via API REST:', checkedCategories.length);
                return result;
            } catch (error) {
                console.error('❌ Erro ao salvar configurações de categorias:', error);
                throw error;
            }
        }
        
        async function saveModalityConfigurations(eventId) {
            try {
                console.log('💾 Salvando configurações de modalidades via API REST...');
                
                // Get all checked modalities
                const checkedModalities = document.querySelectorAll('#modalitiesConfig input[type="checkbox"]:checked');
                
                const configs = Array.from(checkedModalities).map(checkbox => ({
                    event_id: eventId,
                    modality_id: checkbox.value,
                    is_enabled: true
                }));
                
                // Usar API REST para salvar configurações de modalidades
                const response = await fetch(`/api/events/${eventId}/modality-configs`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ configs })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log('✅ Configurações de modalidades salvas via API REST:', checkedModalities.length);
                return result;
            } catch (error) {
                console.error('❌ Erro ao salvar configurações de modalidades:', error);
                throw error;
            }
        }
        
        async function saveEventConfig() {
            if (!currentEvent || !currentEvent.id) {
                showError('Nenhum evento selecionado');
                return;
            }
            
            try {
                const eventName = document.getElementById('eventName')?.value?.trim() || '';
                const eventDate = document.getElementById('eventDate')?.value || '';
                const eventTime = document.getElementById('eventTime')?.value || '';
                const eventLocation = document.getElementById('eventLocation')?.value?.trim() || '';
                const eventType = document.getElementById('eventType')?.value || 'running';
                const eventDistance = document.getElementById('eventDistance')?.value || '';
                console.log('📊 Valores do formulário:', {
                    eventDistance: eventDistance,
                    eventDistanceType: typeof eventDistance,
                    eventDistanceParsed: eventDistance ? parseFloat(eventDistance) : null
                });
                const eventStatus = document.getElementById('eventStatus')?.value || 'active';
                const hasCategories = document.getElementById('hasCategories')?.value === 'true';
                const autoStartEnabled = document.getElementById('autoStartEnabled')?.value === 'true';
                const scheduledStartTimeElement = document.getElementById('scheduledStartTime');
                const scheduledStartTime = scheduledStartTimeElement?.value || '';
                const eventDescription = document.getElementById('eventDescription')?.value?.trim() || '';
                
                console.log('⏰ [saveEventConfig] Campo scheduledStartTime:', {
                    elemento: scheduledStartTimeElement,
                    valor: scheduledStartTime,
                    tipo: typeof scheduledStartTime,
                    isEmpty: !scheduledStartTime,
                    valorAtualNoFormulario: scheduledStartTimeElement?.value
                });
                
                // Validar nome obrigatório
                if (!eventName) {
                    showError('O nome do evento é obrigatório');
                    document.getElementById('eventName')?.focus();
                    return;
                }
                
                // Combine date and time
                let eventDateTime = null;
                
                // Determinar qual data usar (do formulário ou do evento atual)
                let dateToUse = eventDate;
                if (!dateToUse && currentEvent?.event_date) {
                    // Se não há data no formulário, usar a data atual do evento
                    dateToUse = currentEvent.event_date.split('T')[0];
                }
                
                // Se tem data E hora, combinar ambos
                if (dateToUse && eventTime) {
                    const localDateTime = new Date(`${dateToUse}T${eventTime}`);
                    if (!isNaN(localDateTime.getTime())) {
                        eventDateTime = localDateTime.toISOString();
                        console.log('✅ Data e hora combinadas:', {
                            date: dateToUse,
                            time: eventTime,
                            result: eventDateTime
                        });
                    }
                } else if (dateToUse && !eventTime) {
                    // Se só tem data, preservar hora atual do evento ou usar 00:00
                    let timeToUse = '00:00:00';
                    if (currentEvent?.event_date) {
                        const timePart = currentEvent.event_date.split('T')[1];
                        if (timePart) {
                            timeToUse = timePart.substring(0, 8); // HH:mm:ss
                        }
                    }
                    const localDate = new Date(`${dateToUse}T${timeToUse}`);
                    if (!isNaN(localDate.getTime())) {
                        eventDateTime = localDate.toISOString();
                        console.log('✅ Apenas data atualizada (hora preservada):', eventDateTime);
                    }
                } else if (eventTime && !dateToUse) {
                    // Se só tem hora (sem data), usar data de hoje
                    const today = new Date().toISOString().split('T')[0];
                    const localDateTime = new Date(`${today}T${eventTime}`);
                    if (!isNaN(localDateTime.getTime())) {
                        eventDateTime = localDateTime.toISOString();
                        console.log('⚠️ Apenas hora preenchida - usando data de hoje:', eventDateTime);
                    }
                }
                
                // Log para debug
                console.log('📅 Processamento de data/hora:', {
                    eventDateFromForm: eventDate,
                    eventTimeFromForm: eventTime,
                    dateToUse: dateToUse,
                    eventDateTime: eventDateTime,
                    currentEventDate: currentEvent?.event_date,
                    hasDateTime: !!eventDateTime
                });
                
                // Preparar dados para API (campos básicos suportados pela API)
                const apiUpdateData = {
                    name: eventName,
                    description: eventDescription || null,
                    location: eventLocation || null,
                    status: eventStatus,
                    distance_km: eventDistance ? parseFloat(eventDistance) : null,
                    event_type: eventType,
                    has_categories: hasCategories === 'true'
                };
                
                // Incluir event_date apenas se foi calculado
                if (eventDateTime) {
                    apiUpdateData.event_date = eventDateTime;
                    console.log('📤 Enviando event_date para API:', eventDateTime);
                } else if (eventTime || eventDate) {
                    // Se o usuário preencheu hora ou data mas eventDateTime é null, avisar
                    console.warn('⚠️ Hora/data preenchida mas eventDateTime é null:', { eventDate, eventTime });
                }
                
                // Incluir scheduled_start_time se foi preenchido
                if (scheduledStartTime && scheduledStartTime.trim() !== '') {
                    try {
                        // scheduledStartTime vem no formato datetime-local (YYYY-MM-DDTHH:mm)
                        // new Date() precisa converter corretamente considerando timezone local
                        const scheduledTimeISO = new Date(scheduledStartTime).toISOString();
                        apiUpdateData.scheduled_start_time = scheduledTimeISO;
                        console.log('📤 [saveEventConfig] Enviando scheduled_start_time para API:', {
                            valorOriginal: scheduledStartTime,
                            valorISO: scheduledTimeISO,
                            valorAtualNaBD: currentEvent?.scheduled_start_time
                        });
                    } catch (error) {
                        console.error('❌ [saveEventConfig] Erro ao converter scheduled_start_time:', error);
                        console.warn('⚠️ [saveEventConfig] scheduled_start_time ignorado devido a erro de conversão');
                    }
                } else {
                    console.log('ℹ️ [saveEventConfig] scheduled_start_time não preenchido ou vazio - não será enviado');
                    // Se estava preenchido antes mas agora está vazio, enviar null para limpar
                    if (currentEvent?.scheduled_start_time) {
                        apiUpdateData.scheduled_start_time = null;
                        console.log('🗑️ [saveEventConfig] Limpando scheduled_start_time (estava preenchido mas agora está vazio)');
                    }
                }
                
                // Preparar dados completos para Supabase (fallback)
                const supabaseUpdateData = {
                    name: eventName,
                    event_date: eventDateTime,
                    location: eventLocation || null,
                    event_type: eventType,
                    distance_km: eventDistance ? parseFloat(eventDistance) : null,
                    status: eventStatus,
                    has_categories: hasCategories,
                    auto_start_enabled: autoStartEnabled,
                    scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : null,
                    description: eventDescription || null,
                    updated_at: new Date().toISOString()
                };
                
                console.log('💾 Salvando evento:', {
                    id: currentEvent.id,
                    apiData: apiUpdateData,
                    supabaseData: supabaseUpdateData,
                    distance_km_enviado: apiUpdateData.distance_km,
                    distance_km_tipo: typeof apiUpdateData.distance_km
                });
                
                // Usar API REST que bypassa RLS e garante permissões adequadas
                try {
                    const response = await fetch(`/api/events/${currentEvent.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        credentials: 'include',
                        body: JSON.stringify(apiUpdateData)
                    });
                    
                    const apiResult = await response.json();
                    
                    if (!response.ok || !apiResult.success) {
                        const errorMsg = apiResult.error || `Erro HTTP ${response.status}`;
                        console.error('❌ Erro na API:', errorMsg);
                        throw new Error(errorMsg);
                    }
                    
                    console.log('✅ Evento atualizado via API com sucesso:', apiResult.event);
                    console.log('📥 event_date retornado pela API:', apiResult.event?.event_date);
                    console.log('📥 distance_km retornado pela API:', apiResult.event?.distance_km, 'tipo:', typeof apiResult.event?.distance_km);
                    console.log('📥 event_type retornado pela API:', apiResult.event?.event_type);
                    console.log('📥 scheduled_start_time retornado pela API:', apiResult.event?.scheduled_start_time, 'tipo:', typeof apiResult.event?.scheduled_start_time);
                    
                    // Verificar se scheduled_start_time foi atualizado corretamente
                    if (apiUpdateData.scheduled_start_time !== undefined) {
                        const sentScheduledTime = apiUpdateData.scheduled_start_time;
                        const returnedScheduledTime = apiResult.event?.scheduled_start_time || null;
                        
                        // Comparar valores (normalizar para ISO string)
                        const sentISO = sentScheduledTime ? new Date(sentScheduledTime).toISOString() : null;
                        const returnedISO = returnedScheduledTime ? new Date(returnedScheduledTime).toISOString() : null;
                        
                        console.log('🔍 Verificando scheduled_start_time:', {
                            enviado: sentScheduledTime,
                            enviadoISO: sentISO,
                            retornado: returnedScheduledTime,
                            retornadoISO: returnedISO,
                            saoDiferentes: sentISO !== returnedISO
                        });
                        
                        if (sentISO !== returnedISO && sentScheduledTime) {
                            console.warn('⚠️ scheduled_start_time retornado pela API difere do enviado. Atualizando novamente via API REST...');
                            try {
                                const scheduledTimeUpdateResponse = await fetch(`/api/events/${currentEvent.id}`, {
                                    method: 'PUT',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    credentials: 'include',
                                    body: JSON.stringify({ scheduled_start_time: sentScheduledTime })
                                });
                                
                                if (scheduledTimeUpdateResponse.ok) {
                                    const scheduledTimeUpdateResult = await scheduledTimeUpdateResponse.json();
                                    console.log('✅ scheduled_start_time atualizado via API REST:', sentScheduledTime);
                                    if (apiResult.event && scheduledTimeUpdateResult.event) {
                                        apiResult.event.scheduled_start_time = scheduledTimeUpdateResult.event.scheduled_start_time || sentScheduledTime;
                                    }
                                } else {
                                    console.error('❌ Erro ao atualizar scheduled_start_time via API REST:', scheduledTimeUpdateResponse.status);
                                }
                            } catch (scheduledTimeUpdateErr) {
                                console.error('❌ Erro ao atualizar scheduled_start_time via API REST:', scheduledTimeUpdateErr);
                            }
                        } else if (sentISO === returnedISO) {
                            console.log('✅ scheduled_start_time já está correto no resultado da API:', returnedISO);
                        }
                    }
                    
                    // Verificar se a hora foi preservada
                    if (apiResult.event?.event_date && eventDateTime) {
                        const returnedDate = apiResult.event.event_date;
                        const hasTime = returnedDate.includes('T') || returnedDate.includes(' ') || returnedDate.length > 10;
                        console.log('🔍 Verificação de hora:', {
                            returnedDate,
                            hasTime,
                            returnedLength: returnedDate.length,
                            originalSent: eventDateTime
                        });
                        
                        // Se a hora foi perdida, atualizar diretamente via Supabase
                        if (!hasTime && eventTime) {
                            console.warn('⚠️ A hora foi perdida na resposta da API! Atualizando via API REST...');
                            try {
                                const dateUpdateResponse = await fetch(`/api/events/${currentEvent.id}`, {
                                    method: 'PUT',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    credentials: 'include',
                                    body: JSON.stringify({ event_date: eventDateTime })
                                });
                                
                                if (dateUpdateResponse.ok) {
                                    const dateUpdateResult = await dateUpdateResponse.json();
                                    console.log('✅ event_date atualizado via API REST com hora:', eventDateTime);
                                    if (apiResult.event && dateUpdateResult.event) {
                                        apiResult.event.event_date = dateUpdateResult.event.event_date || eventDateTime;
                                    }
                                } else {
                                    console.error('❌ Erro ao atualizar event_date via API REST:', dateUpdateResponse.status);
                                }
                            } catch (dateUpdateErr) {
                                console.error('❌ Erro ao atualizar event_date via API REST:', dateUpdateErr);
                            }
                        }
                    }
                    
                    // Se há hora preenchida, garantir que está salva corretamente via API REST
                    if (eventDateTime && eventTime) {
                        console.log('🔄 Garantindo que event_date com hora está salvo via API REST...');
                        try {
                            const dateConfirmResponse = await fetch(`/api/events/${currentEvent.id}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                credentials: 'include',
                                body: JSON.stringify({ event_date: eventDateTime })
                            });
                            
                            if (dateConfirmResponse.ok) {
                                const dateConfirmResult = await dateConfirmResponse.json();
                                console.log('✅ event_date com hora confirmado via API REST:', eventDateTime);
                                if (apiResult.event && dateConfirmResult.event) {
                                    apiResult.event.event_date = dateConfirmResult.event.event_date || eventDateTime;
                                }
                            } else {
                                console.warn('⚠️ Erro ao confirmar event_date via API REST:', dateConfirmResponse.status);
                            }
                        } catch (dateConfirmErr) {
                            console.warn('⚠️ Erro ao confirmar event_date via API REST:', dateConfirmErr);
                        }
                    }
                    
                    // SEMPRE atualizar distance_km via Supabase após a API (garantia de persistência)
                    // A API pode não salvar corretamente devido a RLS ou outros problemas
                    if (eventDistance) {
                        const distanceEnviado = parseFloat(eventDistance);
                        const distanceRetornado = apiResult.event?.distance_km;
                        
                        console.log('🔍 Verificando distance_km:', {
                            enviado: distanceEnviado,
                            retornado: distanceRetornado,
                            saoDiferentes: distanceEnviado !== distanceRetornado
                        });
                        
                        // Se o valor retornado pela API é diferente do enviado, fazer UPDATE novamente via API REST
                        // A API REST usa service role e bypassa RLS, então deve funcionar
                        if (distanceEnviado !== distanceRetornado) {
                            console.log('🔄 distance_km diferente do enviado, atualizando novamente via API REST...');
                            try {
                                const apiUpdateResponse = await fetch(`/api/events/${currentEvent.id}`, {
                                    method: 'PUT',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    credentials: 'include',
                                    body: JSON.stringify({ distance_km: distanceEnviado })
                                });
                                
                                if (apiUpdateResponse.ok) {
                                    const apiUpdateResult = await apiUpdateResponse.json();
                                    if (apiUpdateResult.success && apiUpdateResult.event?.distance_km) {
                                        const distanceFinal = apiUpdateResult.event.distance_km;
                                        console.log('✅ distance_km atualizado via API REST (2ª tentativa):', distanceFinal);
                                        
                                        // Atualizar apiResult.event com o valor confirmado
                                        if (apiResult.event) {
                                            apiResult.event.distance_km = distanceFinal;
                                        }
                                    } else {
                                        console.warn('⚠️ API REST retornou sucesso mas distance_km não foi atualizado');
                                        // Mesmo assim, usar o valor enviado
                                        if (apiResult.event) {
                                            apiResult.event.distance_km = distanceEnviado;
                                        }
                                    }
                                } else {
                                    const errorText = await apiUpdateResponse.text();
                                    console.warn('⚠️ Erro ao atualizar distance_km via API REST (2ª tentativa):', apiUpdateResponse.status, errorText);
                                    // Mesmo assim, usar o valor enviado no apiResult
                                    if (apiResult.event) {
                                        apiResult.event.distance_km = distanceEnviado;
                                    }
                                }
                            } catch (apiUpdateErr) {
                                console.warn('⚠️ Exceção ao atualizar distance_km via API REST (2ª tentativa):', apiUpdateErr);
                                // Mesmo assim, usar o valor enviado no apiResult
                                if (apiResult.event) {
                                    apiResult.event.distance_km = distanceEnviado;
                                }
                            }
                        } else {
                            console.log('✅ distance_km já está correto no resultado da API:', distanceRetornado);
                        }
                    }
                    
                    // Atualizar outros campos adicionais via API REST se necessário
                    const needsAdditionalUpdate = eventType !== apiResult.event?.event_type ||
                                              hasCategories !== apiResult.event?.has_categories ||
                                              autoStartEnabled !== apiResult.event?.auto_start_enabled ||
                                              (scheduledStartTime ? new Date(scheduledStartTime).toISOString() : null) !== (apiResult.event?.scheduled_start_time || null);
                    
                    if (needsAdditionalUpdate) {
                        console.log('🔄 Atualizando outros campos adicionais via API REST...');
                        try {
                            const additionalUpdateResponse = await fetch(`/api/events/${currentEvent.id}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                credentials: 'include',
                                body: JSON.stringify({
                                    event_type: eventType,
                                    has_categories: hasCategories,
                                    auto_start_enabled: autoStartEnabled,
                                    scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : null
                                })
                            });
                            
                            if (additionalUpdateResponse.ok) {
                                const additionalUpdateResult = await additionalUpdateResponse.json();
                                console.log('✅ Campos adicionais atualizados via API REST:', additionalUpdateResult.event);
                            } else {
                                console.warn('⚠️ Erro ao atualizar campos adicionais via API REST:', additionalUpdateResponse.status);
                            }
                        } catch (additionalUpdateErr) {
                            console.warn('⚠️ Erro ao atualizar campos adicionais via API REST:', additionalUpdateErr);
                        }
                    }
                    
                    // Atualizar currentEvent com os dados retornados
                    // IMPORTANTE: Garantir que event_date inclua a hora se foi fornecida
                    if (apiResult.event) {
                        // Se enviamos hora mas API retornou só data, usar a hora que enviamos
                        if (eventDateTime && eventTime && apiResult.event.event_date && 
                            apiResult.event.event_date.length === 10 && 
                            !apiResult.event.event_date.includes('T')) {
                            console.log('🔧 Corrigindo event_date no currentEvent com a hora enviada');
                            apiResult.event.event_date = eventDateTime;
                        }
                        
                        // Garantir que distance_km está incluído no objeto atualizado
                        // Se o valor retornado é diferente do enviado, usar o valor enviado
                        const distanceEnviado = eventDistance ? parseFloat(eventDistance) : null;
                        const distanceRetornado = apiResult.event.distance_km;
                        
                        if (distanceEnviado !== null && distanceEnviado !== distanceRetornado) {
                            console.warn('⚠️ distance_km retornado pela API (', distanceRetornado, ') difere do enviado (', distanceEnviado, '). Usando valor enviado.');
                            apiResult.event.distance_km = distanceEnviado;
                        } else if (distanceEnviado !== null && apiResult.event.distance_km === undefined) {
                            console.log('🔧 Adicionando distance_km ao resultado da API:', distanceEnviado);
                            apiResult.event.distance_km = distanceEnviado;
                        }
                        
                        // Garantir que event_type está incluído
                        if (eventType && apiResult.event.event_type === undefined) {
                            console.log('🔧 Adicionando event_type ao resultado da API:', eventType);
                            apiResult.event.event_type = eventType;
                        } else if (eventType && apiResult.event.event_type !== eventType) {
                            console.warn('⚠️ event_type retornado pela API difere do enviado. Usando valor enviado.');
                            apiResult.event.event_type = eventType;
                        }
                        
                        currentEvent = { ...currentEvent, ...apiResult.event };
                        console.log('📝 currentEvent atualizado:', {
                            event_date: currentEvent.event_date,
                            distance_km: currentEvent.distance_km,
                            event_type: currentEvent.event_type,
                            location: currentEvent.location,
                            scheduled_start_time: currentEvent.scheduled_start_time
                        });
                    }
                    
                } catch (apiError) {
                    console.error('❌ Erro ao chamar API:', apiError);
                    
                    // Não fazer fallback para Supabase direto - mostrar erro ao usuário
                    showError(`Erro ao salvar configurações: ${apiError.message || 'Erro desconhecido'}`);
                    return;
                }
                
                // Save category configurations
                try {
                    await saveCategoryConfigurations(currentEvent.id);
                } catch (err) {
                    console.warn('⚠️ Erro ao salvar categorias:', err);
                }
                
                // Save modality configurations
                try {
                    await saveModalityConfigurations(currentEvent.id);
                } catch (err) {
                    console.warn('⚠️ Erro ao salvar modalidades:', err);
                }
                
                // Save lap counter configuration
                try {
                    await saveLapCounterConfig(currentEvent.id);
                } catch (err) {
                    console.warn('⚠️ Erro ao salvar configuração de voltas:', err);
                }
                
                // Save dorsal nomenclature configuration (includes assignment mode)
                try {
                    await saveDorsalNomenclatureConfig(currentEvent.id);
                } catch (err) {
                    console.warn('⚠️ Erro ao salvar configuração de dorsais:', err);
                }
                
                showSuccess('Configurações salvas com sucesso!');
                
                // Atualizar campos do formulário diretamente com os dados salvos
                // (evitar reload que pode perder a hora por causa da API)
                // Garantir que currentEvent tem a hora correta antes de atualizar o formulário
                if (eventDateTime && eventTime && currentEvent?.event_date && 
                    currentEvent.event_date.length === 10 && 
                    !currentEvent.event_date.includes('T')) {
                    currentEvent.event_date = eventDateTime;
                    console.log('🔧 Corrigindo currentEvent.event_date antes de atualizar formulário:', currentEvent.event_date);
                }
                
                // Atualizar apenas os campos do formulário sem recarregar tudo da API
                // Isso preserva a hora que acabamos de salvar
                // IMPORTANTE: Preservar também o distance_km que foi enviado
                if (currentEvent) {
                    // Garantir que distance_km preserva o valor enviado se foi diferente do retornado
                    if (eventDistance) {
                        const distanceEnviado = parseFloat(eventDistance);
                        if (currentEvent.distance_km !== distanceEnviado) {
                            console.log('🔧 Corrigindo currentEvent.distance_km com valor enviado:', distanceEnviado);
                            currentEvent.distance_km = distanceEnviado;
                        }
                    }
                    
                    updateFormFields(currentEvent);
                    updateEventDisplay(currentEvent);
                    console.log('✅ Formulário atualizado localmente (preservando hora, distância e scheduled_start_time salvas):', {
                        event_date: currentEvent.event_date,
                        distance_km: currentEvent.distance_km,
                        scheduled_start_time: currentEvent.scheduled_start_time
                    });
                }
                
            } catch (error) {
                console.error('❌ Erro ao salvar evento:', error);
                showError(`Erro ao salvar configurações: ${error.message || 'Erro desconhecido'}`);
            }
        }
        
        function resetEventConfig() {
            if (currentEvent) {
                updateFormFields(currentEvent);
                showSuccess('Formulário resetado');
            }
        }
        
        async function deleteEvent() {
            if (!currentEvent) {
                showError('Nenhum evento selecionado');
                return;
            }
            
            if (!confirm(`Tem certeza que deseja excluir o evento "${currentEvent.name}"? Esta ação não pode ser desfeita.`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/events/${currentEvent.id}`, {
                    method: 'DELETE',
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                showSuccess('Evento excluído com sucesso!');
                
                // Reset form
                hideEventInfo();
                
                // Reload events
                await loadEvents();
                
            } catch (error) {
                console.error('Erro ao excluir evento:', error);
                showError(`Erro ao excluir evento: ${error.message || 'Erro desconhecido'}`);
            }
        }
        
        // =====================================================
        // FUNÇÕES PARA CHECKPOINT TYPES (GLOBAL)
        // =====================================================
        
        async function loadCheckpointTypes() {
            try {
                console.log('📍 Carregando tipos de checkpoints via API REST...');
                const response = await fetch('/api/config/checkpoint-types', {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const types = result.types || result.data || [];
                
                console.log('✅ Tipos de checkpoints carregados via API REST:', types.length);
                renderCheckpointTypesConfig(types);
            } catch (error) {
                console.error('❌ Erro ao carregar tipos:', error);
                const container = document.getElementById('checkpointTypesConfig');
                container.innerHTML = `
                    <div style="padding: var(--spacing-4); background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); border-radius: var(--radius-base); color: var(--danger);">
                        ❌ Erro ao carregar tipos. Execute <strong>create-checkpoint-types.sql</strong> no Supabase.
                    </div>
                `;
            }
        }
        
        function renderCheckpointTypesConfig(types) {
            const container = document.getElementById('checkpointTypesConfig');
            
            if (types.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary);">Nenhum tipo configurado</p>';
                return;
            }
            
            container.innerHTML = types.map(type => `
                <div style="display: flex; align-items: center; gap: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: var(--radius-base); margin-bottom: var(--spacing-2); border-left: 4px solid ${type.color};">
                    <div style="font-size: var(--font-size-2xl); flex-shrink: 0;">${type.icon}</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; color: var(--text-primary); margin-bottom: var(--spacing-1);">${type.name}</div>
                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">
                            ${type.description || ''} • 
                            ${type.is_start ? '🏁 Início' : ''}
                            ${type.is_finish ? '🏁 Meta' : ''}
                            ${type.is_intermediate ? '📍 Intermédio' : ''} • 
                            Splits: ${type.requires_split ? '✓' : '✗'}
                        </div>
                    </div>
                    <div style="display: flex; gap: var(--spacing-1);">
                        <button class="btn btn-sm btn-ghost" onclick="toggleCheckpointType('${type.code}', ${!type.is_active})" title="${type.is_active ? 'Desativar' : 'Ativar'}">
                            ${type.is_active ? '✓' : '✗'}
                        </button>
                    </div>
                </div>
            `).join('');
        }
        
        async function toggleCheckpointType(code, activate) {
            try {
                const response = await fetch(`/api/config/checkpoint-types/${code}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ is_active: activate })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                showSuccess(`Tipo ${activate ? 'ativado' : 'desativado'}!`);
                await loadCheckpointTypes();
                
            } catch (error) {
                console.error('❌ Erro ao atualizar tipo:', error);
                showError(`Erro ao atualizar tipo: ${error.message}`);
            }
        }
        
        // Setup listeners for checkpoint types
        document.addEventListener('DOMContentLoaded', () => {
            const addCheckpointTypeBtn = document.getElementById('addCheckpointTypeBtn');
            const refreshCheckpointTypesBtn = document.getElementById('refreshCheckpointTypesBtn');
            
            if (addCheckpointTypeBtn) {
                addCheckpointTypeBtn.addEventListener('click', () => {
                    showSuccess('Funcionalidade em desenvolvimento. Use SQL para adicionar tipos personalizados.');
                });
            }
            
            if (refreshCheckpointTypesBtn) {
                refreshCheckpointTypesBtn.addEventListener('click', loadCheckpointTypes);
            }
        });
        
        function showError(message) {
            // Simple error display - you can enhance this with toast notifications
            alert(`❌ ${message}`);
        }
        
        function showSuccess(message) {
            // Simple success display - you can enhance this with toast notifications
            alert(`✅ ${message}`);
        }
        
        // Processor Configuration Functions
        function initializeProcessorConfig() {
            console.log('🤖 Inicializando configuração do processador...');
            
            // Processor type selection
            const processorTypeSelect = document.getElementById('processorType');
            if (processorTypeSelect) {
                processorTypeSelect.addEventListener('change', handleProcessorTypeChange);
            }
            
            // Processor speed selection
            const processorSpeedSelect = document.getElementById('processorSpeed');
            if (processorSpeedSelect) {
                processorSpeedSelect.addEventListener('change', handleProcessorSpeedChange);
            }
            
            // Confidence range
            const confidenceRange = document.getElementById('processorConfidence');
            if (confidenceRange) {
                confidenceRange.addEventListener('input', handleConfidenceChange);
            }
            
            // OpenAI model selection
            const openaiModelSelect = document.getElementById('openaiModel');
            if (openaiModelSelect) {
                openaiModelSelect.addEventListener('change', handleOpenAIModelChange);
            }
            
            // Gemini model selection
            const geminiModelSelect = document.getElementById('geminiModel');
            if (geminiModelSelect) {
                geminiModelSelect.addEventListener('change', saveProcessorConfig);
            }
            
            // Reload models button
            const reloadModelsBtn = document.getElementById('reloadModelsBtn');
            if (reloadModelsBtn) {
                reloadModelsBtn.addEventListener('click', () => {
                    loadOpenAIModels();
                });
            }
            
            // Reload Gemini models button
            const reloadGeminiModelsBtn = document.getElementById('reloadGeminiModelsBtn');
            if (reloadGeminiModelsBtn) {
                reloadGeminiModelsBtn.addEventListener('click', () => {
                    loadGeminiModels();
                });
            }
            
            // DeepSeek model reload button
            const reloadDeepSeekModelsBtn = document.getElementById('reloadDeepSeekModelsBtn');
            if (reloadDeepSeekModelsBtn) {
                reloadDeepSeekModelsBtn.addEventListener('click', () => {
                    loadDeepSeekModels();
                });
            }
            
            // DeepSeek model selection
            const deepseekModelSelect = document.getElementById('deepseekModel');
            if (deepseekModelSelect) {
                deepseekModelSelect.addEventListener('change', saveProcessorConfig);
            }
            
            // Processor info cards
            const processorCards = document.querySelectorAll('.processor-info-card');
            processorCards.forEach(card => {
                card.addEventListener('click', () => selectProcessorCard(card));
            });
            
            // Load saved processor config
            loadProcessorConfig();
        }
        
        function handleProcessorTypeChange(event) {
            const selectedType = event.target.value;
            console.log('🔧 Tipo de processador alterado:', selectedType);
            
            // Update processor cards selection
            updateProcessorCardsSelection(selectedType);
            
            // Update processor speed options based on type
            updateProcessorSpeedOptions(selectedType);
            
            // Show/hide model selectors
            const openaiModelGroup = document.getElementById('openaiModelGroup');
            const geminiModelGroup = document.getElementById('geminiModelGroup');
            const deepseekModelGroup = document.getElementById('deepseekModelGroup');
            
            if (openaiModelGroup) {
                if (selectedType === 'openai') {
                    openaiModelGroup.style.display = 'block';
                    loadOpenAIModels();
                } else {
                    openaiModelGroup.style.display = 'none';
                }
            }
            
            if (geminiModelGroup) {
                if (selectedType === 'gemini') {
                    geminiModelGroup.style.display = 'block';
                    loadGeminiModels();
                } else {
                    geminiModelGroup.style.display = 'none';
                }
            }
            
            if (deepseekModelGroup) {
                if (selectedType === 'deepseek') {
                    deepseekModelGroup.style.display = 'block';
                    loadDeepSeekModels();
                } else {
                    deepseekModelGroup.style.display = 'none';
                }
            }
            
            // Save configuration
            saveProcessorConfig();
        }
        
        async function loadGeminiModels() {
            const geminiModelSelect = document.getElementById('geminiModel');
            if (!geminiModelSelect) return;
            
            try {
                geminiModelSelect.innerHTML = '<option value="">Carregando...</option>';
                
                const response = await fetch('/api/gemini/models');
                const data = await response.json();
                
                if (data.success && data.models) {
                    geminiModelSelect.innerHTML = '';
                    
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name} ($${model.pricing.input}/1M tokens)`;
                        geminiModelSelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Erro ao carregar modelos Gemini:', error);
                geminiModelSelect.innerHTML = '<option value="">Erro ao carregar modelos</option>';
            }
        }
        
        async function loadOpenAIModels() {
            const openaiModelSelect = document.getElementById('openaiModel');
            if (!openaiModelSelect) return;
            
            try {
                openaiModelSelect.innerHTML = '<option value="">Carregando...</option>';
                
                const response = await fetch('/api/openai/models');
                const data = await response.json();
                
                if (data.success && data.models) {
                    openaiModelSelect.innerHTML = '';
                    
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name} ($${model.pricing.input}/1K input, $${model.pricing.output}/1K output)`;
                        openaiModelSelect.appendChild(option);
                    });
                    
                    // Se há valor salvo, selecionar
                    const savedConfig = localStorage.getItem(`visionkrono_processor_config_${currentEvent?.id}`);
                    if (savedConfig) {
                        try {
                            const config = JSON.parse(savedConfig);
                            if (config.openaiModel) {
                                openaiModelSelect.value = config.openaiModel;
                            }
                        } catch (e) {
                            console.error('Erro ao carregar configuração salva:', e);
                        }
                    }
                    
                    // Default para gpt-4o se não houver seleção
                    if (!openaiModelSelect.value && data.models.length > 0) {
                        const defaultModel = data.models.find(m => m.id.includes('gpt-4o')) || data.models[0];
                        openaiModelSelect.value = defaultModel.id;
                    }
                } else {
                    throw new Error(data.error || 'Erro ao carregar modelos');
                }
            } catch (error) {
                console.error('Erro ao carregar modelos OpenAI:', error);
                openaiModelSelect.innerHTML = '<option value="">Erro ao carregar modelos</option>';
            }
        }
        
        async function loadDeepSeekModels() {
            const deepseekModelSelect = document.getElementById('deepseekModel');
            if (!deepseekModelSelect) return;
            
            try {
                deepseekModelSelect.innerHTML = '<option value="">Carregando...</option>';
                
                const response = await fetch('/api/deepseek/models');
                const data = await response.json();
                
                if (data.success && data.models) {
                    deepseekModelSelect.innerHTML = '';
                    
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name} ($${model.pricing.input}/1M input, $${model.pricing.output}/1M output)`;
                        deepseekModelSelect.appendChild(option);
                    });
                    
                    // Se há valor salvo, selecionar
                    const savedConfig = localStorage.getItem(`visionkrono_processor_config_${currentEvent?.id}`);
                    if (savedConfig) {
                        try {
                            const config = JSON.parse(savedConfig);
                            if (config.deepseekModel) {
                                deepseekModelSelect.value = config.deepseekModel;
                            }
                        } catch (e) {
                            console.error('Erro ao carregar configuração salva:', e);
                        }
                    }
                    
                    // Default para deepseek-chat se não houver seleção
                    if (!deepseekModelSelect.value && data.models.length > 0) {
                        const defaultModel = data.models.find(m => m.id.includes('deepseek-chat')) || data.models[0];
                        deepseekModelSelect.value = defaultModel.id;
                    }
                } else {
                    throw new Error(data.error || 'Erro ao carregar modelos');
                }
            } catch (error) {
                console.error('Erro ao carregar modelos DeepSeek:', error);
                deepseekModelSelect.innerHTML = '<option value="">Erro ao carregar modelos</option>';
            }
        }
        
        function handleProcessorSpeedChange(event) {
            const selectedSpeed = event.target.value;
            console.log('⚡ Velocidade alterada:', selectedSpeed);
            saveProcessorConfig();
        }
        
        function handleOpenAIModelChange(event) {
            const selectedModel = event.target.value;
            console.log('🤖 Modelo OpenAI alterado:', selectedModel);
            saveProcessorConfig();
        }
        
        function handleConfidenceChange(event) {
            const confidence = event.target.value;
            const confidenceValue = document.getElementById('confidenceValue');
            if (confidenceValue) {
                confidenceValue.textContent = Math.round(confidence * 100) + '%';
            }
            console.log('🎯 Confiança alterada:', confidence);
            saveProcessorConfig();
        }
        
        function selectProcessorCard(card) {
            const processorType = card.dataset.processor;
            console.log('🎯 Processador selecionado:', processorType);
            
            // Update select
            const processorTypeSelect = document.getElementById('processorType');
            if (processorTypeSelect) {
                processorTypeSelect.value = processorType;
            }
            
            // Update cards selection
            updateProcessorCardsSelection(processorType);
            
            // Update speed options
            updateProcessorSpeedOptions(processorType);
            
            // Save configuration
            saveProcessorConfig();
        }
        
        function updateProcessorCardsSelection(selectedType) {
            const processorCards = document.querySelectorAll('.processor-info-card');
            processorCards.forEach(card => {
                if (card.dataset.processor === selectedType) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });
        }
        
        function updateProcessorSpeedOptions(processorType) {
            const speedSelect = document.getElementById('processorSpeed');
            if (!speedSelect) return;
            
            // Clear existing options
            speedSelect.innerHTML = '';
            
            // Add options based on processor type
            const speedOptions = {
                'gemini': [
                    { value: 'fast', text: '⚡ Rápido (Menos Precisão)' },
                    { value: 'balanced', text: '⚖️ Equilibrado (Padrão)' },
                    { value: 'accurate', text: '🎯 Preciso (Mais Lento)' }
                ],
                'openai': [
                    { value: 'fast', text: '⚡ Rápido (Menos Precisão)' },
                    { value: 'balanced', text: '⚖️ Equilibrado (Padrão)' },
                    { value: 'accurate', text: '🎯 Preciso (Mais Lento)' }
                ],
                'google-vision': [
                    { value: 'fast', text: '⚡ Rápido (Menos Precisão)' },
                    { value: 'balanced', text: '⚖️ Equilibrado (Padrão)' }
                ],
                'ocr': [
                    { value: 'fast', text: '⚡ Rápido (Menos Precisão)' },
                    { value: 'balanced', text: '⚖️ Equilibrado (Padrão)' }
                ],
                'hybrid': [
                    { value: 'balanced', text: '⚖️ Equilibrado (Padrão)' },
                    { value: 'accurate', text: '🎯 Preciso (Mais Lento)' }
                ],
                'manual': [
                    { value: 'manual', text: '✋ Manual (Sem IA)' }
                ]
            };
            
            const options = speedOptions[processorType] || speedOptions['gemini'];
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option.value;
                optionElement.textContent = option.text;
                speedSelect.appendChild(optionElement);
            });
            
            // Set default to balanced if available
            if (speedSelect.querySelector('option[value="balanced"]')) {
                speedSelect.value = 'balanced';
            } else {
                speedSelect.value = speedSelect.firstElementChild.value;
            }
        }
        
        function loadProcessorConfig() {
            if (!currentEvent) return;
            
            console.log('📥 Carregando configuração do processador...');
            
            // Load from event configuration or use defaults
            const defaultConfig = {
                processorType: 'gemini',
                processorSpeed: 'balanced',
                processorConfidence: 0.7
            };
            
            // Apply configuration
            const processorTypeSelect = document.getElementById('processorType');
            const processorSpeedSelect = document.getElementById('processorSpeed');
            const confidenceRange = document.getElementById('processorConfidence');
            const confidenceValue = document.getElementById('confidenceValue');
            
            if (processorTypeSelect) {
                processorTypeSelect.value = defaultConfig.processorType;
                updateProcessorCardsSelection(defaultConfig.processorType);
                updateProcessorSpeedOptions(defaultConfig.processorType);
            }
            
            if (processorSpeedSelect) {
                processorSpeedSelect.value = defaultConfig.processorSpeed;
            }
            
            if (confidenceRange) {
                confidenceRange.value = defaultConfig.processorConfidence;
            }
            
            if (confidenceValue) {
                confidenceValue.textContent = Math.round(defaultConfig.processorConfidence * 100) + '%';
            }
        }
        
        function saveProcessorConfig() {
            if (!currentEvent) return;
            
            const config = {
                processorType: document.getElementById('processorType')?.value || 'gemini',
                processorSpeed: document.getElementById('processorSpeed')?.value || 'balanced',
                processorConfidence: parseFloat(document.getElementById('processorConfidence')?.value || '0.7'),
                openaiModel: document.getElementById('openaiModel')?.value || 'gpt-4o',
                geminiModel: document.getElementById('geminiModel')?.value || 'gemini-1.5-flash',
                deepseekModel: document.getElementById('deepseekModel')?.value || 'deepseek-chat'
            };
            
            console.log('💾 Salvando configuração do processador:', config);
            
            // Salvar no localStorage
            localStorage.setItem(`visionkrono_processor_config_${currentEvent.id}`, JSON.stringify(config));
            
            // Salvar no Supabase
            saveProcessorConfigToSupabase(config);
        }
        
        async function saveProcessorConfigToSupabase(config) {
            try {
                if (!currentEvent || !currentEvent.id) {
                    console.log('⚠️ Nenhum evento selecionado');
                    return;
                }
                
                const response = await fetch(`/api/events/${currentEvent.id}/processor-config`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        processor_type: config.processorType,
                        processor_speed: config.processorSpeed,
                        processor_confidence: config.processorConfidence,
                        openai_model: config.openaiModel || 'gpt-4o',
                        gemini_model: config.geminiModel || 'gemini-1.5-flash',
                        deepseek_model: config.deepseekModel || 'deepseek-chat'
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log('✅ Configuração salva via API REST:', result);
                showSuccess('Configuração do processador salva com sucesso!');
                
            } catch (error) {
                console.error('❌ Erro ao salvar configuração:', error);
                showError(`Erro ao salvar configuração no servidor: ${error.message}`);
            }
        }
        
        async function loadProcessorConfig() {
            if (!currentEvent) return;
            
            console.log('📥 Carregando configuração do processador...');
            
            // Tentar carregar do Supabase primeiro
            let config = await loadProcessorConfigFromSupabase();
            
            // Se não encontrar no Supabase, tentar localStorage
            if (!config) {
                const localConfig = localStorage.getItem(`visionkrono_processor_config_${currentEvent.id}`);
                if (localConfig) {
                    try {
                        config = JSON.parse(localConfig);
                        console.log('📥 Configuração carregada do localStorage:', config);
                    } catch (error) {
                        console.error('❌ Erro ao carregar configuração do localStorage:', error);
                    }
                }
            }
            
            // Usar configuração padrão se não encontrar nenhuma
            if (!config) {
                config = {
                    processorType: 'gemini',
                    processorSpeed: 'balanced',
                    processorConfidence: 0.7,
                    openaiModel: 'gpt-4o',
                    geminiModel: 'gemini-1.5-flash',
                    deepseekModel: 'deepseek-chat'
                };
                console.log('📥 Usando configuração padrão:', config);
            }
            
            // Aplicar configuração
            const processorTypeSelect = document.getElementById('processorType');
            const processorSpeedSelect = document.getElementById('processorSpeed');
            const confidenceRange = document.getElementById('processorConfidence');
            const confidenceValue = document.getElementById('confidenceValue');
            const openaiModelSelect = document.getElementById('openaiModel');
            const geminiModelSelect = document.getElementById('geminiModel');
            const deepseekModelSelect = document.getElementById('deepseekModel');
            
            if (processorTypeSelect) {
                processorTypeSelect.value = config.processorType;
                updateProcessorCardsSelection(config.processorType);
                updateProcessorSpeedOptions(config.processorType);
            }
            
            if (processorSpeedSelect) {
                processorSpeedSelect.value = config.processorSpeed;
            }
            
            if (confidenceRange) {
                confidenceRange.value = config.processorConfidence;
            }
            
            if (confidenceValue) {
                confidenceValue.textContent = Math.round(config.processorConfidence * 100) + '%';
            }
            
            if (openaiModelSelect && config.openaiModel) {
                openaiModelSelect.value = config.openaiModel;
            }
            
            if (geminiModelSelect && config.geminiModel) {
                geminiModelSelect.value = config.geminiModel;
            }
            
            if (deepseekModelSelect && config.deepseekModel) {
                deepseekModelSelect.value = config.deepseekModel;
            }
        }
        
        async function loadProcessorConfigFromSupabase() {
            try {
                if (!currentEvent || !currentEvent.id) {
                    return null;
                }
                
                const response = await fetch(`/api/events/${currentEvent.id}/processor-config`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        // Config não existe ainda - retornar null
                        return null;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success && result.config) {
                    // Converter formato da API para formato esperado
                    const config = {
                        processorType: result.config.processor_type || result.config.processorType,
                        processorSpeed: result.config.processor_speed || result.config.processorSpeed,
                        processorConfidence: result.config.processor_confidence || result.config.processorConfidence,
                        openaiModel: result.config.openai_model || result.config.openaiModel || 'gpt-4o',
                        geminiModel: result.config.gemini_model || result.config.geminiModel || 'gemini-1.5-flash',
                        deepseekModel: result.config.deepseek_model || result.config.deepseekModel || 'deepseek-chat'
                    };
                    console.log('✅ Configuração carregada via API REST:', config);
                    return config;
                }
                
                return null;
            } catch (error) {
                console.error('❌ Erro ao carregar configuração:', error);
                return null;
            }
        }
        
        // =====================================================
        // FUNÇÕES PARA CONTADOR DE VOLTAS
        // =====================================================
        
        async function loadLapCounterConfig(eventId) {
            try {
                console.log('🔄 Carregando configuração de contador de voltas via API REST...');
                
                // Carregar configuração do evento via API REST
                const eventResponse = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!eventResponse.ok) {
                    console.error('❌ Erro ao carregar configuração do evento:', eventResponse.status);
                    return;
                }
                
                const eventResult = await eventResponse.json();
                const eventData = eventResult.event;
                
                if (!eventData) {
                    console.log('ℹ️ Evento não encontrado ou sem configuração de lap counter');
                    return;
                }
                
                // Carregar configuração detalhada de voltas via API REST
                const lapResponse = await fetch(`/api/events/${eventId}/lap-config`, {
                    credentials: 'include'
                });
                
                let lapConfig = null;
                if (lapResponse.ok) {
                    const lapResult = await lapResponse.json();
                    lapConfig = lapResult.config || null;
                } else if (lapResponse.status !== 404) {
                    console.error('❌ Erro ao carregar configuração de voltas:', lapResponse.status);
                }
                
                // Atualizar campos do formulário
                const hasLapCounter = document.getElementById('hasLapCounter');
                const lapDistance = document.getElementById('lapDistance');
                const totalLaps = document.getElementById('totalLaps');
                const minLapsForClassification = document.getElementById('minLapsForClassification');
                
                if (hasLapCounter) {
                    hasLapCounter.value = eventData.has_lap_counter ? 'true' : 'false';
                }
                
                if (lapConfig) {
                    if (lapDistance) lapDistance.value = lapConfig.lap_distance_km || '';
                    if (totalLaps) totalLaps.value = lapConfig.total_laps || '';
                    if (minLapsForClassification) minLapsForClassification.value = lapConfig.min_laps_for_classification || 1;
                } else {
                    if (lapDistance) lapDistance.value = '';
                    if (totalLaps) totalLaps.value = '';
                    if (minLapsForClassification) minLapsForClassification.value = 1;
                }
                
                // Ativar/desativar campos baseado na configuração
                handleLapCounterToggle();
                
                // Validar configuração
                await validateLapCounterSetup(eventId);
                
            } catch (error) {
                console.error('❌ Erro ao carregar configuração de voltas:', error);
            }
        }
        
        // Alternar visualização conforme modo de dorsais
        function handleDorsalModeChange() {
            const mode = document.getElementById('dorsalMode').value;
            
            document.getElementById('dorsalSequentialConfig').style.display = 
                mode === 'sequential' ? 'block' : 'none';
            document.getElementById('dorsalCategoryConfig').style.display = 
                mode === 'per_category' ? 'block' : 'none';
            document.getElementById('dorsalRandomConfig').style.display = 
                mode === 'random' ? 'block' : 'none';
            
            console.log('🔢 Modo de dorsais alterado:', mode);
        }
        
        // Salvar configuração de dorsais
        async function saveDorsalConfig(eventId) {
            try {
                const modeEl = document.getElementById('dorsalMode');
                const startEl = document.getElementById('dorsalStartFrom');
                
                if (!modeEl || !startEl) {
                    console.warn('⚠️ Elementos de config de dorsais não encontrados');
                    return;
                }
                
                const mode = modeEl.value;
                const startFrom = parseInt(startEl.value) || 1;
                
                const dorsalConfig = {
                    mode: mode,
                    start_from: startFrom
                };
                
                // Configurações específicas por modo
                if (mode === 'random') {
                    const maxEl = document.getElementById('dorsalRandomMax');
                    dorsalConfig.end_at = parseInt(maxEl?.value) || 999;
                } else if (mode === 'per_category') {
                    // TODO: Ler category_ranges dos inputs
                    dorsalConfig.category_ranges = {};
                }
                
                // Atualizar settings do evento via API REST
                const eventResponse = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!eventResponse.ok) {
                    throw new Error(`HTTP ${eventResponse.status}`);
                }
                
                const eventResult = await eventResponse.json();
                const event = eventResult.event;
                
                if (!event) {
                    console.warn('⚠️ Evento não encontrado');
                    return;
                }
                
                const newSettings = {
                    ...(event.settings || {}),
                    dorsal_assignment: dorsalConfig
                };
                
                const updateResponse = await fetch(`/api/events/${eventId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ settings: newSettings })
                });
                
                if (!updateResponse.ok) {
                    const errorData = await updateResponse.json().catch(() => ({ error: 'Erro desconhecido' }));
                    throw new Error(errorData.error || `HTTP ${updateResponse.status}`);
                }
                
                console.log('✅ Configuração de dorsais salva:', dorsalConfig);
                
            } catch (error) {
                console.error('❌ Erro ao salvar config de dorsais:', error);
                throw error;
            }
        }
        
        // Carregar configuração de dorsais
        async function loadDorsalConfig(eventId) {
            try {
                const response = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        console.warn('⚠️ Evento não encontrado para carregar config de dorsais');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const event = result.event;
                
                if (!event) {
                    console.warn('⚠️ Evento não encontrado para carregar config de dorsais');
                    return;
                }
                
                const dorsalConfig = event.settings?.dorsal_assignment || {
                    mode: 'sequential',
                    start_from: 1
                };
                
                // Preencher form
                const modeSelect = document.getElementById('dorsalMode');
                const startFromInput = document.getElementById('dorsalStartFrom');
                
                if (modeSelect) modeSelect.value = dorsalConfig.mode || 'sequential';
                if (startFromInput) startFromInput.value = dorsalConfig.start_from || 1;
                
                if (dorsalConfig.mode === 'random') {
                    const randomMaxInput = document.getElementById('dorsalRandomMax');
                    if (randomMaxInput) randomMaxInput.value = dorsalConfig.end_at || 999;
                }
                
                // Atualizar visualização
                handleDorsalModeChange();
                
                console.log('✅ Configuração de dorsais carregada:', dorsalConfig);
                
            } catch (error) {
                console.error('❌ Erro ao carregar config de dorsais:', error);
            }
        }
        
        // Adicionar range de categoria
        function addCategoryRange() {
            alert('Funcionalidade em desenvolvimento');
            // TODO: Adicionar inputs para categoria, start, end
        }
        
        // Alternar configuração de nomenclatura
        function handleNomenclatureChange(type) {
            const configs = [
                'numericNomenclatureConfig', 
                'prefixNomenclatureConfig', 
                'suffixNomenclatureConfig', 
                'markersNomenclatureConfig',
                'customNomenclatureConfig'
            ];
            
            configs.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
            
            const targetConfig = type === 'prefix' ? 'prefixNomenclatureConfig' :
                                type === 'suffix' ? 'suffixNomenclatureConfig' :
                                type === 'prefix-suffix' ? 'prefixNomenclatureConfig' : // Mesmo que prefixo por enquanto
                                type === 'markers' ? 'markersNomenclatureConfig' :
                                type === 'custom' ? 'customNomenclatureConfig' :
                                'numericNomenclatureConfig';
            
            const el = document.getElementById(targetConfig);
            if (el) el.style.display = 'block';
            
            console.log('🏷️ Nomenclatura alterada:', type);
        }
        
        // Salvar configuração de nomenclatura (junto com dorsais)
        async function saveDorsalNomenclatureConfig(eventId) {
            try {
                if (!eventId) {
                    console.warn('⚠️ EventId não fornecido para salvar nomenclatura');
                    return;
                }
                
                console.log('💾 Salvando nomenclatura para evento:', eventId);
                
                const nomenclatureType = document.querySelector('input[name="nomenclatureType"]:checked')?.value || 'numeric';
                console.log('📋 Tipo de nomenclatura:', nomenclatureType);
                
                const nomenclatureConfig = {
                    type: nomenclatureType
                };
                
                // Configurações por tipo (com modo de atribuição)
                if (nomenclatureType === 'numeric') {
                    nomenclatureConfig.numeric = {
                        mode: document.getElementById('nomenclatureNumericMode')?.value || 'sequential',
                        min: parseInt(document.getElementById('nomenclatureNumericMin')?.value) || 1,
                        max: parseInt(document.getElementById('nomenclatureNumericMax')?.value) || 9999,
                        use_padding: document.getElementById('nomenclatureUsePadding')?.checked || false,
                        digits: parseInt(document.getElementById('nomenclatureNumericDigits')?.value) || 3
                    };
                } else if (nomenclatureType === 'prefix') {
                    nomenclatureConfig.prefix = {
                        mode: document.getElementById('nomenclaturePrefixMode')?.value || 'sequential',
                        prefixes: document.getElementById('nomenclaturePrefixText')?.value || 'M,F',
                        separator: document.getElementById('nomenclaturePrefixSeparator')?.value || '-',
                        min: parseInt(document.getElementById('nomenclaturePrefixMin')?.value) || 1,
                        max: parseInt(document.getElementById('nomenclaturePrefixMax')?.value) || 999
                    };
                } else if (nomenclatureType === 'suffix') {
                    nomenclatureConfig.suffix = {
                        mode: document.getElementById('nomenclatureSuffixMode')?.value || 'sequential',
                        suffixes: document.getElementById('nomenclatureSuffixText')?.value || 'M,F',
                        separator: document.getElementById('nomenclatureSuffixSeparator')?.value || '-',
                        min: parseInt(document.getElementById('nomenclatureSuffixMin')?.value) || 1,
                        max: parseInt(document.getElementById('nomenclatureSuffixMax')?.value) || 999
                    };
                } else if (nomenclatureType === 'markers') {
                    nomenclatureConfig.markers = {
                        start_color: document.getElementById('nomenclatureStartColor')?.value || '#10b981',
                        end_color: document.getElementById('nomenclatureEndColor')?.value || '#ef4444',
                        tolerance: parseInt(document.getElementById('nomenclatureColorTolerance')?.value) || 20
                    };
                } else if (nomenclatureType === 'custom') {
                    nomenclatureConfig.custom = {
                        regex: document.getElementById('nomenclatureCustomRegex')?.value || '',
                        examples: document.getElementById('nomenclatureCustomExamples')?.value || ''
                    };
                }
                
                // Buscar settings atuais via API REST antes de atualizar
                // (porque currentEvent.settings pode estar desatualizado)
                console.log('🔍 Buscando settings atuais do evento antes de atualizar via API REST...');
                
                let currentEventData = null;
                try {
                    const fetchResponse = await fetch(`/api/events/${eventId}`, {
                        credentials: 'include'
                    });
                    
                    if (fetchResponse.ok) {
                        const fetchResult = await fetchResponse.json();
                        currentEventData = fetchResult.event;
                    } else {
                        console.error('❌ Erro ao buscar settings atuais:', fetchResponse.status);
                    }
                } catch (fetchErr) {
                    console.error('❌ Erro ao buscar settings atuais:', fetchErr);
                }
                
                const currentSettings = (currentEventData?.settings && typeof currentEventData.settings === 'object') 
                    ? currentEventData.settings 
                    : (currentEvent?.settings || {});
                
                console.log('✅ Settings atual (do Supabase):', currentSettings);
                console.log('✅ Settings atual (do currentEvent):', currentEvent?.settings);
                console.log('✅ Settings que será usado:', currentSettings);
                
                // Garantir que currentSettings é um objeto válido
                const validCurrentSettings = (currentSettings && typeof currentSettings === 'object' && !Array.isArray(currentSettings))
                    ? currentSettings 
                    : {};
                
                let newSettings = {
                    ...validCurrentSettings,
                    dorsal_nomenclature: nomenclatureConfig
                };
                
                console.log('💾 Novos settings a guardar:', JSON.stringify(newSettings, null, 2));
                console.log('💾 Tipo de newSettings:', typeof newSettings);
                console.log('💾 Keys em newSettings:', Object.keys(newSettings));
                
                // Atualizar settings via API REST (bypassa RLS)
                console.log('🔄 Executando UPDATE via API REST...');
                
                try {
                    const response = await fetch(`/api/events/${eventId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        credentials: 'include', // Incluir cookies para autenticação
                        body: JSON.stringify({
                            // Apenas enviar settings (nome não é obrigatório se só atualizarmos settings)
                            settings: newSettings
                        })
                    });
                    
                    const apiResult = await response.json();
                    
                    if (!response.ok || !apiResult.success) {
                        const errorMsg = apiResult.error || 'Erro ao atualizar via API';
                        console.error('❌ Erro na API:', errorMsg);
                        throw new Error(errorMsg);
                    }
                    
                    console.log('✅ Resultado do UPDATE via API:', apiResult);
                    console.log('✅ Settings após UPDATE (confirmação):', apiResult.event?.settings);
                    
                    // Verificar se realmente foi guardado e usar os settings retornados pela API
                    if (apiResult.event?.settings && Object.keys(apiResult.event.settings).length > 0) {
                        // Usar os settings retornados pela API (são os confirmados guardados)
                        newSettings = apiResult.event.settings;
                        console.log('✅ Usando settings confirmados da API');
                    } else {
                        console.warn('⚠️ UPDATE via API não retornou settings. Verificando diretamente...');
                        const verifyResponse = await fetch(`/api/events/${eventId}`, {
                            credentials: 'include'
                        });
                        const verifyResult = await verifyResponse.json();
                        
                        if (verifyResult.success && verifyResult.event?.settings && Object.keys(verifyResult.event.settings).length > 0) {
                            console.log('✅ Verificação direta - settings guardado:', verifyResult.event.settings);
                            newSettings = verifyResult.event.settings;
                        } else {
                            console.error('❌ ATENÇÃO: Settings não foi guardado corretamente!');
                        }
                    }
                    
                } catch (apiError) {
                    console.error('❌ Erro ao atualizar via API REST:', apiError);
                    // Não fazer fallback para Supabase - mostrar erro
                    throw apiError;
                }
                
                // Atualizar currentEvent também
                if (currentEvent) {
                    currentEvent.settings = newSettings;
                    console.log('✅ currentEvent.settings atualizado localmente');
                }
                
                console.log('✅ Nomenclatura de dorsais salva com sucesso:', nomenclatureConfig);
                
            } catch (error) {
                console.error('❌ Erro ao salvar nomenclatura:', error);
                throw error;
            }
        }
        
        // Carregar configuração de nomenclatura
        async function loadDorsalNomenclatureConfig(eventId) {
            try {
                const response = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                const event = result.event;
                
                if (!event) return;
                
                const nomenclatureConfig = event.settings?.dorsal_nomenclature || {
                    type: 'numeric',
                    numeric: { min: 1, max: 9999, use_padding: false, digits: 3 }
                };
                
                // Selecionar tipo
                const radioInput = document.querySelector(`input[name="nomenclatureType"][value="${nomenclatureConfig.type}"]`);
                if (radioInput) {
                    radioInput.checked = true;
                    handleNomenclatureChange(nomenclatureConfig.type);
                }
                
                // Preencher campos numéricos
                if (nomenclatureConfig.numeric) {
                    const minInput = document.getElementById('nomenclatureNumericMin');
                    const maxInput = document.getElementById('nomenclatureNumericMax');
                    const paddingInput = document.getElementById('nomenclatureUsePadding');
                    const digitsInput = document.getElementById('nomenclatureNumericDigits');
                    
                    if (minInput) minInput.value = nomenclatureConfig.numeric.min || 1;
                    if (maxInput) maxInput.value = nomenclatureConfig.numeric.max || 9999;
                    if (paddingInput) paddingInput.checked = nomenclatureConfig.numeric.use_padding || false;
                    if (digitsInput) digitsInput.value = nomenclatureConfig.numeric.digits || 3;
                }
                
                console.log('✅ Nomenclatura carregada:', nomenclatureConfig);
                
            } catch (error) {
                console.error('❌ Erro ao carregar nomenclatura:', error);
            }
        }
        
        function handleLapCounterToggle() {
            const hasLapCounter = document.getElementById('hasLapCounter');
            const lapDistance = document.getElementById('lapDistance');
            const totalLaps = document.getElementById('totalLaps');
            const minLapsForClassification = document.getElementById('minLapsForClassification');
            
            const isEnabled = hasLapCounter && hasLapCounter.value === 'true';
            
            if (lapDistance) lapDistance.disabled = !isEnabled;
            if (totalLaps) totalLaps.disabled = !isEnabled;
            if (minLapsForClassification) minLapsForClassification.disabled = !isEnabled;
            
            // Limpar campos se desativado
            if (!isEnabled) {
                if (lapDistance) lapDistance.value = '';
                if (totalLaps) totalLaps.value = '';
                if (minLapsForClassification) minLapsForClassification.value = 1;
            }
            
            // Validar configuração
            if (currentEvent) {
                validateLapCounterSetup(currentEvent.id);
            }
        }
        
        async function validateLapCounterSetup(eventId) {
            try {
                const hasLapCounter = document.getElementById('hasLapCounter');
                const validationDiv = document.getElementById('lapCounterValidation');
                const validationText = document.getElementById('lapCounterValidationText');
                
                if (!hasLapCounter || !validationDiv || !validationText) return;
                
                const isEnabled = hasLapCounter.value === 'true';
                
                if (!isEnabled) {
                    validationDiv.style.display = 'none';
                    return;
                }
                
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    validationText.textContent = 'Erro: Supabase não disponível';
                    validationDiv.style.display = 'block';
                    return;
                }
                
                // Verificar se tem dispositivos necessários
                const { data: lapDevices, error: lapError } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .select(`
                        *,
                        checkpoint_types!inner(code, is_finish)
                    `)
                    .eq('event_id', eventId);
                
                if (lapError) {
                    validationText.textContent = 'Erro ao verificar dispositivos';
                    validationDiv.style.display = 'block';
                    return;
                }
                
                const lapCounterDevices = lapDevices.filter(d => d.checkpoint_types.code === 'lap_counter');
                const finishDevices = lapDevices.filter(d => d.checkpoint_types.is_finish);
                
                if (lapCounterDevices.length === 0) {
                    validationText.textContent = 'Necessário pelo menos 1 dispositivo com checkpoint "Contador de Voltas"';
                    validationDiv.style.display = 'block';
                } else if (finishDevices.length === 0) {
                    validationText.textContent = 'Necessário pelo menos 1 dispositivo com checkpoint "Meta"';
                    validationDiv.style.display = 'block';
                } else {
                    validationText.textContent = `✅ Configuração válida: ${lapCounterDevices.length} contador(es) de voltas, ${finishDevices.length} meta(s)`;
                    validationDiv.style.display = 'block';
                    validationDiv.style.background = 'rgba(34, 197, 94, 0.1)';
                    validationDiv.style.borderColor = 'var(--success)';
                    validationDiv.style.color = 'var(--success)';
                }
                
            } catch (error) {
                console.error('❌ Erro ao validar configuração de voltas:', error);
                const validationText = document.getElementById('lapCounterValidationText');
                if (validationText) {
                    validationText.textContent = 'Erro ao validar configuração';
                }
            }
        }
        
        async function saveLapCounterConfig(eventId) {
            try {
                console.log('💾 Salvando configuração de contador de voltas via API REST...');
                
                const hasLapCounter = document.getElementById('hasLapCounter');
                const lapDistance = document.getElementById('lapDistance');
                const totalLaps = document.getElementById('totalLaps');
                const minLapsForClassification = document.getElementById('minLapsForClassification');
                
                const isEnabled = hasLapCounter && hasLapCounter.value === 'true';
                const distance = lapDistance && lapDistance.value ? parseFloat(lapDistance.value) : null;
                const totalLapsValue = totalLaps && totalLaps.value ? parseInt(totalLaps.value) : null;
                const minLaps = minLapsForClassification && minLapsForClassification.value ? parseInt(minLapsForClassification.value) : 1;
                
                console.log('💾 [saveLapCounterConfig] Valores coletados:', {
                    isEnabled,
                    distance,
                    totalLapsValue,
                    minLaps,
                    hasLapCounterValue: hasLapCounter?.value
                });
                
                // Atualizar evento com has_lap_counter (sempre enviar este campo)
                // IMPORTANTE: Enviar como boolean true/false explícito
                // Converter de string 'true'/'false' para boolean
                let hasLapCounterValue = false; // Default: false
                if (hasLapCounter) {
                    const value = hasLapCounter.value;
                    hasLapCounterValue = (value === 'true' || value === true || value === '1');
                }
                console.log('💾 [saveLapCounterConfig] Enviando has_lap_counter:', {
                    valorOriginal: hasLapCounter?.value,
                    valorConvertido: hasLapCounterValue,
                    tipo: typeof hasLapCounterValue,
                    isEnabled,
                    payload: JSON.stringify({ has_lap_counter: hasLapCounterValue })
                });
                
                const eventUpdateResponse = await fetch(`/api/events/${eventId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ has_lap_counter: hasLapCounterValue })
                });
                
                if (!eventUpdateResponse.ok) {
                    const errorText = await eventUpdateResponse.text();
                    let errorData;
                    try {
                        errorData = JSON.parse(errorText);
                    } catch {
                        errorData = { error: errorText || 'Erro desconhecido' };
                    }
                    console.error('❌ [saveLapCounterConfig] Erro ao atualizar has_lap_counter:', {
                        status: eventUpdateResponse.status,
                        error: errorData
                    });
                    throw new Error(errorData.error || `HTTP ${eventUpdateResponse.status}`);
                }
                
                const eventUpdateResult = await eventUpdateResponse.json();
                console.log('✅ [saveLapCounterConfig] has_lap_counter atualizado:', eventUpdateResult);
                
                // Salvar configuração detalhada via API REST apenas se o lap counter estiver ativado
                // ou se já existir uma configuração para evitar erro de "campos vazios"
                if (isEnabled || distance !== null || totalLapsValue !== null) {
                    const configData = {
                        has_lap_counter: isEnabled,
                        lap_distance_km: distance,
                        total_laps: totalLapsValue,
                        min_laps_for_classification: minLaps
                    };
                    
                    console.log('💾 [saveLapCounterConfig] Enviando config detalhada:', configData);
                    
                    const lapResponse = await fetch(`/api/events/${eventId}/lap-config`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        credentials: 'include',
                        body: JSON.stringify(configData)
                    });
                    
                    if (!lapResponse.ok) {
                        const errorText = await lapResponse.text();
                        let errorData;
                        try {
                            errorData = JSON.parse(errorText);
                        } catch {
                            errorData = { error: errorText || 'Erro desconhecido' };
                        }
                        console.error('❌ [saveLapCounterConfig] Erro ao salvar config detalhada:', {
                            status: lapResponse.status,
                            error: errorData
                        });
                        throw new Error(errorData.error || `HTTP ${lapResponse.status}`);
                    }
                    
                    const result = await lapResponse.json();
                    console.log('✅ Configuração de voltas salva via API REST:', result);
                } else {
                    console.log('ℹ️ Lap counter desativado e sem dados - apenas has_lap_counter foi atualizado');
                }
                
            } catch (error) {
                console.error('❌ Erro ao salvar configuração de voltas:', error);
                throw error;
            }
        }
        
        // =====================================================
        // FUNÇÕES PARA MODALIDADES MULTI-DISCIPLINARES
        // =====================================================
        
        function handleModalityChange(modalityId, modalityName) {
            console.log('🔄 Modalidade alterada:', modalityName);
            
            // Verificar se é modalidade multi-disciplinar
            const isMultimodal = ['Duatlo', 'Triatlo'].includes(modalityName);
            const multimodalConfig = document.getElementById('multimodalConfig');
            
            if (isMultimodal) {
                if (multimodalConfig) multimodalConfig.style.display = 'block';
                loadMultimodalActivities(modalityId);
                if (currentEvent && currentEvent.id) {
                    validateMultimodalSetup(currentEvent.id);
                }
            } else {
                if (multimodalConfig) multimodalConfig.style.display = 'none';
            }
        }
        
        async function loadMultimodalActivities(modalityId) {
            try {
                console.log('🏊🚴🏃 Carregando atividades multi-disciplinares...');
                
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    console.log('⚠️ Supabase não disponível');
                    return;
                }
                
                // Carregar TODAS as atividades (ativas e inativas) para permitir reativação
                const { data: activities, error } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .select('*')
                    .eq('modality_id', modalityId)
                    .order('activity_order');
                
                if (error) {
                    console.error('❌ Erro ao carregar atividades:', error);
                    return;
                }
                
                renderMultimodalActivities(activities || []);
                
            } catch (error) {
                console.error('❌ Erro ao carregar atividades:', error);
            }
        }
        
        function renderMultimodalActivities(activities) {
            const container = document.getElementById('multimodalActivities');
            if (!container) return;
            
            if (activities.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); padding: var(--spacing-4); text-align: center;">Nenhuma atividade configurada para esta modalidade</p>';
                return;
            }
            
            // Ordenar atividades por ordem
            const sortedActivities = [...activities].sort((a, b) => a.activity_order - b.activity_order);
            
            let html = '<div class="form-grid">';
            sortedActivities.forEach((activity, index) => {
                // Estilo diferente para atividades ativas vs inativas
                const isActive = activity.is_active;
                const opacity = isActive ? '1' : '0.6';
                const backgroundOpacity = isActive ? '1' : '0.3';
                const borderColor = isActive ? activity.activity_color : '#6b7280';
                const isLastActivity = index === sortedActivities.length - 1;
                
                html += `
                    <div class="form-group">
                        <div style="display: flex; align-items: center; gap: var(--spacing-3); padding: var(--spacing-4); background: rgba(255, 255, 255, ${backgroundOpacity}); border: 1px solid var(--border-color); border-radius: var(--radius-base); border-left: 4px solid ${borderColor}; opacity: ${opacity};">
                            <div style="display: flex; flex-direction: column; align-items: center; gap: var(--spacing-1);">
                                <div style="font-size: var(--font-size-2xl); flex-shrink: 0;">${activity.activity_icon}</div>
                                <div style="font-size: var(--font-size-xs); color: var(--text-secondary); font-weight: 600;">#${activity.activity_order}</div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: var(--spacing-1);">
                                    ${activity.activity_name}
                                    ${!isActive ? '<span style="font-size: var(--font-size-xs); color: var(--danger); margin-left: var(--spacing-2);">(Desativada)</span>' : ''}
                                    ${isLastActivity ? '<span style="font-size: var(--font-size-xs); color: var(--primary); margin-left: var(--spacing-2);">(Final)</span>' : ''}
                                </div>
                                <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">
                                    Cor: ${activity.activity_color}
                                    ${isLastActivity ? ' • Conta tempo total da prova' : ''}
                                </div>
                            </div>
                            <div style="display: flex; gap: var(--spacing-1); align-items: center;">
                                ${index > 0 ? `
                                    <button class="btn btn-sm btn-ghost" onclick="moveActivity('${activity.id}', 'up')" title="Mover para cima" style="background: var(--primary); color: white; border: none; padding: var(--spacing-1);">
                                        ↑
                                    </button>
                                ` : ''}
                                ${index < sortedActivities.length - 1 ? `
                                    <button class="btn btn-sm btn-ghost" onclick="moveActivity('${activity.id}', 'down')" title="Mover para baixo" style="background: var(--primary); color: white; border: none; padding: var(--spacing-1);">
                                        ↓
                                    </button>
                                ` : ''}
                                <button class="btn btn-sm btn-ghost" onclick="toggleActivity('${activity.id}', ${!activity.is_active})" title="${activity.is_active ? 'Desativar atividade' : 'Ativar atividade'}" style="background: ${activity.is_active ? 'var(--success)' : 'var(--danger)'}; color: white; border: none; min-width: 40px;">
                                    ${activity.is_active ? '✓' : '✗'}
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            // Adicionar informações sobre checkpoints necessários (apenas atividades ativas)
            const activeActivities = sortedActivities.filter(a => a.is_active);
            if (activeActivities.length > 0) {
                html += `
                    <div style="margin-top: var(--spacing-4); padding: var(--spacing-3); background: rgba(59, 130, 246, 0.1); border: 1px solid var(--primary); border-radius: var(--radius-base);">
                        <h4 style="color: var(--primary); margin-bottom: var(--spacing-2);">📋 Checkpoints Necessários:</h4>
                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">
                            Para eventos multi-disciplinares, você precisa configurar dispositivos com os seguintes tipos de checkpoint:
                        </div>
                        <ul style="margin-top: var(--spacing-2); font-size: var(--font-size-sm); color: var(--text-secondary);">
                            ${activeActivities.map(activity => {
                                const checkpointType = activity.activity_name === 'Natação' ? 'Meta Natação' : 
                                                    activity.activity_name === 'Ciclismo' ? 'Meta Ciclismo' : 
                                                    activity.activity_name === 'Corrida' ? 'Meta Corrida' : '';
                                const isLast = activity.activity_order === Math.max(...activeActivities.map(a => a.activity_order));
                                return `<li>${activity.activity_icon} ${checkpointType} (${activity.activity_name})${isLast ? ' - Conta tempo total' : ''}</li>`;
                            }).join('')}
                        </ul>
                        <div style="margin-top: var(--spacing-2); padding: var(--spacing-2); background: rgba(34, 197, 94, 0.1); border-radius: var(--radius-sm); font-size: var(--font-size-sm); color: var(--success);">
                            <strong>💡 Dica:</strong> A última atividade da ordem conta automaticamente o tempo total da prova. Não é necessário dispositivo de "Meta Final" separado.
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        async function moveActivity(activityId, direction) {
            try {
                console.log(`🔄 Movendo atividade ${activityId} para ${direction}...`);
                
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    showError('Supabase não disponível');
                    return;
                }
                
                // Obter atividade atual
                const { data: currentActivity, error: getError } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .select('*')
                    .eq('id', activityId)
                    .single();
                
                if (getError) throw getError;
                
                // Obter todas as atividades da mesma modalidade
                const { data: allActivities, error: allError } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .select('*')
                    .eq('modality_id', currentActivity.modality_id)
                    .order('activity_order');
                
                if (allError) throw allError;
                
                // Encontrar posição atual
                const currentIndex = allActivities.findIndex(a => a.id === activityId);
                if (currentIndex === -1) {
                    showError('Atividade não encontrada');
                    return;
                }
                
                // Calcular nova posição
                let newIndex;
                if (direction === 'up' && currentIndex > 0) {
                    newIndex = currentIndex - 1;
                } else if (direction === 'down' && currentIndex < allActivities.length - 1) {
                    newIndex = currentIndex + 1;
                } else {
                    showError('Não é possível mover nesta direção');
                    return;
                }
                
                // Trocar ordens
                const tempOrder = allActivities[currentIndex].activity_order;
                const newOrder = allActivities[newIndex].activity_order;
                
                // Atualizar ambas as atividades
                const { error: updateError1 } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .update({ activity_order: newOrder })
                    .eq('id', activityId);
                
                if (updateError1) throw updateError1;
                
                const { error: updateError2 } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .update({ activity_order: tempOrder })
                    .eq('id', allActivities[newIndex].id);
                
                if (updateError2) throw updateError2;
                
                showSuccess('Ordem das atividades atualizada!');
                
                // Recarregar atividades
                loadMultimodalActivities(currentActivity.modality_id);
                
            } catch (error) {
                console.error('❌ Erro ao mover atividade:', error);
                showError('Erro ao mover atividade');
            }
        }
        
        async function toggleActivity(activityId, activate) {
            try {
                console.log(`🔄 ${activate ? 'Ativando' : 'Desativando'} atividade ${activityId}...`);
                
                const { error } = await window.supabaseClient.supabase
                    .from('modality_activities')
                    .update({ is_active: activate })
                    .eq('id', activityId);
                
                if (error) throw error;
                
                showSuccess(`Atividade ${activate ? 'ativada' : 'desativada'} com sucesso!`);
                
                // Recarregar atividades para mostrar mudanças visuais
                const checkedModalities = document.querySelectorAll('#modalitiesConfig input[type="checkbox"]:checked');
                checkedModalities.forEach(checkbox => {
                    const modalityData = JSON.parse(checkbox.dataset.modality);
                    if (['Duatlo', 'Triatlo'].includes(modalityData.name)) {
                        loadMultimodalActivities(modalityData.id);
                    }
                });
                
                // Validar configuração se há evento selecionado
                if (currentEvent && currentEvent.id) {
                    validateMultimodalSetup(currentEvent.id);
                }
                
            } catch (error) {
                console.error('❌ Erro ao atualizar atividade:', error);
                showError(`Erro ao ${activate ? 'ativar' : 'desativar'} atividade`);
            }
        }
        
        async function validateMultimodalSetup(eventId) {
            try {
                const validationDiv = document.getElementById('multimodalValidation');
                const validationText = document.getElementById('multimodalValidationText');
                
                if (!validationDiv || !validationText) return;
                
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    validationText.textContent = 'Erro: Supabase não disponível';
                    validationDiv.style.display = 'block';
                    return;
                }
                
                // Verificar se tem dispositivos necessários para modalidades multi-disciplinares
                const { data: lapDevices, error: lapError } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .select(`
                        *,
                        checkpoint_types!inner(code, is_finish)
                    `)
                    .eq('event_id', eventId);
                
                if (lapError) {
                    validationText.textContent = 'Erro ao verificar dispositivos';
                    validationDiv.style.display = 'block';
                    return;
                }
                
                // Verificar checkpoints específicos para modalidades multi-disciplinares
                const swimmingDevices = lapDevices.filter(d => d.checkpoint_types.code === 'swimming_finish');
                const cyclingDevices = lapDevices.filter(d => d.checkpoint_types.code === 'cycling_finish');
                const runningDevices = lapDevices.filter(d => d.checkpoint_types.code === 'running_finish');
                
                // Verificar se o evento é multi-disciplinar
                const { data: event, error: eventError } = await window.supabaseClient.supabase
                    .from('events')
                    .select('event_type')
                    .eq('id', eventId)
                    .single();
                
                if (eventError) {
                    validationText.textContent = 'Erro ao verificar tipo de evento';
                    validationDiv.style.display = 'block';
                    return;
                }
                
                const isMultimodal = ['Duatlo', 'Triatlo'].includes(event.event_type);
                
                if (!isMultimodal) {
                    validationDiv.style.display = 'none';
                    return;
                }
                
                // Validações específicas por modalidade (sem meta final)
                let validationMessage = '';
                let isValid = true;
                
                if (event.event_type === 'Triatlo') {
                    if (swimmingDevices.length === 0) {
                        validationMessage += 'Necessário dispositivo "Meta Natação" • ';
                        isValid = false;
                    }
                    if (cyclingDevices.length === 0) {
                        validationMessage += 'Necessário dispositivo "Meta Ciclismo" • ';
                        isValid = false;
                    }
                    if (runningDevices.length === 0) {
                        validationMessage += 'Necessário dispositivo "Meta Corrida" (conta tempo total) • ';
                        isValid = false;
                    }
                } else if (event.event_type === 'Duatlo') {
                    if (cyclingDevices.length === 0) {
                        validationMessage += 'Necessário dispositivo "Meta Ciclismo" • ';
                        isValid = false;
                    }
                    if (runningDevices.length === 0) {
                        validationMessage += 'Necessário dispositivo "Meta Corrida" (conta tempo total) • ';
                        isValid = false;
                    }
                }
                
                if (isValid) {
                    validationMessage = `✅ Configuração válida para ${event.event_type}`;
                    validationDiv.style.background = 'rgba(34, 197, 94, 0.1)';
                    validationDiv.style.borderColor = 'var(--success)';
                    validationDiv.style.color = 'var(--success)';
                } else {
                    validationMessage = validationMessage.slice(0, -3); // Remove último "• "
                    validationDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                    validationDiv.style.borderColor = 'var(--danger)';
                    validationDiv.style.color = 'var(--danger)';
                }
                
                validationText.textContent = validationMessage;
                validationDiv.style.display = 'block';
                
            } catch (error) {
                console.error('❌ Erro ao validar configuração multi-disciplinar:', error);
                const validationText = document.getElementById('multimodalValidationText');
                if (validationText) {
                    validationText.textContent = 'Erro ao validar configuração';
                }
            }
        }
    </script>
</body>
</html>

