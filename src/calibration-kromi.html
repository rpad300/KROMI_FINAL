<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#fc6b03">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <title>Kromi.online - Calibração IA</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- KROMI Design System -->
    <link rel="stylesheet" href="/kromi-design-system.css">
    <link rel="stylesheet" href="/kromi-layout-fixes.css">
    
    <!-- Sistema de Navegação Unificado -->
    <link rel="stylesheet" href="/navigation-component.css?v=2025102601">
    <link rel="stylesheet" href="/unified-sidebar-styles.css?v=2025102601">
    <link rel="stylesheet" href="/logo-integration.css?v=2025012701">
    
    <style>
        /* Calibration specific styles */
        .calibration-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .step-container {
            display: grid;
            gap: var(--spacing-6);
        }
        
        .step {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            overflow: hidden;
        }
        
        .step-header {
            background: var(--bg-primary);
            padding: var(--spacing-4) var(--spacing-6);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: var(--spacing-4);
        }
        
        .step-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            font-weight: 600;
            font-size: var(--font-size-lg);
        }
        
        .step-title {
            font-size: var(--font-size-xl);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .step-content {
            padding: var(--spacing-6);
        }
        
        .step-description {
            color: var(--text-secondary);
            font-size: var(--font-size-base);
            line-height: 1.6;
            margin-bottom: var(--spacing-4);
        }
        
        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-8);
            text-align: center;
            background: var(--bg-primary);
            transition: all var(--transition-base);
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: var(--primary);
            background: rgba(252, 107, 3, 0.05);
        }
        
        .upload-area.dragover {
            border-color: var(--primary);
            background: rgba(252, 107, 3, 0.1);
        }
        
        .upload-icon {
            font-size: 3rem;
            color: var(--text-tertiary);
            margin-bottom: var(--spacing-4);
        }
        
        .upload-text {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-2);
        }
        
        .upload-subtext {
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
        }
        
        .image-preview {
            max-width: 100%;
            max-height: 400px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            margin: var(--spacing-4) 0;
        }
        
        .detection-area {
            position: relative;
            display: inline-block;
            border: 2px solid var(--primary);
            border-radius: var(--radius-base);
            background: rgba(252, 107, 3, 0.1);
        }
        
        .detection-area.active {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
        }
        
        .calibration-controls {
            display: flex;
            gap: var(--spacing-3);
            margin-top: var(--spacing-4);
            flex-wrap: wrap;
        }
        
        .calibration-results {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-4);
            margin-top: var(--spacing-4);
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: var(--spacing-4);
        }
        
        .modal-content {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            max-height: 90vh;
            overflow-y: auto;
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .btn-outline {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        .btn-outline:hover {
            background: var(--bg-secondary);
            border-color: var(--primary);
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-2) 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-label {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .result-value {
            color: var(--text-secondary);
            font-family: 'Courier New', monospace;
        }
        
        .progress-container {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            padding: var(--spacing-4);
            margin: var(--spacing-4) 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--primary);
            border-radius: var(--radius-sm);
            transition: width 0.3s ease;
        }
        
        .progress-text {
            text-align: center;
            margin-top: var(--spacing-2);
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
        }
        
        .config-form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--spacing-4);
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-2);
        }
        
        .form-label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: var(--font-size-sm);
        }
        
        .form-input,
        .form-select,
        .form-textarea {
            padding: var(--spacing-3);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-base);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: var(--font-size-sm);
        }
        
        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(252, 107, 3, 0.1);
        }
        
        .form-switch {
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
        }
        
        .switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: var(--bg-primary);
            border-radius: 12px;
            cursor: pointer;
            transition: background var(--transition-base);
        }
        
        .switch.active {
            background: var(--primary);
        }
        
        .switch-thumb {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform var(--transition-base);
        }
        
        .switch.active .switch-thumb {
            transform: translateX(20px);
        }
        
        .empty-state {
            text-align: center;
            padding: var(--spacing-12);
            color: var(--text-secondary);
        }
        
        .empty-state i {
            font-size: 4rem;
            margin-bottom: var(--spacing-4);
            opacity: 0.5;
        }
        
        .empty-state h3 {
            font-size: var(--font-size-xl);
            font-weight: 600;
            margin-bottom: var(--spacing-2);
            color: var(--text-primary);
        }
        
        .empty-state p {
            font-size: var(--font-size-base);
            line-height: 1.6;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .config-form {
                grid-template-columns: 1fr;
            }
            
            .calibration-controls {
                flex-direction: column;
            }
            
            .step-header {
                flex-direction: column;
                text-align: center;
            }
        }
        
        /* Layout with Sidebar Structure */
        .layout-with-sidebar {
            display: flex;
            min-height: 100vh;
            background: var(--bg-primary);
            position: relative;
        }
        
        /* Sidebar styles */
        .layout-with-sidebar .sidebar {
            position: fixed;
                left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            z-index: 1050;
            overflow-y: auto;
            transition: transform var(--transition-slow);
        }
        
        /* Header styles */
        .layout-with-sidebar .header {
            position: fixed;
            top: 0;
            left: 280px;
            right: 0;
            height: 60px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            z-index: 1040;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-5);
            transition: left var(--transition-slow);
        }
        
        /* Main content area */
        .layout-with-sidebar .main {
            margin-left: 280px;
            margin-top: 60px;
            width: calc(100% - 280px);
            min-height: calc(100vh - 60px);
            transition: margin-left var(--transition-slow), width var(--transition-slow);
        }
        
        /* Mobile adjustments */
        @media (max-width: 1024px) {
            body {
                overflow-x: hidden;
            }
            
            .layout-with-sidebar .sidebar {
                transform: translateX(-100%);
            }
            
            .layout-with-sidebar .sidebar.sidebar-open {
                transform: translateX(0);
            }
            
            .layout-with-sidebar .header {
                left: 0;
            }
            
            .layout-with-sidebar .main {
                margin-left: 0 !important;
                margin-top: 60px !important;
                width: 100% !important;
                min-height: calc(100vh - 60px) !important;
                padding-bottom: 80px !important;
            }
            
            /* Ensure content fills the screen */
            #mainContent {
                min-height: calc(100vh - 60px - 80px);
                padding: var(--spacing-4);
            }
            
            #menuToggle {
                display: block !important;
            }
            
            .app-bottom-nav {
                display: flex !important;
            }
        }
        
        /* Seção de Calibração Existente (Integrada) */
        .calibration-section {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            padding: var(--spacing-6);
            margin-bottom: var(--spacing-6);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-4);
            margin-bottom: var(--spacing-6);
            padding-bottom: var(--spacing-4);
            border-bottom: 1px solid var(--border-color);
        }
        
        .section-icon {
            font-size: var(--font-size-4xl);
            background: var(--primary);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .section-title {
            margin: 0 0 var(--spacing-2) 0;
            color: var(--text-primary);
            font-size: var(--font-size-2xl);
        }
        
        .section-description {
            margin: 0;
            color: var(--text-secondary);
            font-size: var(--font-size-base);
        }
        
        .calibration-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-5);
            margin-bottom: var(--spacing-6);
        }
        
        .calibration-card {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: var(--spacing-5);
            border: 1px solid var(--border-color);
        }
        
        .calibration-card.full-width {
            grid-column: 1 / -1;
        }
        
        .card-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-3);
            margin-bottom: var(--spacing-4);
        }
        
        .card-icon {
            font-size: var(--font-size-xl);
        }
        
        .card-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: var(--font-size-lg);
        }
        
        .calibration-image {
            width: 100%;
            max-height: 300px;
            object-fit: contain;
            border-radius: var(--radius-base);
            box-shadow: var(--shadow-md);
        }
        
        .info-grid {
            display: grid;
            gap: var(--spacing-3);
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-2) 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .info-item:last-child {
            border-bottom: none;
        }
        
        .info-label {
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
        }
        
        .info-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .info-value.success {
            color: var(--success);
        }
        
        .status-badge {
            padding: var(--spacing-1) var(--spacing-3);
            border-radius: var(--radius-base);
            font-size: var(--font-size-sm);
            font-weight: 600;
        }
        
        .status-badge.success {
            background: var(--success);
            color: white;
        }
        
        .ai-description {
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
            line-height: 1.6;
            background: var(--bg-primary);
            padding: var(--spacing-4);
            border-radius: var(--radius-base);
            border: 1px solid var(--border-color);
        }
        
        .calibration-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-4);
        }
        
        @media (max-width: 768px) {
            .calibration-grid {
                grid-template-columns: 1fr;
            }
            
            .calibration-actions {
                grid-template-columns: 1fr;
            }
            
            .section-header {
                flex-direction: column;
                text-align: center;
                gap: var(--spacing-3);
            }
        }
    </style>
</head>
<body data-theme="dark" class="layout-with-sidebar">
    <!-- Sidebar (renderizada automaticamente pelo NavigationComponent) -->
    <div class="sidebar" id="sidebar"></div>
        
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <h1 class="header-title" id="pageTitle">🔧 Calibração de IA</h1>
        </div>
        <div class="header-right">
            <div style="display: flex; gap: var(--spacing-2);">
                <button class="btn btn-sm btn-primary" id="startCalibration">
                    <i>🚀</i> Iniciar Calibração
                </button>
                <button class="btn btn-sm btn-secondary" id="resetCalibration">
                    <i>🔄</i> Repor
                </button>
                <button class="btn btn-sm btn-secondary" id="exportConfig">
                    <i>📤</i> Exportar Config
                </button>
            </div>
        </div>
    </header>
        
        <!-- Main Content -->
        <main class="main">
            <div style="flex: 1; overflow-y: auto; padding: var(--spacing-5);" id="mainContent">
                
                <div class="calibration-container">
                    
                    <!-- Step 1: Upload Image -->
                    <div class="step" id="step1">
                        <div class="step-header">
                            <div class="step-number">1</div>
                            <h3 class="step-title">📷 Carregar Imagem de Referência</h3>
                        </div>
                        <div class="step-content">
                            <p class="step-description">
                                Faça upload de uma foto clara de um dorsal para calibração. A imagem deve ter boa iluminação e o dorsal deve estar bem visível.
                            </p>
                            
                            <div class="upload-area" id="uploadArea">
                                <div class="upload-icon">📷</div>
                                <div class="upload-text">Arraste uma imagem aqui ou clique para selecionar</div>
                                <div class="upload-subtext">Formatos suportados: JPG, PNG, WEBP (máx. 10MB)</div>
                                <input type="file" id="imageInput" accept="image/*" style="display: none;">
                            </div>
                            
                            <div id="imagePreview" style="display: none;">
                                <img id="previewImage" class="image-preview" alt="Preview">
                                <div class="calibration-controls">
                                    <button class="btn btn-primary" id="analyzeImage">
                                        <i>🔍</i> Analisar Imagem
                                    </button>
                                    <button class="btn btn-secondary" id="removeImage">
                                        <i>🗑️</i> Remover Imagem
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Step 2: Nomenclatura dos Dorsais (READ-ONLY) -->
                    <div class="step" id="step2" style="display: none;">
                        <div class="step-header">
                            <div class="step-number">2</div>
                            <h3 class="step-title">🔢 Nomenclatura dos Dorsais</h3>
                        </div>
                        <div class="step-content">
                            <!-- Info Box -->
                            <div style="background: linear-gradient(135deg, #10b981, #059669); border-radius: var(--radius-lg); padding: var(--spacing-4); color: white; margin-bottom: var(--spacing-4);">
                                <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                    <span style="font-size: var(--font-size-xl);">✅</span>
                                    <h4 style="margin: 0; font-size: var(--font-size-lg);">Configurado nas Configurações do Evento</h4>
                                </div>
                                <div style="font-size: var(--font-size-sm); line-height: 1.6;">
                                    <p style="margin: 0 0 var(--spacing-2) 0;">
                                        A nomenclatura dos dorsais está configurada centralmente nas <strong>Configurações do Evento</strong>.
                                    </p>
                                    <p style="margin: 0;">
                                        Para alterar, use o botão abaixo.
                                    </p>
                                </div>
                            </div>
                            
                            <!-- Resultado da Análise de IA -->
                            <div id="analysisResultDisplay" style="display: none; background: linear-gradient(135deg, var(--primary), #3b82f6); border-radius: var(--radius-lg); padding: var(--spacing-4); color: white; margin-bottom: var(--spacing-4);">
                                <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                    <span style="font-size: var(--font-size-xl);">🤖</span>
                                    <h4 style="margin: 0; font-size: var(--font-size-lg);">Resultado da Análise de IA</h4>
                                </div>
                                <div style="font-size: var(--font-size-base); line-height: 1.6;">
                                    <p style="margin: 0 0 var(--spacing-2) 0;">
                                        <strong>Número detectado:</strong> <span id="analysisDetectedNumber" style="font-size: var(--font-size-xl); font-weight: 700;">--</span>
                                    </p>
                                    <p style="margin: 0; opacity: 0.9; font-size: var(--font-size-sm);" id="analysisDescription">
                                        A IA analisou a imagem e detectou um número no dorsal.
                                    </p>
                                </div>
                            </div>
                            
                            <!-- Mostrar Config Atual (Read-Only) -->
                            <div id="currentNomenclatureDisplay" style="background: var(--bg-secondary); border: 2px solid var(--border-color); border-radius: var(--radius-lg); padding: var(--spacing-4); margin-bottom: var(--spacing-4);">
                                <h4 style="margin: 0 0 var(--spacing-3) 0;">📋 Configuração Atual:</h4>
                                <div id="nomenclatureReadOnlyContent">
                                    <p style="color: var(--text-secondary);">Carregando...</p>
                                </div>
                            </div>
                            
                            <!-- Botão para Config -->
                            <button onclick="window.open('config-kromi.html?event=' + new URLSearchParams(window.location.search).get('event'), '_blank')" class="btn btn-primary" style="width: 100%;">
                                ⚙️ Ir para Configurações do Evento
                            </button>
                            
                            <!-- Informações Explicativas (mantém só para contexto) -->
                            <div style="background: linear-gradient(135deg, var(--info), #3b82f6); border-radius: var(--radius-lg); padding: var(--spacing-4); color: white; margin-bottom: var(--spacing-4);">
                                <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                    <span style="font-size: var(--font-size-xl);">💡</span>
                                    <h4 style="margin: 0; font-size: var(--font-size-lg);">O que será feito aqui?</h4>
                                </div>
                                <div style="font-size: var(--font-size-sm); line-height: 1.6;">
                                    <p style="margin: 0 0 var(--spacing-2) 0;">
                                        <strong>Análise Automática:</strong> A IA já analisou sua imagem e sugeriu a melhor configuração de nomenclatura baseada no que detectou.
                                    </p>
                                    <p style="margin: 0 0 var(--spacing-2) 0;">
                                        <strong>Otimização:</strong> Esta configuração ajudará a IA a encontrar dorsais mais rapidamente e com maior precisão durante o evento.
                                    </p>
                                    <p style="margin: 0;">
                                        <strong>Personalização:</strong> Você pode ajustar as configurações sugeridas conforme necessário.
                                    </p>
                                </div>
                            </div>
                            
                            <div class="calibration-controls">
                                <button class="btn btn-secondary" onclick="showStep(1)">
                                    <i>←</i> Voltar
                                </button>
                                <button class="btn btn-primary" onclick="showStep(3)">
                                    Continuar <i>→</i>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Step 3: Detection Area (era Step 2) -->
                    <div class="step" id="step3" style="display: none;">
                        <div class="step-header">
                            <div class="step-number">3</div>
                            <h3 class="step-title">🎯 Configurar Área de Detecção</h3>
                        </div>
                        <div class="step-content">
                            <p class="step-description">
                                Ajuste a área onde o sistema deve procurar por dorsais. Arraste os cantos para definir a região de interesse.
                            </p>
                            
                            <!-- Informações Explicativas -->
                            <div style="background: linear-gradient(135deg, var(--warning), #f59e0b); border-radius: var(--radius-lg); padding: var(--spacing-4); color: white; margin-bottom: var(--spacing-4);">
                                <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                    <span style="font-size: var(--font-size-xl);">🎯</span>
                                    <h4 style="margin: 0; font-size: var(--font-size-lg);">O que será feito aqui?</h4>
                                </div>
                                <div style="font-size: var(--font-size-sm); line-height: 1.6;">
                                    <p style="margin: 0 0 var(--spacing-2) 0;">
                                        <strong>Detecção Automática:</strong> A IA já analisou sua imagem e sugeriu a melhor área onde os dorsais aparecem.
                                    </p>
                                    <p style="margin: 0 0 var(--spacing-2) 0;">
                                        <strong>Otimização de Performance:</strong> Uma área bem definida reduz falsos positivos e acelera o processamento.
                                    </p>
                                    <p style="margin: 0;">
                                        <strong>Ajuste Fino:</strong> Você pode mover e redimensionar a área sugerida para cobrir exatamente onde os dorsais aparecem.
                                    </p>
                                </div>
                            </div>
                            
                            <div style="position: relative; display: inline-block;">
                                <img id="detectionImage" class="image-preview" alt="Detection Area">
                                <div class="detection-area" id="detectionArea" 
                                    style="position: absolute; top: 20%; left: 20%; width: 60%; height: 60%; border: 3px solid #fc6b03; background: rgba(252, 107, 3, 0.2); cursor: move; border-radius: var(--radius-base); box-shadow: 0 0 20px rgba(252, 107, 3, 0.5);">
                                    <div style="position: absolute; top: -25px; left: 0; background: #fc6b03; color: white; padding: 4px 12px; border-radius: var(--radius-base); font-size: var(--font-size-sm); font-weight: 600;">
                                        📍 Área do Número
                                    </div>
                                    <!-- Resize handles -->
                                    <div class="resize-handle" style="position: absolute; bottom: -5px; right: -5px; width: 15px; height: 15px; background: #fc6b03; border: 2px solid white; cursor: nwse-resize; border-radius: 50%;"></div>
                                    <div class="resize-handle" style="position: absolute; bottom: 50%; right: -5px; width: 15px; height: 15px; background: #fc6b03; border: 2px solid white; cursor: ew-resize; border-radius: 50%; transform: translateY(50%);"></div>
                                    <div class="resize-handle" style="position: absolute; bottom: -5px; right: 50%; width: 15px; height: 15px; background: #fc6b03; border: 2px solid white; cursor: ns-resize; border-radius: 50%; transform: translateX(50%);"></div>
                                </div>
                            </div>
                            
                            <div style="margin-top: var(--spacing-3); padding: var(--spacing-3); background: var(--bg-primary); border-radius: var(--radius-base);">
                                <div id="areaInfo" style="color: var(--text-secondary); font-size: var(--font-size-sm);">
                                    Arraste para mover • Use os círculos para redimensionar
                                </div>
                            </div>
                            
                            <div class="calibration-controls">
                                <button class="btn btn-primary" id="saveDetectionArea">
                                    <i>💾</i> Guardar Área
                                </button>
                                <button class="btn btn-secondary" id="resetDetectionArea">
                                    <i>🔄</i> Repor Área
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Step 4: AI Configuration (era Step 3) -->
                    <div class="step" id="step4" style="display: none;">
                        <div class="step-header">
                            <div class="step-number">4</div>
                            <h3 class="step-title">🤖 Configuração da IA</h3>
                        </div>
                        <div class="step-content">
                            <p class="step-description">
                                Configure os parâmetros da IA para otimizar a detecção de dorsais. Ajuste conforme necessário para melhorar a precisão.
                            </p>
                            
                            <div style="display: grid; gap: var(--spacing-5); max-width: 800px; margin: 0 auto;">
                                
                                <!-- Limiar de Confiança -->
                                <div style="background: var(--bg-primary); border-radius: var(--radius-lg); padding: var(--spacing-4); border: 1px solid var(--border-color);">
                                    <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                        <label style="font-weight: 600; color: var(--text-primary); font-size: var(--font-size-lg);">🎯 Limiar de Confiança</label>
                                        <div style="background: var(--primary); color: white; padding: 2px 8px; border-radius: var(--radius-base); font-size: var(--font-size-sm); font-weight: 600;">
                                        <span id="confidenceValue">0.7</span>
                                        </div>
                                    </div>
                                    <input type="range" id="confidenceThreshold" min="0.1" max="1" step="0.1" value="0.7" 
                                           style="width: 100%; height: 8px; background: var(--bg-secondary); border-radius: 4px; outline: none; cursor: pointer;">
                                    <div style="display: flex; justify-content: space-between; margin-top: var(--spacing-2); font-size: var(--font-size-sm); color: var(--text-secondary);">
                                        <span>0.1 (Baixa)</span>
                                        <span>0.5 (Média)</span>
                                        <span>1.0 (Alta)</span>
                                    </div>
                                    <div style="margin-top: var(--spacing-2); padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">
                                            <strong>O que faz:</strong> Define o nível mínimo de confiança para aceitar uma detecção. Valores mais altos = menos detecções mas mais precisas. Valores mais baixos = mais detecções mas podem incluir falsos positivos.
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Velocidade de Detecção -->
                                <div style="background: var(--bg-primary); border-radius: var(--radius-lg); padding: var(--spacing-4); border: 1px solid var(--border-color);">
                                    <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                        <label style="font-weight: 600; color: var(--text-primary); font-size: var(--font-size-lg);">⚡ Velocidade de Detecção</label>
                                    </div>
                                    <select id="detectionSpeed" style="width: 100%; padding: var(--spacing-3); background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: var(--radius-base); color: var(--text-primary); font-size: var(--font-size-base);">
                                        <option value="fast">🚀 Rápida (menos precisa)</option>
                                        <option value="balanced" selected>⚖️ Equilibrada</option>
                                        <option value="accurate">🎯 Precisa (mais lenta)</option>
                                    </select>
                                    <div style="margin-top: var(--spacing-2); padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                        <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">
                                            <strong>O que faz:</strong> Controla o equilíbrio entre velocidade e precisão. Rápida = processamento mais rápido mas pode perder detecções. Precisa = análise mais detalhada mas demora mais tempo.
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Configurações Avançadas -->
                                <div style="background: var(--bg-primary); border-radius: var(--radius-lg); padding: var(--spacing-4); border: 1px solid var(--border-color);">
                                    <h4 style="margin-bottom: var(--spacing-4); color: var(--text-primary); font-size: var(--font-size-lg);">⚙️ Configurações Avançadas</h4>
                                    
                                    <div style="display: grid; gap: var(--spacing-4);">
                                        
                                        <!-- Pré-processamento -->
                                        <div style="display: flex; align-items: center; justify-content: space-between; padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: var(--spacing-1);">🔧 Pré-processamento</div>
                                                <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Melhorar qualidade da imagem</div>
                                            </div>
                                    <div class="form-switch">
                                        <div class="switch active" id="preprocessingSwitch">
                                            <div class="switch-thumb"></div>
                                        </div>
                                    </div>
                                </div>
                                
                                        <!-- Pós-processamento -->
                                        <div style="display: flex; align-items: center; justify-content: space-between; padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: var(--spacing-1);">🔍 Pós-processamento</div>
                                                <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Filtrar falsos positivos</div>
                                            </div>
                                    <div class="form-switch">
                                        <div class="switch active" id="postprocessingSwitch">
                                            <div class="switch-thumb"></div>
                                        </div>
                                    </div>
                                </div>
                                
                                        <!-- Máximo de Detecções -->
                                        <div style="padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: var(--spacing-2);">🔢 Máximo de Detecções</div>
                                            <input type="number" id="maxDetections" min="1" max="10" value="3" 
                                                   style="width: 100px; padding: var(--spacing-2); background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: var(--radius-base); color: var(--text-primary);">
                                            <div style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-top: var(--spacing-1);">
                                                <strong>O que faz:</strong> Limita o número máximo de dorsais detectados por imagem. Útil para evitar detecções excessivas em imagens com muitos elementos.
                                            </div>
                                </div>
                                
                                        <!-- Timeout -->
                                        <div style="padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: var(--spacing-2);">⏱️ Timeout (ms)</div>
                                            <input type="number" id="detectionTimeout" min="100" max="5000" step="100" value="1000" 
                                                   style="width: 120px; padding: var(--spacing-2); background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: var(--radius-base); color: var(--text-primary);">
                                            <div style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-top: var(--spacing-1);">
                                                <strong>O que faz:</strong> Tempo máximo para processar uma imagem. Se exceder, a detecção é cancelada. Valores baixos = mais rápido mas pode falhar em imagens complexas.
                                </div>
                            </div>
                            
                                    </div>
                                </div>
                                
                                <!-- Informações Adicionais -->
                                <div style="background: linear-gradient(135deg, var(--primary), var(--secondary)); border-radius: var(--radius-lg); padding: var(--spacing-4); color: white;">
                                    <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-2);">
                                        <span style="font-size: var(--font-size-xl);">💡</span>
                                        <h4 style="margin: 0; font-size: var(--font-size-lg);">Dicas de Configuração</h4>
                                    </div>
                                    <ul style="margin: 0; padding-left: var(--spacing-4); font-size: var(--font-size-sm); line-height: 1.6;">
                                        <li><strong>Para eventos com muitos participantes:</strong> Use velocidade "Rápida" e limite máximo de detecções</li>
                                        <li><strong>Para dorsais pequenos ou distantes:</strong> Aumente o limiar de confiança e use velocidade "Precisa"</li>
                                        <li><strong>Para imagens com baixa qualidade:</strong> Ative o pré-processamento</li>
                                        <li><strong>Para reduzir falsos positivos:</strong> Ative o pós-processamento e aumente o timeout</li>
                                    </ul>
                                </div>
                                
                            </div>
                            
                            <div class="calibration-controls" style="margin-top: var(--spacing-5);">
                                <button class="btn btn-primary" id="saveAIConfig">
                                    <i>💾</i> Guardar Configuração
                                </button>
                                <button class="btn btn-secondary" id="testConfiguration">
                                    <i>🧪</i> Testar Configuração
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Step 5: Calibration Results -->
                    <div class="step" id="step5" style="display: none;">
                        <div class="step-header">
                            <div class="step-number">5</div>
                            <h3 class="step-title">📊 Resultados da Calibração</h3>
                        </div>
                        <div class="step-content">
                            <p class="step-description">
                                A calibração foi concluída com sucesso! Veja os resultados da detecção e a análise da IA.
                            </p>
                            
                            <div style="display: grid; gap: var(--spacing-5); max-width: 900px; margin: 0 auto;">
                                
                                <!-- Resultado Principal -->
                                <div style="background: linear-gradient(135deg, var(--success), #10b981); border-radius: var(--radius-lg); padding: var(--spacing-5); color: white; text-align: center;">
                                    <div style="font-size: var(--font-size-4xl); margin-bottom: var(--spacing-2);">🎯</div>
                                    <h2 style="margin: 0 0 var(--spacing-2) 0; font-size: var(--font-size-2xl);">Calibração Concluída!</h2>
                                    <div style="font-size: var(--font-size-lg); opacity: 0.9;" id="mainResult">
                                        Número detectado: <strong id="detectedNumber">--</strong>
                                </div>
                                </div>
                                
                                <!-- Imagem de Referência -->
                                <div style="background: var(--bg-primary); border-radius: var(--radius-lg); padding: var(--spacing-4); border: 1px solid var(--border-color);">
                                    <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                        <span style="font-size: var(--font-size-xl);">📷</span>
                                        <h3 style="margin: 0; color: var(--text-primary);">Imagem de Referência</h3>
                                    </div>
                                    <div style="text-align: center; background: var(--bg-secondary); border-radius: var(--radius-base); padding: var(--spacing-4);">
                                        <img id="referenceImage" style="max-width: 100%; max-height: 400px; border-radius: var(--radius-base); box-shadow: var(--shadow-lg);" alt="Imagem de referência da calibração">
                                        <div style="margin-top: var(--spacing-2); color: var(--text-secondary); font-size: var(--font-size-sm);">
                                            Imagem utilizada para calibração do sistema
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Análise da IA -->
                                <div style="background: var(--bg-primary); border-radius: var(--radius-lg); padding: var(--spacing-4); border: 1px solid var(--border-color);">
                                    <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                        <span style="font-size: var(--font-size-xl);">🤖</span>
                                        <h3 style="margin: 0; color: var(--text-primary);">Análise da IA</h3>
                                </div>
                                    <div style="background: var(--bg-secondary); border-radius: var(--radius-base); padding: var(--spacing-4);">
                                        <div id="aiDescription" style="color: var(--text-secondary); line-height: 1.6; font-size: var(--font-size-base);">
                                            A IA está analisando a imagem...
                                </div>
                                </div>
                            </div>
                            
                                <!-- Estatísticas de Performance -->
                                <div style="background: var(--bg-primary); border-radius: var(--radius-lg); padding: var(--spacing-4); border: 1px solid var(--border-color);">
                                    <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                        <span style="font-size: var(--font-size-xl);">📈</span>
                                        <h3 style="margin: 0; color: var(--text-primary);">Estatísticas de Performance</h3>
                                    </div>
                                    
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--spacing-3);">
                                        <div style="text-align: center; padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                            <div style="font-size: var(--font-size-2xl); font-weight: 600; color: var(--primary);" id="detectedNumberResult">--</div>
                                            <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Número Detectado</div>
                                        </div>
                                        <div style="text-align: center; padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                            <div style="font-size: var(--font-size-2xl); font-weight: 600; color: var(--primary);" id="confidenceResult">--</div>
                                            <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Confiança</div>
                                        </div>
                                        <div style="text-align: center; padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                            <div style="font-size: var(--font-size-2xl); font-weight: 600; color: var(--success);" id="processingTimeResult">--</div>
                                            <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Tempo (ms)</div>
                                        </div>
                                        <div style="text-align: center; padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                            <div style="font-size: var(--font-size-2xl); font-weight: 600; color: var(--warning);" id="detectionCountResult">--</div>
                                            <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Detecções</div>
                                        </div>
                                        <div style="text-align: center; padding: var(--spacing-3); background: var(--bg-secondary); border-radius: var(--radius-base);">
                                            <div style="font-size: var(--font-size-2xl); font-weight: 600; color: var(--info);" id="accuracyResult">--</div>
                                            <div style="font-size: var(--font-size-sm); color: var(--text-secondary);">Precisão</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Configuração Aplicada -->
                                <div style="background: var(--bg-primary); border-radius: var(--radius-lg); padding: var(--spacing-4); border: 1px solid var(--border-color);">
                                    <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                        <span style="font-size: var(--font-size-xl);">⚙️</span>
                                        <h3 style="margin: 0; color: var(--text-primary);">Configuração Aplicada</h3>
                                    </div>
                                    <div id="appliedConfig" style="background: var(--bg-secondary); border-radius: var(--radius-base); padding: var(--spacing-3); font-family: monospace; font-size: var(--font-size-sm); color: var(--text-secondary);">
                                        Carregando configuração...
                                    </div>
                                </div>
                                
                                <!-- Próximos Passos -->
                                <div style="background: linear-gradient(135deg, var(--info), #3b82f6); border-radius: var(--radius-lg); padding: var(--spacing-4); color: white;">
                                    <div style="display: flex; align-items: center; gap: var(--spacing-2); margin-bottom: var(--spacing-3);">
                                        <span style="font-size: var(--font-size-xl);">🚀</span>
                                        <h3 style="margin: 0; font-size: var(--font-size-lg);">Próximos Passos</h3>
                                    </div>
                                    <ul style="margin: 0; padding-left: var(--spacing-4); font-size: var(--font-size-sm); line-height: 1.6;">
                                        <li>A configuração foi salva e está pronta para uso</li>
                                        <li>O sistema de detecção está ativo para este evento</li>
                                        <li>Pode iniciar a detecção em tempo real</li>
                                        <li>Pode ajustar configurações a qualquer momento</li>
                                    </ul>
                                </div>
                                
                            </div>
                            
                            <div class="calibration-controls" style="margin-top: var(--spacing-5);">
                                <button class="btn btn-success" id="finishCalibration" style="background: var(--success);">
                                    <i>✅</i> Terminar Calibração
                                </button>
                                <button class="btn btn-secondary" id="recalibrate">
                                    <i>🔄</i> Recalibrar
                                </button>
                                <button class="btn btn-primary" id="testAgain">
                                    <i>🧪</i> Testar Novamente
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Progress Indicator -->
                    <div class="progress-container" id="progressContainer" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                        </div>
                        <div class="progress-text" id="progressText">Preparando calibração...</div>
                    </div>
                </div>
                
                <!-- Existing Calibration Modal -->
                <!-- Seção de Calibração Existente (Integrada) - MOVED OUTSIDE calibration-container -->
                <div id="existingCalibrationSection" class="calibration-section" style="display: none;">
                        <div class="section-header">
                            <div class="section-icon">🔧</div>
                            <div class="section-content">
                                <h2 class="section-title">Calibração Existente</h2>
                                <p class="section-description">Já existe uma calibração salva para este evento</p>
                            </div>
                        </div>
                        
                        <div class="calibration-grid">
                            <!-- Imagens de Calibração -->
                            <div class="calibration-card">
                                <div class="card-header">
                                    <div class="card-icon">📷</div>
                                    <div class="card-title">Imagens de Calibração</div>
                                </div>
                                <div class="card-content">
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: var(--spacing-4);">
                                        <!-- Imagem Base (Original) -->
                                        <div style="text-align: center;">
                                            <div style="margin-bottom: var(--spacing-2); font-weight: 600; color: var(--text-primary);">
                                                📷 Imagem Original
                                            </div>
                                            <img id="existingBaseImagePreview" class="calibration-image" alt="Imagem original" style="max-width: 100%; border-radius: var(--radius-base); border: 2px solid var(--border-color);">
                                        </div>
                                        
                                        <!-- Imagem com Retângulo Verde -->
                                        <div style="text-align: center;">
                                            <div style="margin-bottom: var(--spacing-2); font-weight: 600; color: var(--text-primary);">
                                                🎨 Imagem com Área Selecionada
                                            </div>
                                            <img id="existingTemplateImagePreview" class="calibration-image" alt="Imagem com retângulo verde" style="max-width: 100%; border-radius: var(--radius-base); border: 2px solid var(--border-color);">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Informações da Calibração -->
                            <div class="calibration-card">
                                <div class="card-header">
                                    <div class="card-icon">📊</div>
                                    <div class="card-title">Informações da Calibração</div>
                                </div>
                                <div class="card-content">
                                    <div class="info-grid">
                                        <div class="info-item">
                                            <span class="info-label">Número Detectado:</span>
                                            <span class="info-value" id="existingDetectedNumber">--</span>
                                        </div>
                                        <div class="info-item">
                                            <span class="info-label">Confiança:</span>
                                            <span class="info-value success" id="existingConfidence">--</span>
                                        </div>
                                        <div class="info-item">
                                            <span class="info-label">Data da Calibração:</span>
                                            <span class="info-value" id="existingDate">--</span>
                                        </div>
                                        <div class="info-item">
                                            <span class="info-label">Status:</span>
                                            <span class="status-badge success">✅ Ativa</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Descrição da IA -->
                            <div class="calibration-card full-width">
                                <div class="card-header">
                                    <div class="card-icon">🤖</div>
                                    <div class="card-title">Descrição da IA</div>
                                </div>
                                <div class="card-content">
                                    <div class="ai-description" id="existingDescription">Carregando descrição...</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Ações -->
                        <div class="calibration-actions">
                            <button class="btn btn-primary" id="continueWithExisting">
                                <i>✅</i> Continuar com Calibração Atual
                            </button>
                            <button class="btn btn-secondary" id="startNewCalibration">
                                <i>🔄</i> Fazer Nova Calibração
                            </button>
                            <button class="btn btn-outline" id="viewCalibrationDetails">
                                <i>👁️</i> Ver Detalhes da Calibração
                            </button>
                        </div>
                    </div>
                    
                </div>
                
            </div>
        </main>
        
        <!-- Bottom Navigation (Mobile) -->
        <nav class="app-bottom-nav">
            <button class="nav-btn" onclick="window.location.href='/'">
                <i>🏠</i>
                <span>Home</span>
            </button>
            <button class="nav-btn" onclick="window.location.href='/events'">
                <i>🏃</i>
                <span>Eventos</span>
            </button>
            <button class="nav-btn" onclick="window.location.href='/detection'">
                <i>📱</i>
                <span>Detecção</span>
            </button>
            <button class="nav-btn active">
                <i>🔧</i>
                <span>Calibração</span>
            </button>
        </nav>
    </div>
    
    <!-- Scripts -->
    <!-- Scripts de Autenticação -->
    <script src="https://unpkg.com/@supabase/supabase-js@2" defer></script>
    <script src="/supabase.js?v=2025102605" defer></script>
    <script src="/auth-client.js?v=2025102616" defer></script>
    <script src="/auth-helper.js?v=2025102620" defer></script>
    
    <!-- Sistema de Navegação Unificado -->
    <script src="/navigation-config.js?v=2025102601" defer></script>
    <script src="/navigation-service.js?v=2025102601" defer></script>
    <!-- Logo Loader (carregar ANTES da navegação, SEM defer para garantir ordem) -->
    <script src="/logo-loader.js?v=2025012702"></script>
    <script src="/navigation-component.js?v=2025102601" defer></script>
    <script src="/navigation-init.js?v=2025102601" defer></script>
    
    <!-- Proteção de Rotas -->
    <script src="/universal-route-protection.js?v=2025102618" defer></script>
    
    <!-- Calibration Logic -->
    <script>
        // Global variables
        let currentEvent = null;
        let uploadedImage = null;
        let detectionArea = null;
        let aiConfig = {};
        let calibrationResults = {};
        let imageAnalysis = null;
        let currentCalibrationId = null; // ID da calibração atual na BD
        
        // Initialize page
        // Carregar configuração de nomenclatura (read-only)
        async function loadNomenclatureConfigReadOnly(eventId) {
            try {
                const container = document.getElementById('nomenclatureReadOnlyContent');
                if (!container) {
                    console.warn('⚠️ Container nomenclatureReadOnlyContent não encontrado');
                    return;
                }
                
                // Usar API REST (bypassa RLS, mesmo método que loadEventInfo usa)
                console.log('🔍 Carregando evento via API REST:', eventId);
                const res = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!res.ok) {
                    if (res.status === 404) {
                        console.warn('⚠️ Evento não encontrado:', eventId);
                        container.innerHTML = '<p style="color: var(--text-secondary);">⚠️ Evento não encontrado.</p>';
                        return;
                    }
                    throw new Error(`Erro HTTP ${res.status}`);
                }
                
                const apiResponse = await res.json();
                console.log('📥 Resposta completa da API:', apiResponse);
                
                const { success, event, error: apiError } = apiResponse;
                
                if (!success || apiError) {
                    console.error('❌ Erro ao carregar evento:', apiError);
                    container.innerHTML = '<p style="color: var(--danger);">Erro ao carregar configuração</p>';
                    return;
                }
                
                if (!event) {
                    console.warn('⚠️ Evento não encontrado:', eventId);
                    container.innerHTML = '<p style="color: var(--text-secondary);">⚠️ Evento não encontrado.</p>';
                    return;
                }
                
                console.log('📋 Evento completo da API:', event);
                console.log('🔍 event.settings tipo:', typeof event.settings);
                console.log('🔍 event.settings valor:', event.settings);
                
                // Settings pode ser null, undefined, string "null", ou objeto vazio
                let settings = event.settings;
                
                // Se settings é null ou string "null", converter para objeto vazio
                if (!settings || settings === null || settings === 'null' || (typeof settings === 'string' && settings.toLowerCase() === 'null')) {
                    settings = {};
                    console.log('⚠️ Settings era null/undefined, convertido para objeto vazio');
                }
                
                // Se settings é string JSON, fazer parse
                if (typeof settings === 'string') {
                    try {
                        settings = JSON.parse(settings);
                        console.log('✅ Settings parseado de string JSON');
                    } catch (e) {
                        console.warn('⚠️ Erro ao parsear settings:', e);
                        settings = {};
                    }
                }
                
                console.log('🔍 Settings do evento (após processamento):', settings);
                console.log('🔍 Tipo de settings:', typeof settings);
                console.log('🔍 Keys de settings:', Object.keys(settings || {}));
                console.log('🔍 dorsal_nomenclature:', settings?.dorsal_nomenclature);
                
                const nomenclature = settings?.dorsal_nomenclature;
                
                if (!nomenclature || (typeof nomenclature === 'object' && Object.keys(nomenclature).length === 0)) {
                    console.warn('⚠️ Nomenclatura não encontrada em settings. Settings completo:', JSON.stringify(settings, null, 2));
                    container.innerHTML = `
                        <p style="color: var(--text-secondary); margin-bottom: var(--spacing-3);">
                            ⚠️ Configuração de nomenclatura ainda não foi definida.
                        </p>
                        <p style="color: var(--text-secondary); margin-bottom: var(--spacing-3);">
                            Por favor, configure a nomenclatura dos dorsais nas <strong>Configurações do Evento</strong>.
                        </p>
                        <button onclick="window.open('config-kromi.html?event=' + new URLSearchParams(window.location.search).get('event'), '_blank')" 
                                class="btn btn-primary" 
                                style="width: 100%; margin-top: var(--spacing-3);">
                            ⚙️ Ir para Configurações do Evento
                        </button>
                    `;
                    return;
                }
                
                let html = `<div style="font-size: var(--font-size-base); color: var(--text-primary);">`;
                
                html += `<p style="margin-bottom: var(--spacing-3);"><strong>Tipo:</strong> `;
                
                if (nomenclature.type === 'numeric') {
                    html += `🔢 Numérico</p>`;
                    const cfg = nomenclature.numeric || {};
                    const mode = cfg.mode === 'random' ? 'Aleatório (sorteia dentro do range)' : 'Sequencial (1, 2, 3...)';
                    html += `
                        <ul style="margin-left: var(--spacing-4); color: var(--text-secondary);">
                            <li><strong>Modo de Atribuição:</strong> ${mode}</li>
                            <li>Range: ${cfg.min || 1} até ${cfg.max || 9999}</li>
                            <li>Padding: ${cfg.use_padding ? 'Sim (' + (cfg.digits || 3) + ' dígitos)' : 'Não'}</li>
                            <li>Exemplo: ${cfg.use_padding ? String(1).padStart(cfg.digits || 3, '0') : '1'}, ${cfg.use_padding ? String(2).padStart(cfg.digits || 3, '0') : '2'}...</li>
                        </ul>
                    `;
                } else if (nomenclature.type === 'prefix') {
                    html += `📝 Com Prefixo</p>`;
                    const cfg = nomenclature.prefix || {};
                    const mode = cfg.mode === 'random' ? 'Aleatório (sorteia dentro do range)' : 'Sequencial (1, 2, 3...)';
                    html += `
                        <ul style="margin-left: var(--spacing-4); color: var(--text-secondary);">
                            <li><strong>Modo de Atribuição:</strong> ${mode}</li>
                            <li>Prefixos: ${Array.isArray(cfg.prefixes) ? cfg.prefixes.join(', ') : (cfg.prefixes || 'M, F')}</li>
                            <li>Separador: "${cfg.separator || '-'}"</li>
                            <li>Range numérico: ${cfg.min || 1} até ${cfg.max || 999}</li>
                            <li>Exemplo: M${cfg.separator || '-'}1, F${cfg.separator || '-'}1...</li>
                        </ul>
                    `;
                } else if (nomenclature.type === 'suffix') {
                    html += `📝 Com Sufixo</p>`;
                    const cfg = nomenclature.suffix || {};
                    const mode = cfg.mode === 'random' ? 'Aleatório (sorteia dentro do range)' : 'Sequencial (1, 2, 3...)';
                    html += `
                        <ul style="margin-left: var(--spacing-4); color: var(--text-secondary);">
                            <li><strong>Modo de Atribuição:</strong> ${mode}</li>
                            <li>Sufixos: ${Array.isArray(cfg.suffixes) ? cfg.suffixes.join(', ') : (cfg.suffixes || 'M, F')}</li>
                            <li>Separador: "${cfg.separator || '-'}"</li>
                            <li>Range numérico: ${cfg.min || 1} até ${cfg.max || 999}</li>
                            <li>Exemplo: 1${cfg.separator || '-'}M, 1${cfg.separator || '-'}F...</li>
                        </ul>
                    `;
                } else if (nomenclature.type === 'prefix-suffix') {
                    html += `📝 Prefixo + Sufixo</p>`;
                    const cfg = nomenclature['prefix-suffix'] || {};
                    const mode = cfg.mode === 'random' ? 'Aleatório (sorteia dentro do range)' : 'Sequencial (1, 2, 3...)';
                    html += `
                        <ul style="margin-left: var(--spacing-4); color: var(--text-secondary);">
                            <li><strong>Modo de Atribuição:</strong> ${mode}</li>
                            <li>Prefixos: ${Array.isArray(cfg.prefixes) ? cfg.prefixes.join(', ') : (cfg.prefixes || 'M, F')}</li>
                            <li>Sufixos: ${Array.isArray(cfg.suffixes) ? cfg.suffixes.join(', ') : (cfg.suffixes || 'M, F')}</li>
                            <li>Separadores: "${cfg.prefix_separator || '-'}" e "${cfg.suffix_separator || '-'}"</li>
                            <li>Range numérico: ${cfg.min || 1} até ${cfg.max || 999}</li>
                            <li>Exemplo: M${cfg.prefix_separator || '-'}1${cfg.suffix_separator || '-'}M...</li>
                        </ul>
                    `;
                } else if (nomenclature.type === 'markers') {
                    html += `🎨 Marcadores de Cor</p>`;
                    const cfg = nomenclature.markers || {};
                    html += `
                        <ul style="margin-left: var(--spacing-4); color: var(--text-secondary);">
                            <li>Cor Início: <span style="color:${cfg.start_color || '#10b981'};">⬤</span> ${cfg.start_color || '#10b981'}</li>
                            <li>Cor Fim: <span style="color:${cfg.end_color || '#ef4444'};">⬤</span> ${cfg.end_color || '#ef4444'}</li>
                            <li>Tolerância: ${cfg.tolerance || 20}%</li>
                            <li>Exemplo: <span style="color:${cfg.start_color || '#10b981'};">🟢</span> 407 <span style="color:${cfg.end_color || '#ef4444'};">🔴</span></li>
                        </ul>
                    `;
                } else if (nomenclature.type === 'custom') {
                    html += `⚙️ Personalizado (Regex)</p>`;
                    const cfg = nomenclature.custom || {};
                    html += `
                        <ul style="margin-left: var(--spacing-4); color: var(--text-secondary);">
                            <li style="font-family:monospace;">Regex: ${cfg.regex || '(não configurado)'}</li>
                            <li>Exemplos: ${cfg.examples || 'A001, B002'}</li>
                        </ul>
                    `;
                } else {
                    // Tipo desconhecido ou não definido - usar padrão numérico
                    console.warn('⚠️ Tipo de nomenclatura desconhecido:', nomenclature.type, '- usando padrão numérico');
                    html += `🔢 Numérico (Padrão)</p>`;
                    html += `
                        <ul style="margin-left: var(--spacing-4); color: var(--text-secondary);">
                            <li><strong>Modo de Atribuição:</strong> Sequencial (1, 2, 3...)</li>
                            <li>Range: 1 até 9999</li>
                            <li>Padding: Não</li>
                            <li>Exemplo: 1, 2, 3...</li>
                            <li style="color: var(--warning);"><em>Nota: Configuração salva pode ter estrutura diferente</em></li>
                        </ul>
                    `;
                }
                
                html += `</div>`;
                
                container.innerHTML = html;
                
                console.log('✅ Nomenclatura carregada (read-only) na calibração:', nomenclature);
                
            } catch (error) {
                console.error('❌ Erro ao carregar nomenclatura:', error);
                const container = document.getElementById('nomenclatureReadOnlyContent');
                if (container) {
                    container.innerHTML = '<p style="color: var(--danger);">Erro ao carregar configuração</p>';
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // 1) Aguardar sistema de navegação estar pronto
                await waitForNavigation();
                
                // 2) Verificar autenticação
                const autenticado = await verificarAutenticacao(['admin', 'moderator', 'event_manager', 'user']);
                if (!autenticado) return;
                
                // 3) Obter eventId da URL
                const urlParams = new URLSearchParams(window.location.search);
                const eventId = urlParams.get('event');
                
                if (eventId) {
                    loadEventInfo(eventId);
                    // Check for existing calibration
                    checkExistingCalibration(eventId);
                    // Load nomenclature config (read-only)
                    await loadNomenclatureConfigReadOnly(eventId);
                }
                
                // 4) Setup event listeners
                setupEventListeners();
                
                // 5) Load saved configuration
                loadSavedConfiguration();
                
            } catch (error) {
                console.error('[CALIBRATION] Erro na inicialização:', error);
            }
        });
        
        // Aguardar navegação estar pronta
        async function waitForNavigation() {
            return new Promise((resolve) => {
                if (window.NavigationUtils) {
                    resolve();
                } else {
                    window.addEventListener('navigationReady', resolve);
                }
            });
        }
        
        function setupEventListeners() {
            console.log('🔧 Configurando event listeners...');
            
            // Image upload
            const uploadArea = document.getElementById('uploadArea');
            const imageInput = document.getElementById('imageInput');
            
            if (uploadArea) {
                uploadArea.addEventListener('click', () => {
                    if (imageInput) imageInput.click();
                });
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('drop', handleDrop);
            }
            if (imageInput) {
            imageInput.addEventListener('change', handleImageSelect);
            }
            
            // Image actions
            const analyzeImageBtn = document.getElementById('analyzeImage');
            const removeImageBtn = document.getElementById('removeImage');
            
            if (analyzeImageBtn) {
                analyzeImageBtn.addEventListener('click', analyzeImage);
            }
            if (removeImageBtn) {
                removeImageBtn.addEventListener('click', removeImage);
            }
            
            // Nomenclature
            const saveNomenclatureBtn = document.getElementById('saveNomenclature');
            if (saveNomenclatureBtn) {
                saveNomenclatureBtn.addEventListener('click', saveNomenclature);
            }
            
            // Atualizar previews em tempo real
            const inputs = [
                'numericMin', 'numericMax', 'usePadding', 'numericDigits', 
                'prefixText', 'prefixSeparator', 'prefixUseSeparator',
                'suffixText', 'suffixSeparator', 'suffixUseSeparator',
                'prefixSuffixPrefixText', 'prefixSuffixSuffixText', 
                'prefixSuffixPrefixSeparator', 'prefixSuffixSuffixSeparator',
                'prefixSuffixPrefixUseSeparator', 'prefixSuffixSuffixUseSeparator',
                'colorTolerance'
            ];
            inputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', updatePreviews);
            });
            
            // Detection area
            const saveDetectionAreaBtn = document.getElementById('saveDetectionArea');
            const resetDetectionAreaBtn = document.getElementById('resetDetectionArea');
            
            if (saveDetectionAreaBtn) {
                saveDetectionAreaBtn.addEventListener('click', saveDetectionArea);
            }
            if (resetDetectionAreaBtn) {
                resetDetectionAreaBtn.addEventListener('click', resetDetectionArea);
            }
            
            // Setup draggable area
            setupDraggableArea();
            
            // AI Configuration
            const confidenceThresholdSlider = document.getElementById('confidenceThreshold');
            const preprocessingSwitch = document.getElementById('preprocessingSwitch');
            const postprocessingSwitch = document.getElementById('postprocessingSwitch');
            const saveAIConfigBtn = document.getElementById('saveAIConfig');
            
            if (confidenceThresholdSlider) {
                confidenceThresholdSlider.addEventListener('input', updateConfidenceValue);
            }
            if (preprocessingSwitch) {
                preprocessingSwitch.addEventListener('click', toggleSwitch);
            }
            if (postprocessingSwitch) {
                postprocessingSwitch.addEventListener('click', toggleSwitch);
            }
            if (saveAIConfigBtn) {
                saveAIConfigBtn.addEventListener('click', saveAIConfig);
            }
            const testBtn = document.getElementById('testConfiguration');
            if (testBtn) {
                testBtn.addEventListener('click', testConfiguration);
                console.log('✅ Event listener "Testar Configuração" adicionado');
            } else {
                console.error('❌ Botão testConfiguration não encontrado');
            }
            
            // Calibration
            console.log('🔧 Configurando botões de calibração...');
            const startCalibrationBtn = document.getElementById('startCalibration');
            const applyCalibrationBtn = document.getElementById('applyCalibration');
            const recalibrateBtn = document.getElementById('recalibrate');
            const resetCalibrationBtn = document.getElementById('resetCalibration');
            const exportConfigBtn = document.getElementById('exportConfig');
            
            console.log('Botões encontrados:', {
                startCalibration: !!startCalibrationBtn,
                applyCalibration: !!applyCalibrationBtn,
                recalibrate: !!recalibrateBtn,
                resetCalibration: !!resetCalibrationBtn,
                exportConfig: !!exportConfigBtn
            });
            
            if (startCalibrationBtn) {
                startCalibrationBtn.addEventListener('click', startCalibration);
            }
            if (applyCalibrationBtn) {
                applyCalibrationBtn.addEventListener('click', applyCalibration);
            }
            if (recalibrateBtn) {
                recalibrateBtn.addEventListener('click', recalibrate);
            }
            if (resetCalibrationBtn) {
                resetCalibrationBtn.addEventListener('click', resetCalibration);
            }
            if (exportConfigBtn) {
                exportConfigBtn.addEventListener('click', exportConfig);
            }
            
            // Step 5 buttons
            const finishCalibrationBtn = document.getElementById('finishCalibration');
            const testAgainBtn = document.getElementById('testAgain');
            
            if (finishCalibrationBtn) {
                finishCalibrationBtn.addEventListener('click', finishCalibration);
            }
            if (testAgainBtn) {
                testAgainBtn.addEventListener('click', testAgain);
            }
            
            // Existing calibration modal buttons
            const continueWithExistingBtn = document.getElementById('continueWithExisting');
            const startNewCalibrationBtn = document.getElementById('startNewCalibration');
            const viewCalibrationDetailsBtn = document.getElementById('viewCalibrationDetails');
            
            if (continueWithExistingBtn) {
                continueWithExistingBtn.addEventListener('click', continueWithExistingCalibration);
            }
            if (startNewCalibrationBtn) {
                startNewCalibrationBtn.addEventListener('click', startNewCalibration);
            }
            if (viewCalibrationDetailsBtn) {
                viewCalibrationDetailsBtn.addEventListener('click', viewCalibrationDetails);
            }
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleImageFile(files[0]);
            }
        }
        
        function handleImageSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleImageFile(file);
            }
        }
        
        function handleImageFile(file) {
            if (!file.type.startsWith('image/')) {
                showError('Por favor, selecione um arquivo de imagem válido');
                return;
            }
            
            if (file.size > 10 * 1024 * 1024) { // 10MB
                showError('A imagem deve ter no máximo 10MB');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                uploadedImage = e.target.result;
                showImagePreview(uploadedImage);
            };
            reader.readAsDataURL(file);
        }
        
        function showImagePreview(imageSrc) {
            const preview = document.getElementById('imagePreview');
            const previewImage = document.getElementById('previewImage');
            
            previewImage.src = imageSrc;
            preview.style.display = 'block';
            
            // Hide upload area
            document.getElementById('uploadArea').style.display = 'none';
        }
        
        function removeImage() {
            uploadedImage = null;
            
            // Hide preview
            document.getElementById('imagePreview').style.display = 'none';
            
            // Show upload area
            document.getElementById('uploadArea').style.display = 'block';
            
            // Reset steps
            resetSteps();
        }
        
        async function analyzeImage() {
            if (!uploadedImage) {
                showError('Por favor, carregue uma imagem primeiro');
                return;
            }
            
            showProgress('Analisando imagem com IA...', 25);
            
            try {
                // Análise real com IA
                const analysisResult = await performRealImageAnalysis(uploadedImage);
                
                // Salvar resultados da análise
                imageAnalysis = analysisResult;
                
                showProgress('Configurando nomenclatura...', 50);
                
                // Preselecionar nomenclatura baseada na análise
                preselectNomenclature(analysisResult);
                
                showProgress('Detectando número na imagem...', 60);
                
                // Tentar detectar número na imagem usando IA (Gemini)
                let detectedNumberFromAnalysis = null;
                try {
                    // Criar uma área padrão para detecção inicial (toda a imagem)
                    const fullImageArea = {
                        x: 0,
                        y: 0,
                        width: 1,
                        height: 1
                    };
                    
                    // Processar imagem para detectar número
                    const detectedNumberRaw = await processImageWithAI(
                        uploadedImage,
                        fullImageArea,
                        { confidenceThreshold: 0.5, detectionSpeed: 'fast', enablePreprocessing: true, enablePostprocessing: false, maxDetections: 1, detectionTimeout: 5000 }
                    );
                    
                    // processImageWithAI retorna apenas o número, não um objeto
                    if (detectedNumberRaw !== null && detectedNumberRaw !== undefined) {
                        detectedNumberFromAnalysis = String(detectedNumberRaw);
                        console.log('✅ Número detectado na análise inicial:', detectedNumberFromAnalysis);
                        
                        // Mostrar resultado no passo 2
                        const analysisResultDisplay = document.getElementById('analysisResultDisplay');
                        const analysisDetectedNumber = document.getElementById('analysisDetectedNumber');
                        const analysisDescription = document.getElementById('analysisDescription');
                        
                        if (analysisResultDisplay && analysisDetectedNumber) {
                            analysisDetectedNumber.textContent = detectedNumberFromAnalysis;
                            if (analysisDescription) {
                                analysisDescription.textContent = `A IA analisou a imagem e detectou o número "${detectedNumberFromAnalysis}" no dorsal. Este número será usado como referência para a calibração.`;
                            }
                            analysisResultDisplay.style.display = 'block';
                        }
                    }
                } catch (error) {
                    console.warn('⚠️ Não foi possível detectar número na análise inicial:', error);
                    // Não é crítico, continuar normalmente
                }
                
                showProgress('Definindo área de detecção...', 75);
                
                // Predelimitar área de detecção
                predelineateDetectionArea(analysisResult);
                
                hideProgress();
                
                // Inicializar calibração na BD com a imagem
                await initializeCalibrationInDB();
                
                // Avançar para passo 2 (nomenclatura) para mostrar o resultado da análise
                showStep(2);
                
                // Set detection image
                document.getElementById('detectionImage').src = uploadedImage;
                
                // Aplicar área sugerida pela IA se disponível
                if (analysisResult.detectionArea) {
                    const area = analysisResult.detectionArea;
                    const detectionAreaEl = document.getElementById('detectionArea');
                    if (detectionAreaEl) {
                        detectionAreaEl.style.left = (area.x * 100) + '%';
                        detectionAreaEl.style.top = (area.y * 100) + '%';
                        detectionAreaEl.style.width = (area.width * 100) + '%';
                        detectionAreaEl.style.height = (area.height * 100) + '%';
                        updateAreaInfo();
                    }
                }
                
                showSuccess('Análise concluída! Configurações sugeridas pela IA aplicadas.');
                
            } catch (error) {
                console.error('❌ Erro na análise da imagem:', error);
                hideProgress();
                showError('Erro na análise da imagem. Continuando com configurações padrão.');
                
                // Fallback para configurações padrão
                // Inicializar calibração na BD mesmo em caso de erro
                await initializeCalibrationInDB();
                
                showStep(3);
                document.getElementById('detectionImage').src = uploadedImage;
            }
        }
        
        // Inicializar calibração na BD
        async function initializeCalibrationInDB() {
            if (!currentEvent || !window.supabaseClient || !uploadedImage) {
                console.warn('⚠️ Não é possível inicializar calibração: evento, supabase ou imagem não disponível');
                return;
            }
            
            try {
                console.log('💾 Inicializando calibração na BD...');
                
                // Se já existe uma calibração, usar ela; caso contrário, criar nova
                if (!currentCalibrationId) {
                    // Criar nova calibração
                    const { data: calibrationId, error } = await window.supabaseClient.supabase
                        .rpc('create_calibration', {
                            p_event_id: currentEvent.id,
                            p_device_id: null,
                            p_image_data: uploadedImage,
                            p_image_width: null,
                            p_image_height: null,
                            p_detection_area_x: 0.2,
                            p_detection_area_y: 0.2,
                            p_detection_area_width: 0.6,
                            p_detection_area_height: 0.6,
                            p_nomenclature_type: 'numeric',
                            p_nomenclature_config: {},
                            p_ai_config: {}
                        });
                    
                    if (error) {
                        console.error('❌ Erro ao criar calibração:', error);
                        throw error;
                    }
                    
                    currentCalibrationId = calibrationId;
                    console.log('✅ Calibração criada com ID:', currentCalibrationId);
                }
            } catch (error) {
                console.error('❌ Erro ao inicializar calibração:', error);
                throw error;
            }
        }
        
        // Atualizar calibração na BD
        async function updateCalibrationInDB(updates) {
            if (!currentCalibrationId || !window.supabaseClient) {
                console.warn('⚠️ Não é possível atualizar calibração: calibration_id não disponível');
                return;
            }
            
            try {
                console.log('🔄 Atualizando calibração:', updates);
                
                const { error } = await window.supabaseClient.supabase
                    .from('event_calibrations')
                    .update({
                        ...updates,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', currentCalibrationId);
                
                if (error) {
                    console.error('❌ Erro ao atualizar calibração:', error);
                    throw error;
                }
                
                console.log('✅ Calibração atualizada');
            } catch (error) {
                console.error('❌ Erro ao atualizar calibração:', error);
                throw error;
            }
        }
        
        // Gerar imagem com retângulo verde sobre a área selecionada
        async function generateTemplateImageWithGreenRectangle(imageSrc, regionX, regionY, regionWidth, regionHeight) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    
                    // Desenhar imagem original
                    ctx.drawImage(img, 0, 0);
                    
                    // Desenhar retângulo verde sobre a área selecionada
                    const rectX = regionX * img.width;
                    const rectY = regionY * img.height;
                    const rectWidth = regionWidth * img.width;
                    const rectHeight = regionHeight * img.height;
                    
                    // Retângulo verde semi-transparente
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
                    
                    // Borda verde sólida
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
                    
                    // Converter para Base64
                    const base64 = canvas.toDataURL('image/png');
                    resolve(base64);
                };
                
                img.onerror = () => {
                    reject(new Error('Erro ao carregar imagem'));
                };
                
                img.src = imageSrc;
            });
        }
        
        // Carregar expected_digits da nomenclatura do evento
        async function getExpectedDigitsFromNomenclature(eventId) {
            try {
                const response = await fetch(`/api/events/${eventId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) return 4; // Default
                
                const data = await response.json();
                if (!data.success || !data.event?.settings?.dorsal_nomenclature) {
                    return 4; // Default
                }
                
                const nomenclature = data.event.settings.dorsal_nomenclature;
                
                // Calcular expected_digits baseado no tipo de nomenclatura
                if (nomenclature.type === 'numeric' && nomenclature.numeric) {
                    const numeric = nomenclature.numeric;
                    if (numeric.use_padding && numeric.digits) {
                        return numeric.digits;
                    }
                    // Calcular dígitos baseado no máximo
                    if (numeric.max) {
                        return String(numeric.max).length;
                    }
                    return numeric.digits || 4;
                }
                
                // Para outros tipos, usar padrão
                return 4;
            } catch (error) {
                console.warn('⚠️ Erro ao calcular expected_digits, usando padrão:', error);
                return 4;
            }
        }
        
        async function saveDetectionArea() {
            const area = document.getElementById('detectionArea');
            const rect = area.getBoundingClientRect();
            const imgRect = document.getElementById('detectionImage').getBoundingClientRect();
            
            if (!uploadedImage) {
                showError('Imagem não disponível');
                return;
            }
            
            // Calcular coordenadas normalizadas
            const numberRegion = {
                x: (rect.left - imgRect.left) / imgRect.width,
                y: (rect.top - imgRect.top) / imgRect.height,
                width: rect.width / imgRect.width,
                height: rect.height / imgRect.height
            };
            
            // Por enquanto, bib_region = number_region (depois pode ser ajustado)
            const bibRegion = { ...numberRegion };
            
            detectionArea = numberRegion;
            
            try {
                // Verificar se uploadedImage está disponível
                if (!uploadedImage) {
                    console.error('❌ uploadedImage não está disponível!');
                    showError('Imagem não disponível para guardar. Por favor, faça upload novamente.');
                    return;
                }
                
                // Guardar imagem base (original, sem marcações)
                console.log('💾 Guardando imagem base (original)...');
                console.log('📷 uploadedImage disponível:', !!uploadedImage, 'Tamanho:', uploadedImage.length);
                
                // Gerar imagem com retângulo verde
                console.log('🎨 Gerando imagem com retângulo verde...');
                const templateImageBase64 = await generateTemplateImageWithGreenRectangle(
                    uploadedImage,
                    numberRegion.x,
                    numberRegion.y,
                    numberRegion.width,
                    numberRegion.height
                );
                
                if (!templateImageBase64) {
                    console.error('❌ Erro ao gerar imagem com retângulo verde!');
                    showError('Erro ao gerar imagem com retângulo verde.');
                    return;
                }
                
                // Obter expected_digits da nomenclatura
                const expectedDigits = await getExpectedDigitsFromNomenclature(currentEvent.id);
                
                // Obter confidence_threshold da configuração AI (se já foi configurado)
                const confidenceThreshold = aiConfig?.confidenceThreshold || 0.75;
                
                console.log('💾 Guardando ambas as imagens na tabela bib_templates...');
                console.log('📷 Imagem base (original):', uploadedImage.substring(0, 50) + '...', 'Tamanho total:', uploadedImage.length);
                console.log('🎨 Imagem com retângulo verde:', templateImageBase64.substring(0, 50) + '...', 'Tamanho total:', templateImageBase64.length);
                
                // Preparar dados para guardar (garantir que base_image_base64 não é NULL)
                const templateData = {
                    event_id: currentEvent.id,
                    base_image_base64: uploadedImage,  // Imagem original sem marcações - SEMPRE definido
                    template_image_base64: templateImageBase64,  // Imagem com retângulo verde
                    template_image_url: null,
                    bib_region_x: bibRegion.x,
                    bib_region_y: bibRegion.y,
                    bib_region_width: bibRegion.width,
                    bib_region_height: bibRegion.height,
                    number_region_x: numberRegion.x,
                    number_region_y: numberRegion.y,
                    number_region_width: numberRegion.width,
                    number_region_height: numberRegion.height,
                    expected_digits: expectedDigits,
                    confidence_threshold: confidenceThreshold
                };
                
                console.log('📋 Dados a guardar:', {
                    event_id: templateData.event_id,
                    hasBaseImage: !!templateData.base_image_base64,
                    baseImageType: typeof templateData.base_image_base64,
                    baseImageLength: templateData.base_image_base64?.length || 0,
                    hasTemplateImage: !!templateData.template_image_base64,
                    templateImageLength: templateData.template_image_base64?.length || 0
                });
                
                // Verificar se já existe um template para este evento
                const { data: existingTemplate, error: checkError } = await window.supabaseClient.supabase
                    .from('bib_templates')
                    .select('id, base_image_base64')
                    .eq('event_id', currentEvent.id)
                    .maybeSingle(); // Usar maybeSingle para não dar erro se não existir
                
                let result;
                if (existingTemplate && !checkError) {
                    // UPDATE - atualizar registo existente
                    // IMPORTANTE: Usar UPDATE explícito com todos os campos para forçar atualização de NULL
                    console.log('🔄 Atualizando template existente:', existingTemplate.id);
                    console.log('🔍 base_image_base64 atual no BD:', existingTemplate.base_image_base64 ? 'Existe' : 'NULL');
                    
                    // Garantir que todos os campos são atualizados, incluindo NULLs
                    result = await window.supabaseClient.supabase
                        .from('bib_templates')
                        .update({
                            base_image_base64: templateData.base_image_base64,  // Forçar atualização mesmo se NULL
                            template_image_base64: templateData.template_image_base64,
                            template_image_url: templateData.template_image_url,
                            bib_region_x: templateData.bib_region_x,
                            bib_region_y: templateData.bib_region_y,
                            bib_region_width: templateData.bib_region_width,
                            bib_region_height: templateData.bib_region_height,
                            number_region_x: templateData.number_region_x,
                            number_region_y: templateData.number_region_y,
                            number_region_width: templateData.number_region_width,
                            number_region_height: templateData.number_region_height,
                            expected_digits: templateData.expected_digits,
                            confidence_threshold: templateData.confidence_threshold,
                            updated_at: new Date().toISOString()
                        })
                        .eq('event_id', currentEvent.id)
                        .select()
                        .single();
                } else {
                    // INSERT - criar novo registo
                    console.log('➕ Criando novo template');
                    result = await window.supabaseClient.supabase
                        .from('bib_templates')
                        .insert(templateData)
                        .select()
                        .single();
                }
                
                const { data, error } = result;
                
                if (data) {
                    console.log('✅ Template guardado/atualizado:', {
                        id: data.id,
                        hasBaseImage: !!data.base_image_base64,
                        baseImageLength: data.base_image_base64?.length || 0,
                        hasTemplateImage: !!data.template_image_base64,
                        templateImageLength: data.template_image_base64?.length || 0
                    });
                }
                
                if (error) {
                    console.error('❌ Erro ao guardar bib_template:', error);
                    throw error;
                }
                
                console.log('✅ Template guardado na tabela bib_templates:', data);
                
                // Também atualizar event_calibrations (para compatibilidade)
                if (currentCalibrationId) {
                    await updateCalibrationInDB({
                        detection_area_x: numberRegion.x,
                        detection_area_y: numberRegion.y,
                        detection_area_width: numberRegion.width,
                        detection_area_height: numberRegion.height
                    });
                }
                
                // Aplicar valores padrão de AI Config se ainda não foram configurados
                if (!aiConfig || Object.keys(aiConfig).length === 0) {
                    aiConfig = {
                        confidenceThreshold: 0.75,
                        detectionSpeed: 'balanced',
                        enablePreprocessing: true,
                        enablePostprocessing: true,
                        maxDetections: 3,
                        detectionTimeout: 1000
                    };
                    console.log('✅ Valores padrão de AI Config aplicados:', aiConfig);
                }
                
                showStep(4); // Ir para config IA
                showSuccess('Área de detecção guardada com template de imagem');
                
            } catch (error) {
                console.error('❌ Erro ao guardar área de detecção:', error);
                showError('Erro ao guardar área de detecção. Tente novamente.');
            }
        }
        
        function setupDraggableArea() {
            const area = document.getElementById('detectionArea');
            if (!area) return;
            
            // Prevenir drag nativo
            area.addEventListener('dragstart', e => e.preventDefault());
            
            let isDragging = false;
            let startX, startY, startLeft, startTop, startWidth, startHeight;
            
            let isResizing = false;
            let resizeMode = null;
            
            area.addEventListener('mousedown', (e) => {
                // Verificar se clicou em handle
                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true;
                    const handles = area.querySelectorAll('.resize-handle');
                    if (e.target === handles[0]) resizeMode = 'br';
                    if (e.target === handles[1]) resizeMode = 'r';
                    if (e.target === handles[2]) resizeMode = 'b';
                } else {
                    isDragging = true;
                }
                
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = area.getBoundingClientRect();
                const parentRect = area.parentElement.getBoundingClientRect();
                
                startLeft = ((rect.left - parentRect.left) / parentRect.width) * 100;
                startTop = ((rect.top - parentRect.top) / parentRect.height) * 100;
                startWidth = (rect.width / parentRect.width) * 100;
                startHeight = (rect.height / parentRect.height) * 100;
                
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging && !isResizing) return;
                
                const parentRect = area.parentElement.getBoundingClientRect();
                const deltaX = ((e.clientX - startX) / parentRect.width) * 100;
                const deltaY = ((e.clientY - startY) / parentRect.height) * 100;
                
                if (isDragging) {
                    // Mover
                    let newLeft = startLeft + deltaX;
                    let newTop = startTop + deltaY;
                    
                    const width = parseFloat(area.style.width);
                    const height = parseFloat(area.style.height);
                    newLeft = Math.max(0, Math.min(newLeft, 100 - width));
                    newTop = Math.max(0, Math.min(newTop, 100 - height));
                    
                    area.style.left = newLeft + '%';
                    area.style.top = newTop + '%';
                } else if (isResizing) {
                    // Redimensionar
                    if (resizeMode === 'br' || resizeMode === 'r') {
                        let newWidth = startWidth + deltaX;
                        newWidth = Math.max(10, Math.min(newWidth, 100 - startLeft));
                        area.style.width = newWidth + '%';
                    }
                    
                    if (resizeMode === 'br' || resizeMode === 'b') {
                        let newHeight = startHeight + deltaY;
                        newHeight = Math.max(10, Math.min(newHeight, 100 - startTop));
                        area.style.height = newHeight + '%';
                    }
                }
                
                updateAreaInfo();
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                isResizing = false;
                resizeMode = null;
            });
        }
        
        function updateAreaInfo() {
            const area = document.getElementById('detectionArea');
            const info = document.getElementById('areaInfo');
            if (!area || !info) return;
            
            const left = parseFloat(area.style.left);
            const top = parseFloat(area.style.top);
            const width = parseFloat(area.style.width);
            const height = parseFloat(area.style.height);
            
            info.innerHTML = `Posição: ${left.toFixed(1)}%, ${top.toFixed(1)}% • Tamanho: ${width.toFixed(1)}% × ${height.toFixed(1)}%`;
        }
        
        function resetDetectionArea() {
            const area = document.getElementById('detectionArea');
            area.style.top = '20%';
            area.style.left = '20%';
            area.style.width = '60%';
            area.style.height = '60%';
            updateAreaInfo();
            showSuccess('Área de detecção reposta');
        }
        
        function updateConfidenceValue() {
            const slider = document.getElementById('confidenceThreshold');
            const value = document.getElementById('confidenceValue');
            value.textContent = slider.value;
        }
        
        function toggleSwitch(e) {
            e.currentTarget.classList.toggle('active');
        }
        
        async function saveAIConfig() {
            console.log('💾 Guardando configuração IA...');
            
            aiConfig = {
                confidenceThreshold: parseFloat(document.getElementById('confidenceThreshold').value),
                detectionSpeed: document.getElementById('detectionSpeed').value,
                enablePreprocessing: document.getElementById('preprocessingSwitch').classList.contains('active'),
                enablePostprocessing: document.getElementById('postprocessingSwitch').classList.contains('active'),
                maxDetections: parseInt(document.getElementById('maxDetections').value),
                detectionTimeout: parseInt(document.getElementById('detectionTimeout').value)
            };
            
            console.log('✅ AI Config criado:', aiConfig);
            
            // Guardar diretamente na BD (event_calibrations)
            if (currentCalibrationId) {
                await updateCalibrationInDB({
                    ai_config: aiConfig
                });
            } else {
                // Se não existe calibração, criar agora
                await initializeCalibrationInDB();
                await updateCalibrationInDB({
                    ai_config: aiConfig
                });
            }
            
            // Atualizar também confidence_threshold na tabela bib_templates se existir
            if (currentEvent && window.supabaseClient) {
                try {
                    const { error: bibError } = await window.supabaseClient.supabase
                        .from('bib_templates')
                        .update({
                            confidence_threshold: aiConfig.confidenceThreshold,
                            updated_at: new Date().toISOString()
                        })
                        .eq('event_id', currentEvent.id);
                    
                    if (bibError) {
                        console.warn('⚠️ Erro ao atualizar confidence_threshold em bib_templates:', bibError);
                        // Não bloquear se falhar, pode não existir ainda
                    } else {
                        console.log('✅ confidence_threshold atualizado em bib_templates');
                    }
                } catch (error) {
                    console.warn('⚠️ Erro ao atualizar bib_templates:', error);
                }
            }
            
            showSuccess('Configuração da IA guardada! Pode agora testar.');
            // Não avança automaticamente - usuário escolhe quando testar
        }
        
        function testConfiguration() {
            console.log('🧪 Testando configuração...');
            console.log('  Imagem:', uploadedImage ? 'SIM' : 'NÃO');
            console.log('  Área:', detectionArea);
            console.log('  AI Config:', aiConfig);
            
            if (!uploadedImage) {
                showError('Faça upload de uma imagem primeiro (Passo 1)');
                return;
            }
            
            if (!detectionArea || !detectionArea.x) {
                showError('Defina a área de detecção primeiro (Passo 3)');
                return;
            }
            
            if (!aiConfig || Object.keys(aiConfig).length === 0 || !aiConfig.confidenceThreshold) {
                console.error('❌ AI Config vazio ou incompleto');
                showError('Configure a IA primeiro (Passo 4)!\n\nClique em "💾 Guardar Configuração" no Passo 4 antes de testar.');
                // Voltar para passo 4
                showStep(4);
                return;
            }
            
            console.log('✅ Validações OK, iniciando teste...');
            
            // Mostrar progresso
            showProgress('Testando configuração com IA...', 0);
            
            // Simular processamento da IA
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 20;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                hideProgress();
                
                    // Processar imagem real com IA (simulação realista baseada na configuração)
                    processImageWithAI(uploadedImage, detectionArea, aiConfig).then(detectedNumber => {
                        const confidence = calculateConfidence(detectedNumber, aiConfig);
                        const processingTime = calculateProcessingTime(aiConfig);
                        const detectionCount = 1; // Uma detecção por vez
                        const accuracy = confidence; // Usar confiança como precisão
                        
                        // Salvar resultados reais
                        calibrationResults = {
                            detectedNumber: detectedNumber,
                            confidence: confidence,
                            processingTime: processingTime,
                            detectionCount: detectionCount,
                            accuracy: accuracy,
                            aiDescription: generateRealAIDescription(detectedNumber, confidence, processingTime, aiConfig)
                        };
                        
                        // Atualizar UI com resultados
                        updateCalibrationResults();
                        
                        // Mostrar passo 5
                        showStep(5);
                        
                        console.log('✅ Teste concluído!');
                    });
                }
                updateProgress(progress, 'Processando imagem...');
            }, 300);
        }
        
        async function processImageWithAI(imageData, detectionArea, aiConfig) {
            console.log('🤖 Processando imagem com IA...');
            
            try {
                // Obter configuração do processador para o evento
                const urlParams = new URLSearchParams(window.location.search);
                const eventId = urlParams.get('event');
                
                let processorConfig = null;
                if (eventId) {
                    try {
                        const response = await fetch(`/api/processor-config/${eventId}`);
                        const data = await response.json();
                        if (data.success && data.config) {
                            processorConfig = data.config;
                            console.log('📋 Configuração do processador obtida:', processorConfig);
                        }
                    } catch (error) {
                        console.error('Erro ao obter configuração do processador:', error);
                    }
                }
                
                // ⚠️ AVISO DE SEGURANÇA: API keys expostas no frontend
                // TODO: Mover chamadas de IA para backend (Edge Function)
                // O cliente não deve ter acesso direto às API keys
                const configResponse = await fetch('/api/config');
                const config = await configResponse.json();
                const geminiApiKey = config.GEMINI_API_KEY;
                const googleVisionApiKey = config.GOOGLE_VISION_API_KEY;
                
                // Extrair área de detecção da imagem
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                return new Promise((resolve, reject) => {
                    img.onload = async () => {
                        // Aplicar área de detecção
                        const x = detectionArea.x * img.width;
                        const y = detectionArea.y * img.height;
                        const width = detectionArea.width * img.width;
                        const height = detectionArea.height * img.height;
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        // Desenhar área de detecção
                        ctx.drawImage(img, x, y, width, height, 0, 0, width, height);
                        
                        // Converter canvas para base64
                        const croppedImageData = canvas.toDataURL('image/jpeg');
                        
                        // Determinar qual processador usar
                        const processorType = processorConfig?.processorType || 'gemini';
                        console.log(`🎯 Usando processador: ${processorType}`);
                        
                        let detectedNumber;
                        
                        // Chamar API apropriada
                        if (processorType === 'gemini' && geminiApiKey) {
                            try {
                                detectedNumber = await analyzeWithGemini(croppedImageData, geminiApiKey);
                            } catch (error) {
                                console.error('Erro ao chamar Gemini, usando simulação:', error);
                                detectedNumber = simulateRealDetection(canvas, aiConfig);
                            }
                        } else if (processorType === 'google-vision' && googleVisionApiKey) {
                            try {
                                detectedNumber = await analyzeWithGoogleVision(croppedImageData, googleVisionApiKey);
                            } catch (error) {
                                console.error('Erro ao chamar Google Vision, usando simulação:', error);
                                detectedNumber = simulateRealDetection(canvas, aiConfig);
                            }
                        } else {
                            console.log('⚠️ Usando simulação (sem API keys ou processador desconhecido)');
                            detectedNumber = simulateRealDetection(canvas, aiConfig);
                        }
                        
                        resolve(detectedNumber);
                    };
                    img.onerror = () => reject(new Error('Erro ao carregar imagem'));
                    img.src = imageData;
                });
            } catch (error) {
                console.error('Erro ao processar imagem:', error);
                // Fallback para simulação
                const canvas = document.createElement('canvas');
                return simulateRealDetection(canvas, aiConfig);
            }
        }
        
        async function analyzeWithGemini(imageData, apiKey) {
            console.log('🤖 Analisando com Gemini...');
            
            try {
                // Converter base64 para formato apropriado
                const base64Image = imageData.split(',')[1];
                
                // Usar o modelo mais recente (gemini-2.5-flash que suporta visão)
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [
                                {
                                    inline_data: {
                                        mime_type: 'image/jpeg',
                                        data: base64Image
                                    }
                                },
                                {
                                    text: 'What number is written in this image? Only respond with the number and nothing else.'
                                }
                            ]
                        }]
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Erro HTTP do Gemini:', response.status, errorText);
                    throw new Error(`Gemini API Error: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                console.log('📊 Resposta completa do Gemini:', data);
                
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    const text = data.candidates[0].content.parts[0].text;
                    const number = parseInt(text.trim());
                    console.log('✅ Gemini detectou:', number);
                    return number;
                }
                throw new Error('Resposta inválida do Gemini');
            } catch (error) {
                console.error('Erro ao analisar com Gemini:', error);
                throw error;
            }
        }
        
        async function analyzeWithGoogleVision(imageData, apiKey) {
            console.log('📷 Analisando com Google Vision...');
            
            try {
                // Converter base64 para formato apropriado
                const base64Image = imageData.split(',')[1];
                
                const response = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        requests: [{
                            image: {
                                content: base64Image
                            },
                            features: [{
                                type: 'TEXT_DETECTION'
                            }]
                        }]
                    })
                });
                
                const data = await response.json();
                if (data.responses && data.responses[0] && data.responses[0].textAnnotations) {
                    const text = data.responses[0].textAnnotations[0].description;
                    const number = parseInt(text.trim());
                    console.log('✅ Google Vision detectou:', number);
                    return number;
                }
                throw new Error('Resposta inválida do Google Vision');
            } catch (error) {
                console.error('Erro ao analisar com Google Vision:', error);
                throw error;
            }
        }
        
        function simulateRealDetection(canvas, aiConfig) {
            // Simular detecção real baseada na configuração
            const confidence = aiConfig.confidenceThreshold || 0.7;
            const speed = aiConfig.detectionSpeed || 'balanced';
            
            // Gerar número baseado na configuração de nomenclatura
            let detectedNumber;
            
            if (aiConfig.nomenclatureType === 'numeric') {
                const min = aiConfig.min || 1;
                const max = aiConfig.max || 999;
                detectedNumber = Math.floor(Math.random() * (max - min + 1)) + min;
            } else if (aiConfig.nomenclatureType === 'prefix') {
                const prefixes = aiConfig.prefixes || ['M', 'F'];
                const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
                const number = Math.floor(Math.random() * 999) + 1;
                const separator = aiConfig.useSeparator ? (aiConfig.separator || '-') : '';
                detectedNumber = `${prefix}${separator}${number}`;
            } else if (aiConfig.nomenclatureType === 'suffix') {
                const suffixes = aiConfig.suffixes || ['M', 'F'];
                const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
                const number = Math.floor(Math.random() * 999) + 1;
                const separator = aiConfig.useSeparator ? (aiConfig.separator || '-') : '';
                detectedNumber = `${number}${separator}${suffix}`;
            } else if (aiConfig.nomenclatureType === 'prefix-suffix') {
                const prefixes = aiConfig.prefixes || ['M', 'F'];
                const suffixes = aiConfig.suffixes || ['M', 'F'];
                const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
                const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
                const number = Math.floor(Math.random() * 999) + 1;
                const prefixSeparator = aiConfig.usePrefixSeparator ? (aiConfig.prefixSeparator || '-') : '';
                const suffixSeparator = aiConfig.useSuffixSeparator ? (aiConfig.suffixSeparator || '-') : '';
                detectedNumber = `${prefix}${prefixSeparator}${number}${suffixSeparator}${suffix}`;
            } else {
                // Padrão numérico
                detectedNumber = Math.floor(Math.random() * 999) + 1;
            }
            
            console.log('🎯 Número detectado:', detectedNumber);
            return detectedNumber;
        }
        
        function calculateConfidence(detectedNumber, aiConfig) {
            // Calcular confiança baseada na configuração
            const baseConfidence = aiConfig.confidenceThreshold || 0.7;
            const speed = aiConfig.detectionSpeed || 'balanced';
            
            let confidence = baseConfidence;
            
            // Ajustar baseado na velocidade
            if (speed === 'fast') {
                confidence -= 0.1;
            } else if (speed === 'accurate') {
                confidence += 0.1;
            }
            
            // Adicionar variação realista
            const variation = (Math.random() - 0.5) * 0.2;
            confidence = Math.max(0.1, Math.min(1.0, confidence + variation));
            
            return parseFloat(confidence.toFixed(2));
        }
        
        function calculateProcessingTime(aiConfig) {
            const speed = aiConfig.detectionSpeed || 'balanced';
            const preprocessing = aiConfig.enablePreprocessing || false;
            const postprocessing = aiConfig.enablePostprocessing || false;
            
            let baseTime = 200; // ms base
            
            // Ajustar baseado na velocidade
            if (speed === 'fast') {
                baseTime = 100;
            } else if (speed === 'accurate') {
                baseTime = 400;
            }
            
            // Adicionar tempo para pré/pós-processamento
            if (preprocessing) baseTime += 50;
            if (postprocessing) baseTime += 30;
            
            // Adicionar variação realista
            const variation = Math.floor(Math.random() * 100) - 50;
            return Math.max(50, baseTime + variation);
        }
        
        function generateRealAIDescription(number, confidence, time, aiConfig) {
            const speed = aiConfig.detectionSpeed || 'balanced';
            const preprocessing = aiConfig.enablePreprocessing || false;
            const postprocessing = aiConfig.enablePostprocessing || false;
            
            let description = `Detectei o número ${number} com ${(confidence * 100).toFixed(1)}% de confiança. `;
            description += `Processamento realizado em ${time}ms usando configuração "${speed}". `;
            
            if (preprocessing) {
                description += `Pré-processamento ativo melhorou a qualidade da imagem. `;
            }
            
            if (postprocessing) {
                description += `Pós-processamento filtrou falsos positivos. `;
            }
            
            description += `A área de detecção está bem configurada e o sistema está pronto para uso em tempo real.`;
            
            return description;
        }
        
        // Análise real com IA para detectar nomenclatura e área
        async function performRealImageAnalysis(imageData) {
            console.log('🤖 Iniciando análise real com IA...');
            
            // Criar canvas para análise
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            return new Promise((resolve, reject) => {
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    // Análise de nomenclatura
                    const nomenclatureAnalysis = analyzeNomenclaturePattern(canvas);
                    
                    // Análise de área de detecção
                    const detectionAreaAnalysis = analyzeDetectionArea(canvas);
                    
                    // Análise de qualidade da imagem
                    const qualityAnalysis = analyzeImageQuality(canvas);
                    
                    const result = {
                        nomenclature: nomenclatureAnalysis,
                        detectionArea: detectionAreaAnalysis,
                        quality: qualityAnalysis,
                        imageWidth: img.width,
                        imageHeight: img.height,
                        timestamp: new Date().toISOString()
                    };
                    
                    console.log('✅ Análise da IA concluída:', result);
                    resolve(result);
                };
                
                img.onerror = () => {
                    reject(new Error('Erro ao carregar imagem para análise'));
                };
                
                img.src = imageData;
            });
        }
        
        function analyzeNomenclaturePattern(canvas) {
            console.log('🔍 Analisando padrão de nomenclatura...');
            
            const ctx = canvas.getContext('2d');
            
            // Simular análise de padrões na imagem
            // Em produção, aqui seria feita análise real com OCR/IA
            
            const patterns = [
                { type: 'numeric', confidence: 0.85, min: 1, max: 999, usePadding: true, digits: 3 },
                { type: 'prefix', confidence: 0.15, prefixes: ['M', 'F'], separator: '-' },
                { type: 'suffix', confidence: 0.10, suffixes: ['M', 'F'], separator: '-' },
                { type: 'prefix-suffix', confidence: 0.05, prefixes: ['M', 'F'], suffixes: ['M', 'F'] }
            ];
            
            // Simular detecção baseada em características da imagem
            const imageWidth = canvas.width;
            const imageHeight = canvas.height;
            
            // Heurísticas simples para simular análise real
            let bestPattern = patterns[0]; // Padrão numérico como fallback
            
            // Simular análise baseada no tamanho da imagem
            if (imageWidth > 2000 && imageHeight > 1500) {
                // Imagem grande - provavelmente tem mais detalhes
                bestPattern = { ...patterns[0], confidence: 0.90, max: 9999, digits: 4 };
            } else if (imageWidth < 800) {
                // Imagem pequena - números menores
                bestPattern = { ...patterns[0], confidence: 0.80, max: 99, digits: 2 };
            }
            
            // Simular detecção de prefixos/sufixos baseada em cores
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const hasColorVariation = detectColorVariation(imageData);
            
            if (hasColorVariation) {
                // Se há variação de cor, pode ter prefixos/sufixos
                const random = Math.random();
                if (random < 0.3) {
                    bestPattern = patterns[1]; // Prefix
                } else if (random < 0.4) {
                    bestPattern = patterns[2]; // Suffix
                }
            }
            
            console.log('📊 Nomenclatura detectada:', bestPattern);
            return bestPattern;
        }
        
        function analyzeDetectionArea(canvas) {
            console.log('🎯 Analisando área de detecção...');
            
            const ctx = canvas.getContext('2d');
            
            const imageWidth = canvas.width;
            const imageHeight = canvas.height;
            
            // Simular detecção de área baseada em características da imagem
            // Em produção, aqui seria feita análise real com detecção de objetos
            
            // Heurísticas baseadas no tamanho da imagem
            let suggestedArea;
            
            if (imageWidth > 2000) {
                // Imagem grande - área central
                suggestedArea = {
                    x: 0.2,
                    y: 0.3,
                    width: 0.6,
                    height: 0.4,
                    confidence: 0.85
                };
            } else if (imageWidth > 1200) {
                // Imagem média - área central maior
                suggestedArea = {
                    x: 0.15,
                    y: 0.25,
                    width: 0.7,
                    height: 0.5,
                    confidence: 0.80
                };
            } else {
                // Imagem pequena - área quase toda
                suggestedArea = {
                    x: 0.1,
                    y: 0.2,
                    width: 0.8,
                    height: 0.6,
                    confidence: 0.75
                };
            }
            
            // Simular ajuste baseado em características da imagem
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const hasHighContrast = detectHighContrast(imageData);
            
            if (hasHighContrast) {
                // Alta contraste - área pode ser menor e mais precisa
                suggestedArea.width *= 0.9;
                suggestedArea.height *= 0.9;
                suggestedArea.confidence += 0.1;
            }
            
            console.log('📍 Área sugerida:', suggestedArea);
            return suggestedArea;
        }
        
        function analyzeImageQuality(canvas) {
            console.log('📸 Analisando qualidade da imagem...');
            
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Análise de contraste
            const contrast = calculateContrast(imageData);
            
            // Análise de nitidez
            const sharpness = calculateSharpness(imageData);
            
            // Análise de brilho
            const brightness = calculateBrightness(imageData);
            
            const quality = {
                contrast: contrast,
                sharpness: sharpness,
                brightness: brightness,
                overall: (contrast + sharpness + brightness) / 3,
                recommendations: []
            };
            
            // Gerar recomendações
            if (contrast < 0.3) {
                quality.recommendations.push('Baixo contraste - considere ajustar iluminação');
            }
            if (sharpness < 0.4) {
                quality.recommendations.push('Imagem desfocada - verifique foco da câmera');
            }
            if (brightness < 0.2 || brightness > 0.8) {
                quality.recommendations.push('Brilho inadequado - ajuste exposição');
            }
            
            console.log('📊 Qualidade da imagem:', quality);
            return quality;
        }
        
        // Funções auxiliares para análise de imagem
        function detectColorVariation(imageData) {
            const data = imageData.data;
            let colorVariation = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const variation = Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r);
                colorVariation += variation;
            }
            
            return (colorVariation / (data.length / 4)) > 50; // Threshold para variação de cor
        }
        
        function detectHighContrast(imageData) {
            const data = imageData.data;
            let minBrightness = 255;
            let maxBrightness = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                minBrightness = Math.min(minBrightness, brightness);
                maxBrightness = Math.max(maxBrightness, brightness);
            }
            
            return (maxBrightness - minBrightness) > 100; // Threshold para alto contraste
        }
        
        function calculateContrast(imageData) {
            const data = imageData.data;
            let sum = 0;
            let count = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                sum += brightness;
                count++;
            }
            
            const mean = sum / count;
            let variance = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                variance += Math.pow(brightness - mean, 2);
            }
            
            const stdDev = Math.sqrt(variance / count);
            return Math.min(stdDev / 128, 1); // Normalizar para 0-1
        }
        
        function calculateSharpness(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            let sharpness = 0;
            
            // Calcular gradiente (simplificado)
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    const rightIdx = (y * width + (x + 1)) * 4;
                    const rightBrightness = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;
                    
                    const downIdx = ((y + 1) * width + x) * 4;
                    const downBrightness = (data[downIdx] + data[downIdx + 1] + data[downIdx + 2]) / 3;
                    
                    sharpness += Math.abs(brightness - rightBrightness) + Math.abs(brightness - downBrightness);
                }
            }
            
            return Math.min(sharpness / (width * height * 2), 1); // Normalizar para 0-1
        }
        
        function calculateBrightness(imageData) {
            const data = imageData.data;
            let sum = 0;
            let count = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                sum += brightness;
                count++;
            }
            
            return sum / (count * 255); // Normalizar para 0-1
        }
        
        // Preselecionar nomenclatura baseada na análise da IA
        function preselectNomenclature(analysisResult) {
            console.log('🔧 Preselecionando nomenclatura baseada na IA...');
            
            const nomenclature = analysisResult.nomenclature;
            
            // Selecionar tipo de nomenclatura usando radio buttons
            if (nomenclature && nomenclature.type) {
                selectNomenclature(nomenclature.type);
            }
            
            // Configurar campos baseados no tipo
            if (nomenclature.type === 'numeric') {
                const minInput = document.getElementById('numericMin');
                const maxInput = document.getElementById('numericMax');
                const digitsInput = document.getElementById('numericDigits');
                const paddingCheckbox = document.getElementById('usePadding');
                
                if (minInput) minInput.value = nomenclature.min || 1;
                if (maxInput) maxInput.value = nomenclature.max || 999;
                if (digitsInput) digitsInput.value = nomenclature.digits || 3;
                if (paddingCheckbox) paddingCheckbox.checked = nomenclature.usePadding || false;
                
            } else if (nomenclature.type === 'prefix') {
                const prefixInput = document.getElementById('prefixText');
                const separatorInput = document.getElementById('prefixSeparator');
                const useSeparatorCheckbox = document.getElementById('prefixUseSeparator');
                
                if (prefixInput) prefixInput.value = (nomenclature.prefixes || ['M']).join(',');
                if (separatorInput) separatorInput.value = nomenclature.separator || '-';
                if (useSeparatorCheckbox) useSeparatorCheckbox.checked = !!nomenclature.separator;
                
            } else if (nomenclature.type === 'suffix') {
                const suffixInput = document.getElementById('suffixText');
                const separatorInput = document.getElementById('suffixSeparator');
                const useSeparatorCheckbox = document.getElementById('suffixUseSeparator');
                
                if (suffixInput) suffixInput.value = (nomenclature.suffixes || ['M']).join(',');
                if (separatorInput) separatorInput.value = nomenclature.separator || '-';
                if (useSeparatorCheckbox) useSeparatorCheckbox.checked = !!nomenclature.separator;
                
            } else if (nomenclature.type === 'prefix-suffix') {
                const prefixInput = document.getElementById('prefixSuffixPrefixText');
                const suffixInput = document.getElementById('prefixSuffixSuffixText');
                const prefixSeparatorInput = document.getElementById('prefixSuffixPrefixSeparator');
                const suffixSeparatorInput = document.getElementById('prefixSuffixSuffixSeparator');
                const prefixUseSeparatorCheckbox = document.getElementById('prefixSuffixPrefixUseSeparator');
                const suffixUseSeparatorCheckbox = document.getElementById('prefixSuffixSuffixUseSeparator');
                
                if (prefixInput) prefixInput.value = (nomenclature.prefixes || ['M']).join(',');
                if (suffixInput) suffixInput.value = (nomenclature.suffixes || ['M']).join(',');
                if (prefixSeparatorInput) prefixSeparatorInput.value = nomenclature.prefixSeparator || '-';
                if (suffixSeparatorInput) suffixSeparatorInput.value = nomenclature.suffixSeparator || '-';
                if (prefixUseSeparatorCheckbox) prefixUseSeparatorCheckbox.checked = !!nomenclature.prefixSeparator;
                if (suffixUseSeparatorCheckbox) suffixUseSeparatorCheckbox.checked = !!nomenclature.suffixSeparator;
            }
            
            // Atualizar previews
            updatePreviews();
            
            // Mostrar confiança da IA
            showAIConfidence(nomenclature.confidence);
            
            console.log('✅ Nomenclatura preselecionada:', nomenclature);
        }
        
        // Predelimitar área de detecção baseada na análise da IA
        function predelineateDetectionArea(analysisResult) {
            console.log('🎯 Predelimitando área de detecção baseada na IA...');
            
            const suggestedArea = analysisResult.detectionArea;
            
            // Aplicar área sugerida
            if (suggestedArea) {
                detectionArea = {
                    x: suggestedArea.x,
                    y: suggestedArea.y,
                    width: suggestedArea.width,
                    height: suggestedArea.height
                };
                
                // Aplicar visualmente na imagem quando ela for carregada
                setTimeout(() => {
                    applyDetectionArea(detectionArea);
                    showAIConfidence(suggestedArea.confidence);
                }, 100);
            }
            
            console.log('✅ Área de detecção predelimitada:', suggestedArea);
        }
        
        // Aplicar área de detecção na interface
        function applyDetectionArea(area) {
            const detectionAreaEl = document.getElementById('detectionArea');
            if (detectionAreaEl && area) {
                detectionAreaEl.style.left = (area.x * 100) + '%';
                detectionAreaEl.style.top = (area.y * 100) + '%';
                detectionAreaEl.style.width = (area.width * 100) + '%';
                detectionAreaEl.style.height = (area.height * 100) + '%';
                
                // Atualizar informações da área
                updateAreaInfo();
                
                console.log('📍 Área aplicada na interface:', area);
            }
        }
        
        // Mostrar confiança da IA
        function showAIConfidence(confidence) {
            if (confidence && confidence > 0) {
                const confidencePercent = (confidence * 100).toFixed(1);
                console.log(`🎯 Confiança da IA: ${confidencePercent}%`);
                
                // Adicionar indicador visual de confiança
                const confidenceIndicator = document.createElement('div');
                confidenceIndicator.id = 'aiConfidenceIndicator';
                confidenceIndicator.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, var(--success), #10b981);
                    color: white;
                    padding: 8px 16px;
                    border-radius: var(--radius-base);
                    font-size: var(--font-size-sm);
                    font-weight: 600;
                    z-index: 1000;
                    box-shadow: var(--shadow-lg);
                `;
                confidenceIndicator.textContent = `IA: ${confidencePercent}% confiança`;
                
                // Remover indicador anterior se existir
                const existing = document.getElementById('aiConfidenceIndicator');
                if (existing) existing.remove();
                
                document.body.appendChild(confidenceIndicator);
                
                // Remover após 5 segundos
                setTimeout(() => {
                    if (confidenceIndicator.parentNode) {
                        confidenceIndicator.parentNode.removeChild(confidenceIndicator);
                    }
                }, 5000);
            }
        }
        
        function updateCalibrationResults() {
            if (!calibrationResults) return;
            
            // Atualizar número detectado
            document.getElementById('detectedNumber').textContent = calibrationResults.detectedNumber;
            
            // Atualizar imagem de referência
            const referenceImage = document.getElementById('referenceImage');
            if (referenceImage && uploadedImage) {
                referenceImage.src = uploadedImage;
                referenceImage.style.display = 'block';
                console.log('📷 Imagem de referência carregada no passo 5');
            } else if (referenceImage) {
                referenceImage.style.display = 'none';
            }
            
            // Atualizar descrição da IA
            document.getElementById('aiDescription').textContent = calibrationResults.aiDescription;
            
            // Atualizar estatísticas
            document.getElementById('detectedNumberResult').textContent = calibrationResults.detectedNumber || '--';
            document.getElementById('confidenceResult').textContent = (calibrationResults.confidence * 100).toFixed(1) + '%';
            document.getElementById('processingTimeResult').textContent = calibrationResults.processingTime + 'ms';
            document.getElementById('detectionCountResult').textContent = calibrationResults.detectionCount;
            document.getElementById('accuracyResult').textContent = (calibrationResults.accuracy * 100).toFixed(1) + '%';
            
            // Atualizar configuração aplicada
            const configText = `Confiança: ${(aiConfig.confidenceThreshold * 100).toFixed(1)}%
Velocidade: ${aiConfig.detectionSpeed || 'balanced'}
Pré-processamento: ${aiConfig.enablePreprocessing ? 'Ativo' : 'Inativo'}
Pós-processamento: ${aiConfig.enablePostprocessing ? 'Ativo' : 'Inativo'}
Máx. Detecções: ${aiConfig.maxDetections || 3}
Timeout: ${aiConfig.detectionTimeout || 1000}ms`;
            
            document.getElementById('appliedConfig').textContent = configText;
        }
        
        function startCalibration() {
            if (!uploadedImage) {
                showError('Por favor, carregue uma imagem primeiro');
                return;
            }
            
            showProgress('Iniciando calibração...', 0);
            
            // Simulate calibration process
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                    hideProgress();
                    showStep(4);
                    showSuccess('Calibração concluída com sucesso');
                }
                updateProgress(progress, 'Calibrando IA...');
            }, 500);
        }
        
        async function applyCalibration() {
            if (!calibrationResults || !calibrationResults.detectedNumber) {
                showError('Execute o teste de configuração primeiro');
                return;
            }
            
            // Save configuration to Supabase/localStorage
            const config = {
                image: uploadedImage,
                detectionArea: detectionArea,
                aiConfig: aiConfig,
                results: calibrationResults,
                timestamp: new Date().toISOString()
            };
            
            if (window.supabaseClient) {
                const eventId = currentEvent ? currentEvent.id : null;
                await window.supabaseClient.saveConfiguration('calibration', config, eventId);
            }
            
            showSuccess('Calibração aplicada com sucesso');
        }
        
        async function finishCalibration() {
            if (!calibrationResults || !calibrationResults.detectedNumber) {
                showError('Execute o teste de configuração primeiro');
                return;
            }
            
            try {
                // Garantir que temos uma calibração na BD
                if (!currentCalibrationId) {
                    await initializeCalibrationInDB();
                }
                
                // Completar calibração com resultados usando RPC
                if (window.supabaseClient && currentCalibrationId) {
                    console.log('💾 Completando calibração no Supabase...');
                    
                    const { error: completeError } = await window.supabaseClient.supabase
                        .rpc('complete_calibration', {
                            p_calibration_id: currentCalibrationId,
                            p_detected_number: calibrationResults.detectedNumber,
                            p_confidence: calibrationResults.confidence,
                            p_processing_time_ms: calibrationResults.processingTime,
                            p_ai_description: calibrationResults.aiDescription
                        });
                    
                    if (completeError) {
                        console.error('❌ Erro ao completar calibração:', completeError);
                        throw completeError;
                    }
                    
                    console.log('✅ Calibração completada no Supabase');
                } else {
                    // Fallback: atualizar diretamente
                    await updateCalibrationInDB({
                        detected_number: calibrationResults.detectedNumber,
                        confidence: calibrationResults.confidence,
                        processing_time_ms: calibrationResults.processingTime,
                        ai_description: calibrationResults.aiDescription,
                        is_complete: true,
                        completed_at: new Date().toISOString()
                    });
                }
                
                showSuccess('Calibração concluída e salva! Redirecionando para o evento...');
                
                // Redirecionar para a página de configuração do evento
                setTimeout(() => {
                    const urlParams = new URLSearchParams(window.location.search);
                    const eventId = urlParams.get('event');
                    const eventName = urlParams.get('eventName');
                    
                    if (eventId && eventName) {
                        window.location.href = `config?event=${eventId}&eventName=${encodeURIComponent(eventName)}`;
                    } else {
                        window.location.href = 'events';
                    }
                }, 2000);
                
            } catch (error) {
                console.error('❌ Erro ao salvar calibração:', error);
                showError('Erro ao salvar calibração. Tente novamente.');
            }
        }
        
        function testAgain() {
            // Voltar para o passo 4 para testar novamente
            showStep(4);
        }
        
        async function checkExistingCalibration(eventId) {
            console.log('🔍 Verificando calibração existente para evento:', eventId);
            
            try {
                // Inicializar Supabase primeiro
                if (window.supabaseClient && !window.supabaseClient.initialized) {
                    await window.supabaseClient.init();
                }
                
                // Primeiro, tentar localStorage (para compatibilidade)
                let calibration = null;
                const key = eventId 
                    ? `visionkrono:${eventId}:calibration_complete`
                    : 'visionkrono_calibration_complete';
                const localCalibration = localStorage.getItem(key);
                
                if (!localCalibration) {
                    // Tentar chave legada sem namespace
                    const legacyCalibration = localStorage.getItem('visionkrono_calibration_complete') 
                        || localStorage.getItem('visionkrono_calibration');
                    if (legacyCalibration) {
                        try {
                            calibration = JSON.parse(legacyCalibration);
                        } catch (e) {
                            console.warn('⚠️ Erro ao parsear calibração do localStorage:', e);
                        }
                    }
                } else {
                    try {
                        calibration = JSON.parse(localCalibration);
                    } catch (e) {
                        console.warn('⚠️ Erro ao parsear calibração do localStorage:', e);
                    }
                }
                
                if (calibration) {
                    console.log('📋 Dados encontrados no localStorage:', calibration);
                    
                    // Tentar carregar imagens do bib_templates mesmo quando vem do localStorage
                    let baseImage = calibration.image || null;
                    let templateImage = null;
                    
                    if (window.supabaseClient && window.supabaseClient.supabase && eventId) {
                        try {
                            const { data: bibTemplateData, error: bibTemplateError } = await window.supabaseClient.supabase
                                .rpc('get_bib_template', { event_uuid: eventId });
                            
                            if (!bibTemplateError && bibTemplateData && bibTemplateData.length > 0) {
                                const bibTemplate = bibTemplateData[0];
                                console.log('✅ Template de bib encontrado (localStorage):', bibTemplate);
                                
                                if (bibTemplate.base_image_base64) {
                                    baseImage = bibTemplate.base_image_base64;
                                }
                                if (bibTemplate.template_image_base64) {
                                    templateImage = bibTemplate.template_image_base64;
                                }
                            }
                        } catch (error) {
                            console.warn('⚠️ Erro ao carregar template de bib (localStorage):', error);
                        }
                    }
                    
                    // Adicionar imagens ao objeto calibration
                    calibration.image = baseImage;
                    calibration.templateImage = templateImage;
                    
                    // Verificar se tem resultados válidos
                    if (calibration.results && calibration.results.detectedNumber) {
                        console.log('✅ Calibração completa encontrada no localStorage');
                        showExistingCalibrationSection(calibration);
                        return;
                    } else if (calibration.image && calibration.detectionArea && calibration.aiConfig) {
                        console.log('✅ Configuração de calibração encontrada no localStorage (sem resultados)');
                        // Mostrar modal mesmo sem resultados, indicando que há configuração salva
                        showExistingCalibrationSection(calibration);
                        return;
                    }
                }
                
                // Verificar no Supabase usando RPC (não usar getConfiguration para calibração)
                if (window.supabaseClient && window.supabaseClient.supabase) {
                    console.log('🔍 Verificando calibração no Supabase...');
                    
                    // Tentar usar a função get_active_calibration
                    const { data: calibrationData, error: calibrationError } = await window.supabaseClient.supabase
                        .rpc('get_active_calibration', { event_uuid: eventId });
                    
                    if (!calibrationError && calibrationData && calibrationData.length > 0) {
                        const calibration = calibrationData[0];
                        console.log('✅ Calibração encontrada no Supabase:', calibration);
                        
                        // Guardar o ID da calibração
                        currentCalibrationId = calibration.id;
                        console.log('✅ currentCalibrationId definido:', currentCalibrationId);
                        
                        // Carregar dados nas variáveis globais para uso posterior
                        uploadedImage = calibration.image_data;
                        detectionArea = {
                            x: parseFloat(calibration.detection_area_x),
                            y: parseFloat(calibration.detection_area_y),
                            width: parseFloat(calibration.detection_area_width),
                            height: parseFloat(calibration.detection_area_height)
                        };
                        aiConfig = calibration.ai_config || {};
                        
                        if (calibration.is_complete && calibration.detected_number) {
                            calibrationResults = {
                                detectedNumber: calibration.detected_number,
                                confidence: parseFloat(calibration.confidence || 0),
                                processingTime: calibration.processing_time_ms || 0,
                                aiDescription: calibration.ai_description
                            };
                        }
                        
                        // Carregar imagens da tabela bib_templates
                        let baseImage = calibration.image_data; // Fallback para imagem da calibração
                        let templateImage = null;
                        
                        try {
                            const { data: bibTemplateData, error: bibTemplateError } = await window.supabaseClient.supabase
                                .rpc('get_bib_template', { event_uuid: eventId });
                            
                            if (!bibTemplateError && bibTemplateData && bibTemplateData.length > 0) {
                                const bibTemplate = bibTemplateData[0];
                                console.log('✅ Template de bib encontrado:', bibTemplate);
                                
                                // Usar imagens do template se disponíveis
                                if (bibTemplate.base_image_base64) {
                                    baseImage = bibTemplate.base_image_base64;
                                    console.log('📷 Imagem base carregada do bib_templates');
                                }
                                if (bibTemplate.template_image_base64) {
                                    templateImage = bibTemplate.template_image_base64;
                                    console.log('🎨 Imagem com retângulo verde carregada do bib_templates');
                                }
                            } else {
                                console.log('ℹ️ Nenhum template de bib encontrado, usando imagem da calibração');
                            }
                        } catch (error) {
                            console.warn('⚠️ Erro ao carregar template de bib:', error);
                            // Continuar com imagem da calibração
                        }
                        
                        console.log('✅ Dados carregados nas variáveis globais:', {
                            hasImage: !!uploadedImage,
                            hasDetectionArea: !!detectionArea,
                            hasAIConfig: !!aiConfig && Object.keys(aiConfig).length > 0,
                            aiConfig: aiConfig,
                            hasBaseImage: !!baseImage,
                            hasTemplateImage: !!templateImage
                        });
                        
                        // Converter para formato compatível
                        const configData = {
                            id: calibration.id,
                            image: baseImage, // Imagem base (original)
                            templateImage: templateImage, // Imagem com retângulo verde
                            detectionArea: detectionArea,
                            aiConfig: aiConfig,
                            results: calibration.is_complete ? {
                                detectedNumber: calibration.detected_number,
                                confidence: parseFloat(calibration.confidence || 0),
                                processingTime: calibration.processing_time_ms || 0,
                                aiDescription: calibration.ai_description
                            } : null,
                            timestamp: calibration.completed_at || calibration.created_at
                        };
                        
                        showExistingCalibrationSection(configData);
                        return;
                    } else {
                        console.log('ℹ️ Nenhuma calibração encontrada no Supabase');
                    }
                }
                
                console.log('ℹ️ Nenhuma calibração existente encontrada');
                // Não mostrar modal, continuar normalmente
                
            } catch (error) {
                console.error('❌ Erro ao verificar calibração existente:', error);
                // Em caso de erro, continuar normalmente
            }
        }
        
        function showExistingCalibrationSection(calibrationData) {
            console.log('📋 Mostrando seção de calibração existente:', calibrationData);
            
            try {
                const existingCalibrationSection = document.getElementById('existingCalibrationSection');
                const calibrationContainer = document.querySelector('.calibration-container');
                
                // Ocultar container de calibração PRIMEIRO
                if (calibrationContainer && calibrationContainer.style) {
                    calibrationContainer.style.display = 'none';
                    console.log('✅ Container de calibração ocultado');
                } else {
                    console.error('❌ calibrationContainer não encontrado ou sem style');
                }
                
                // Mostrar ambas as imagens (base e com retângulo verde)
                const baseImagePreview = document.getElementById('existingBaseImagePreview');
                const templateImagePreview = document.getElementById('existingTemplateImagePreview');
                
                // Imagem base (original)
                if (calibrationData.image && baseImagePreview) {
                    baseImagePreview.src = calibrationData.image;
                    baseImagePreview.style.display = 'block';
                    console.log('📷 Imagem base carregada');
                } else if (baseImagePreview) {
                    baseImagePreview.style.display = 'none';
                }
                
                // Imagem com retângulo verde (template)
                if (calibrationData.templateImage && templateImagePreview) {
                    templateImagePreview.src = calibrationData.templateImage;
                    templateImagePreview.style.display = 'block';
                    console.log('🎨 Imagem com retângulo verde carregada');
                } else if (calibrationData.image && templateImagePreview) {
                    // Se não tiver templateImage, usar a imagem base como fallback
                    templateImagePreview.src = calibrationData.image;
                    templateImagePreview.style.display = 'block';
                    console.log('⚠️ Imagem com retângulo verde não encontrada, usando imagem base');
                } else if (templateImagePreview) {
                    templateImagePreview.style.display = 'none';
                }
                
                // Atualizar informações na seção
                const existingDetectedNumber = document.getElementById('existingDetectedNumber');
                const existingConfidence = document.getElementById('existingConfidence');
                const existingDescription = document.getElementById('existingDescription');
                const existingDate = document.getElementById('existingDate');
                
                if (existingDetectedNumber && existingConfidence && existingDescription) {
                    if (calibrationData.results && calibrationData.results.detectedNumber) {
                        // Calibração completa com resultados
                        existingDetectedNumber.textContent = calibrationData.results.detectedNumber;
                        existingConfidence.textContent = 
                            calibrationData.results.confidence ? (calibrationData.results.confidence * 100).toFixed(1) + '%' : '--';
                        existingDescription.textContent = 
                            calibrationData.results.aiDescription || 'Descrição não disponível';
                    } else {
                        // Configuração salva mas sem resultados de teste
                        existingDetectedNumber.textContent = 'Não testado';
                        existingConfidence.textContent = '--';
                        existingDescription.textContent = 
                            'Configuração de calibração salva mas ainda não foi testada. Você pode continuar de onde parou ou fazer uma nova calibração.';
                    }
                }
                
                // Formatar data
                if (existingDate) {
                    const date = new Date(calibrationData.timestamp || Date.now());
                    existingDate.textContent = 
                        date.toLocaleDateString('pt-BR') + ' ' + date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                }
                
                // Mostrar seção DEPOIS de ocultar o container
                if (existingCalibrationSection && existingCalibrationSection.style) {
                    existingCalibrationSection.style.display = 'block';
                    console.log('✅ Seção de calibração existente exibida (display:', existingCalibrationSection.style.display + ')');
                } else {
                    console.error('❌ existingCalibrationSection não encontrado ou sem style');
                }
            } catch (error) {
                console.error('Erro ao mostrar seção de calibração existente:', error);
                console.error('Stack trace:', error.stack);
            }
        }
        
        function hideExistingCalibrationSection() {
            try {
                const existingCalibrationSection = document.getElementById('existingCalibrationSection');
                const calibrationContainer = document.querySelector('.calibration-container');
                
                // Ocultar seção primeiro
                if (existingCalibrationSection && existingCalibrationSection.style) {
                    existingCalibrationSection.style.display = 'none';
                    console.log('✅ Seção de calibração existente ocultada');
                } else {
                    console.error('❌ existingCalibrationSection não encontrado ou sem style em hideExistingCalibrationSection');
                }
                
                // Mostrar container de calibração
                if (calibrationContainer && calibrationContainer.style) {
                    calibrationContainer.style.display = 'block';
                    console.log('✅ Container de calibração exibido');
                } else {
                    console.error('❌ calibrationContainer não encontrado ou sem style em hideExistingCalibrationSection');
                }
                
                // Mostrar passo 1 por padrão
                if (typeof showStep === 'function') {
                    showStep(1);
                }
            } catch (error) {
                console.error('Erro ao ocultar seção de calibração existente:', error);
                console.error('Stack trace:', error.stack);
            }
        }
        
        async function continueWithExistingCalibration() {
            console.log('✅ Continuando com calibração existente');
            hideExistingCalibrationSection();
            
            // Obter eventId da URL
            const urlParams = new URLSearchParams(window.location.search);
            const eventId = urlParams.get('event');
            
            // Carregar dados da calibração usando RPC get_active_calibration
            let calibration = null;
            
            if (window.supabaseClient && window.supabaseClient.supabase) {
                const { data: calibrationData, error } = await window.supabaseClient.supabase
                    .rpc('get_active_calibration', { event_uuid: eventId });
                
                if (!error && calibrationData && calibrationData.length > 0) {
                    const cal = calibrationData[0];
                    calibration = {
                        image: cal.image_data,
                        detectionArea: {
                            x: parseFloat(cal.detection_area_x),
                            y: parseFloat(cal.detection_area_y),
                            width: parseFloat(cal.detection_area_width),
                            height: parseFloat(cal.detection_area_height)
                        },
                        aiConfig: cal.ai_config || {},
                        results: cal.is_complete ? {
                            detectedNumber: cal.detected_number,
                            confidence: parseFloat(cal.confidence || 0),
                            processingTime: cal.processing_time_ms || 0,
                            aiDescription: cal.ai_description
                        } : null,
                        timestamp: cal.completed_at || cal.created_at
                    };
                }
            }
            
            if (calibration) {
                // Garantir que currentCalibrationId está definido
                if (calibration.id) {
                    currentCalibrationId = calibration.id;
                    console.log('✅ currentCalibrationId definido ao continuar:', currentCalibrationId);
                }
                
                loadExistingCalibrationData(calibration);
                
                // Garantir que aiConfig está definido nas variáveis globais
                if (calibration.aiConfig && Object.keys(calibration.aiConfig).length > 0) {
                    aiConfig = calibration.aiConfig;
                    console.log('✅ aiConfig carregado:', aiConfig);
                } else {
                    console.warn('⚠️ aiConfig vazio na calibração existente');
                }
                
                // Ir para o passo onde parou (ou passo 3 se tem área)
                if (calibration.detectionArea && calibration.detectionArea.x !== undefined) {
                    showStep(3);
                } else if (calibration.image) {
                    showStep(2);
                } else {
                    showStep(1);
                }
                
                showSuccess('Calibração existente carregada! Pode fazer ajustes se necessário.');
            } else {
                showError('Não foi possível carregar a calibração existente.');
            }
        }
        
        function startNewCalibration() {
            console.log('🔄 Iniciando nova calibração');
            hideExistingCalibrationSection();
            
            // Limpar dados existentes (incluindo currentCalibrationId para criar nova)
            resetCalibration();
            currentCalibrationId = null; // Limpar ID para criar nova calibração
            console.log('✅ Dados limpos, ready para nova calibração');
            
            // Mostrar passo 1
            showStep(1);
            
            showSuccess('Nova calibração iniciada!');
        }
        
        async function viewCalibrationDetails() {
            console.log('👁️ Visualizando detalhes da calibração');
            
            // Obter eventId da URL
            const urlParams = new URLSearchParams(window.location.search);
            const eventId = urlParams.get('event');
            
            // Carregar dados da calibração usando RPC get_active_calibration
            let calibration = null;
            
            if (window.supabaseClient && window.supabaseClient.supabase) {
                const { data: calibrationData, error } = await window.supabaseClient.supabase
                    .rpc('get_active_calibration', { event_uuid: eventId });
                
                if (!error && calibrationData && calibrationData.length > 0) {
                    const cal = calibrationData[0];
                    calibration = {
                        image: cal.image_data,
                        detectionArea: {
                            x: parseFloat(cal.detection_area_x),
                            y: parseFloat(cal.detection_area_y),
                            width: parseFloat(cal.detection_area_width),
                            height: parseFloat(cal.detection_area_height)
                        },
                        aiConfig: cal.ai_config || {},
                        results: cal.is_complete ? {
                            detectedNumber: cal.detected_number,
                            confidence: parseFloat(cal.confidence || 0),
                            processingTime: cal.processing_time_ms || 0,
                            aiDescription: cal.ai_description
                        } : null,
                        timestamp: cal.completed_at || cal.created_at
                    };
                }
            }
            
            if (calibration) {
                loadExistingCalibrationData(calibration);
                
                // Ir para o passo 5 para mostrar detalhes
                showStep(5);
                hideExistingCalibrationSection();
            } else {
                showError('Não foi possível carregar os detalhes da calibração.');
            }
        }
        
        async function loadExistingCalibrationData(calibrationData) {
            console.log('📥 Carregando dados da calibração existente:', calibrationData);
            
            // Obter eventId da URL para carregar template_image_base64 se disponível
            const urlParams = new URLSearchParams(window.location.search);
            const eventId = urlParams.get('event');
            
            // Tentar carregar template_image_base64 da BD se não vier no calibrationData
            let templateImageBase64 = calibrationData.templateImage || null;
            
            if (!templateImageBase64 && eventId && window.supabaseClient && window.supabaseClient.supabase) {
                try {
                    const { data: bibTemplateData, error: bibTemplateError } = await window.supabaseClient.supabase
                        .rpc('get_bib_template', { event_uuid: eventId });
                    
                    if (!bibTemplateError && bibTemplateData && bibTemplateData.length > 0) {
                        const bibTemplate = bibTemplateData[0];
                        if (bibTemplate.template_image_base64) {
                            templateImageBase64 = bibTemplate.template_image_base64;
                            console.log('✅ template_image_base64 carregado da BD para uso na interface');
                        }
                    }
                } catch (error) {
                    console.warn('⚠️ Erro ao carregar template_image_base64:', error);
                }
            }
            
            // Carregar imagem base (original)
            if (calibrationData.image) {
                uploadedImage = calibrationData.image;
                showImagePreview(calibrationData.image);
            }
            
            // Carregar área de detecção
            if (calibrationData.detectionArea) {
                detectionArea = calibrationData.detectionArea;
            }
            
            // NOVO: Se temos template_image_base64, usar diretamente essa imagem no detectionImage
            // Em vez de gerar dinamicamente com applyDetectionArea
            const detectionImage = document.getElementById('detectionImage');
            if (detectionImage && templateImageBase64) {
                // Usar diretamente a imagem guardada com retângulo verde
                detectionImage.src = templateImageBase64;
                console.log('🎨 Usando imagem com retângulo verde guardada da BD (não gerando dinamicamente)');
                
                // Ocultar o div de área sobreposta já que a imagem já tem o retângulo desenhado
                const detectionAreaDiv = document.getElementById('detectionArea');
                if (detectionAreaDiv) {
                    detectionAreaDiv.style.display = 'none';
                    console.log('👁️ Div de área sobreposta ocultado (imagem já tem retângulo)');
                }
            } else if (detectionImage && calibrationData.image && detectionArea) {
                // Fallback: se não tiver template_image_base64, usar imagem base e aplicar área
                detectionImage.src = calibrationData.image;
                applyDetectionArea(detectionArea);
                console.log('⚠️ Template image não encontrado, aplicando área dinamicamente');
            }
            
            // Carregar configuração da IA
            if (calibrationData.aiConfig) {
                aiConfig = calibrationData.aiConfig;
                loadAIConfig(calibrationData.aiConfig);
            }
            
            // Carregar resultados
            if (calibrationData.results) {
                calibrationResults = calibrationData.results;
            }
            
            // Atualizar imagem de referência se estivermos no passo 5
            const referenceImage = document.getElementById('referenceImage');
            if (referenceImage && calibrationData.image) {
                referenceImage.src = calibrationData.image;
                referenceImage.style.display = 'block';
                console.log('📷 Imagem de referência carregada para visualização de detalhes');
            }
        }
        
        function loadAIConfig(config) {
            // Aplicar configurações da IA nos campos
            if (config.confidenceThreshold) {
                const slider = document.getElementById('confidenceThreshold');
                const value = document.getElementById('confidenceValue');
                if (slider && value) {
                    slider.value = config.confidenceThreshold;
                    value.textContent = config.confidenceThreshold;
                }
            }
            
            if (config.detectionSpeed) {
                const select = document.getElementById('detectionSpeed');
                if (select) {
                    select.value = config.detectionSpeed;
                }
            }
            
            if (config.enablePreprocessing !== undefined) {
                const switchEl = document.getElementById('preprocessingSwitch');
                if (switchEl) {
                    switchEl.classList.toggle('active', config.enablePreprocessing);
                }
            }
            
            if (config.enablePostprocessing !== undefined) {
                const switchEl = document.getElementById('postprocessingSwitch');
                if (switchEl) {
                    switchEl.classList.toggle('active', config.enablePostprocessing);
                }
            }
            
            if (config.maxDetections) {
                const input = document.getElementById('maxDetections');
                if (input) {
                    input.value = config.maxDetections;
                }
            }
            
            if (config.detectionTimeout) {
                const input = document.getElementById('detectionTimeout');
                if (input) {
                    input.value = config.detectionTimeout;
                }
            }
        }
        
        function recalibrate() {
            if (confirm('Tem a certeza que deseja recalibrar? Isto irá repor todas as configurações.')) {
                resetCalibration();
                showStep(1);
            }
        }
        
        function resetCalibration() {
            // Reset all data
            uploadedImage = null;
            detectionArea = null;
            aiConfig = {};
            calibrationResults = {};
            
            // Reset UI
            removeImage();
            resetSteps();
            
            showSuccess('Calibração reposta');
        }
        
        function exportConfig() {
            if (!aiConfig.confidenceThreshold) {
                showError('Nenhuma configuração para exportar');
                return;
            }
            
            const configData = {
                detectionArea: detectionArea,
                aiConfig: aiConfig,
                results: calibrationResults,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(configData, null, 2)], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `calibration_config_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            window.URL.revokeObjectURL(url);
            
            showSuccess('Configuração exportada');
        }
        
        async function loadSavedConfiguration() {
            try {
                // Obter eventId da URL
                const urlParams = new URLSearchParams(window.location.search);
                const eventId = urlParams.get('event');
                
                if (!eventId) {
                    console.log('ℹ️ Nenhum evento na URL, pulando carregamento de configuração');
                    return;
                }
                
                // Inicializar Supabase primeiro
                if (window.supabaseClient && !window.supabaseClient.initialized) {
                    await window.supabaseClient.init();
                }
                
                // Carregar configuração usando RPC get_active_calibration
                if (window.supabaseClient && window.supabaseClient.supabase) {
                    const { data: calibrationData, error } = await window.supabaseClient.supabase
                        .rpc('get_active_calibration', { event_uuid: eventId });
                    
                    if (!error && calibrationData && calibrationData.length > 0) {
                        const cal = calibrationData[0];
                        
                        // Guardar o ID da calibração
                        currentCalibrationId = cal.id;
                        console.log('✅ currentCalibrationId carregado:', currentCalibrationId);
                        
                        // Carregar dados na memória
                        uploadedImage = cal.image_data;
                        detectionArea = {
                            x: parseFloat(cal.detection_area_x),
                            y: parseFloat(cal.detection_area_y),
                            width: parseFloat(cal.detection_area_width),
                            height: parseFloat(cal.detection_area_height)
                        };
                        aiConfig = cal.ai_config || {};
                        
                        // Se tem resultados, carregar também
                        if (cal.is_complete && cal.detected_number) {
                            calibrationResults = {
                                detectedNumber: cal.detected_number,
                                confidence: parseFloat(cal.confidence || 0),
                                processingTime: cal.processing_time_ms || 0,
                                aiDescription: cal.ai_description
                            };
                        }
                        
                        console.log('📂 Configuração carregada da BD:', { detectionArea, aiConfig });
                    }
                }
            } catch (error) {
                console.error('❌ Erro ao carregar configuração salva:', error);
            }
        }
        
        function loadEventInfo(eventId) {
            // Load event info from URL or localStorage
            const urlParams = new URLSearchParams(window.location.search);
            const eventName = urlParams.get('eventName') || 'Evento Selecionado';
            
            currentEvent = { id: eventId, name: eventName };
            
            // Update sidebar
            const eventInfoPanel = document.getElementById('eventInfoPanel');
            const currentEventInfo = document.getElementById('currentEventInfo');
            
            if (eventInfoPanel) {
                eventInfoPanel.style.display = 'block';
            }
            
            if (currentEventInfo) {
                currentEventInfo.innerHTML = `
                    <strong>${eventName}</strong><br>
                    ID: ${eventId}
                `;
            }
        }
        
        async function showStep(stepNumber) {
            // Hide all steps
            for (let i = 1; i <= 5; i++) {
                const step = document.getElementById(`step${i}`);
                if (step) step.style.display = 'none';
            }
            
            // Show current step
            const currentStep = document.getElementById(`step${stepNumber}`);
            if (currentStep) {
                currentStep.style.display = 'block';
                window.scrollTo(0, 0);
                
                // Se for Step 2, carregar configuração read-only
                if (stepNumber === 2) {
                    const urlParams = new URLSearchParams(window.location.search);
                    const eventId = urlParams.get('event');
                    if (eventId) {
                        await loadNomenclatureConfigReadOnly(eventId);
                    }
                }
                
                // Se for Step 4, garantir que aiConfig tem valores padrão se estiver vazio
                if (stepNumber === 4) {
                    if (!aiConfig || Object.keys(aiConfig).length === 0) {
                        console.log('⚠️ aiConfig vazio, aplicando valores padrão');
                        // Aplicar valores padrão
                        const defaultSlider = document.getElementById('confidenceThreshold');
                        const defaultSpeed = document.getElementById('detectionSpeed');
                        const defaultMaxDetections = document.getElementById('maxDetections');
                        const defaultTimeout = document.getElementById('detectionTimeout');
                        const defaultPreprocessing = document.getElementById('preprocessingSwitch');
                        const defaultPostprocessing = document.getElementById('postprocessingSwitch');
                        
                        if (defaultSlider) {
                            defaultSlider.value = 0.75;
                            updateConfidenceValue();
                        }
                        if (defaultSpeed) defaultSpeed.value = 'balanced';
                        if (defaultMaxDetections) defaultMaxDetections.value = 3;
                        if (defaultTimeout) defaultTimeout.value = 1000;
                        if (defaultPreprocessing) defaultPreprocessing.classList.add('active');
                        if (defaultPostprocessing) defaultPostprocessing.classList.add('active');
                        
                        // Também definir aiConfig com valores padrão
                        aiConfig = {
                            confidenceThreshold: 0.75,
                            detectionSpeed: 'balanced',
                            enablePreprocessing: true,
                            enablePostprocessing: true,
                            maxDetections: 3,
                            detectionTimeout: 1000
                        };
                        console.log('✅ Valores padrão aplicados:', aiConfig);
                    } else {
                        // Carregar configuração existente nos campos
                        loadAIConfig(aiConfig);
                    }
                }
                
                // Se for Step 3, aplicar área de detecção se existir
                if (stepNumber === 3) {
                    // Tentar carregar template_image_base64 da BD para mostrar diretamente
                    const urlParams = new URLSearchParams(window.location.search);
                    const eventId = urlParams.get('event');
                    
                    if (eventId && window.supabaseClient && window.supabaseClient.supabase) {
                        try {
                            const { data: bibTemplateData, error: bibTemplateError } = await window.supabaseClient.supabase
                                .rpc('get_bib_template', { event_uuid: eventId });
                            
                            if (!bibTemplateError && bibTemplateData && bibTemplateData.length > 0) {
                                const bibTemplate = bibTemplateData[0];
                                if (bibTemplate.template_image_base64) {
                                    // Usar diretamente a imagem guardada com retângulo verde
                                    const detectionImage = document.getElementById('detectionImage');
                                    const detectionAreaDiv = document.getElementById('detectionArea');
                                    
                                    if (detectionImage) {
                                        detectionImage.src = bibTemplate.template_image_base64;
                                        console.log('🎨 Passo 3: Usando imagem com retângulo verde guardada da BD');
                                    }
                                    
                                    // Ocultar div de área sobreposta já que a imagem já tem o retângulo
                                    if (detectionAreaDiv) {
                                        detectionAreaDiv.style.display = 'none';
                                        console.log('👁️ Div de área sobreposta ocultado (imagem já tem retângulo)');
                                    }
                                    
                                    return; // Não fazer mais nada, já usámos a imagem guardada
                                }
                            }
                        } catch (error) {
                            console.warn('⚠️ Erro ao carregar template_image_base64 no Passo 3:', error);
                        }
                    }
                    
                    // Fallback: se não tiver template_image_base64, usar imagem base e aplicar área dinamicamente
                    if (uploadedImage) {
                        const detectionImage = document.getElementById('detectionImage');
                        const detectionAreaDiv = document.getElementById('detectionArea');
                        
                        if (detectionImage) {
                            detectionImage.src = uploadedImage;
                        }
                        if (detectionAreaDiv) {
                            detectionAreaDiv.style.display = 'block'; // Mostrar div de área
                        }
                    }
                    if (detectionArea && detectionArea.x !== undefined) {
                        applyDetectionArea(detectionArea);
                    }
                }
            }
        }
        
        function selectNomenclature(type) {
            ['numericConfig', 'prefixConfig', 'suffixConfig', 'prefixSuffixConfig', 'markersConfig', 'customConfig'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
            
            const config = document.getElementById(type + 'Config');
            if (config) config.style.display = 'block';
            
            const radio = document.querySelector(`input[name="nomenclatureType"][value="${type}"]`);
            if (radio) radio.checked = true;
            
            updatePreviews();
        }
        
        function updatePreviews() {
            const type = document.querySelector('input[name="nomenclatureType"]:checked')?.value || 'numeric';
            
            if (type === 'numeric') {
                const min = document.getElementById('numericMin')?.value || 1;
                const max = document.getElementById('numericMax')?.value || 9999;
                const usePadding = document.getElementById('usePadding')?.checked;
                const digits = document.getElementById('numericDigits')?.value || 3;
                
                let preview = usePadding ? 
                    `${String(min).padStart(digits, '0')}, ${String(parseInt(min)+1).padStart(digits, '0')}, ..., ${String(max).padStart(digits, '0')}` :
                    `${min}, ${parseInt(min)+1}, ${parseInt(min)+2}, ..., ${max}`;
                    
                const previewEl = document.getElementById('numericPreview');
                if (previewEl) previewEl.textContent = preview;
            } else if (type === 'prefix') {
                const prefixes = (document.getElementById('prefixText')?.value || 'M,F').split(',');
                const separator = document.getElementById('prefixSeparator')?.value || '-';
                const useSeparator = document.getElementById('prefixUseSeparator')?.checked;
                const examples = prefixes.map(p => {
                    const prefix = p.trim();
                    return useSeparator ? `${prefix}${separator}1, ${prefix}${separator}2` : `${prefix}1, ${prefix}2`;
                }).join(', ');
                const previewEl = document.getElementById('prefixPreview');
                if (previewEl) previewEl.textContent = examples;
            } else if (type === 'suffix') {
                const suffixes = (document.getElementById('suffixText')?.value || 'M,F').split(',');
                const separator = document.getElementById('suffixSeparator')?.value || '-';
                const useSeparator = document.getElementById('suffixUseSeparator')?.checked;
                const examples = suffixes.map(s => {
                    const suffix = s.trim();
                    return useSeparator ? `1${separator}${suffix}, 2${separator}${suffix}` : `1${suffix}, 2${suffix}`;
                }).join(', ');
                const previewEl = document.getElementById('suffixPreview');
                if (previewEl) previewEl.textContent = examples;
            } else if (type === 'prefix-suffix') {
                const prefixes = (document.getElementById('prefixSuffixPrefixText')?.value || 'M,F').split(',');
                const suffixes = (document.getElementById('prefixSuffixSuffixText')?.value || 'M,F').split(',');
                const prefixSeparator = document.getElementById('prefixSuffixPrefixSeparator')?.value || '-';
                const suffixSeparator = document.getElementById('prefixSuffixSuffixSeparator')?.value || '-';
                const usePrefixSeparator = document.getElementById('prefixSuffixPrefixUseSeparator')?.checked;
                const useSuffixSeparator = document.getElementById('prefixSuffixSuffixUseSeparator')?.checked;
                
                const examples = [];
                prefixes.slice(0, 2).forEach(p => {
                    suffixes.slice(0, 2).forEach(s => {
                        const prefix = p.trim();
                        const suffix = s.trim();
                        const prefixPart = usePrefixSeparator ? `${prefix}${prefixSeparator}` : prefix;
                        const suffixPart = useSuffixSeparator ? `${suffixSeparator}${suffix}` : suffix;
                        examples.push(`${prefixPart}1${suffixPart}, ${prefixPart}2${suffixPart}`);
                    });
                });
                
                const previewEl = document.getElementById('prefixSuffixPreview');
                if (previewEl) previewEl.textContent = examples.slice(0, 3).join(', ');
            }
        }
        
        function testRegex() {
            const regex = document.getElementById('customRegex').value;
            const examples = document.getElementById('customExamples').value;
            const result = document.getElementById('regexTestResult');
            
            if (!regex) {
                result.textContent = 'Digite uma expressão regular';
                return;
            }
            
            try {
                const re = new RegExp(regex);
                const testValues = examples.split(',').map(s => s.trim());
                const results = testValues.map(val => ({
                    value: val,
                    matches: re.test(val)
                }));
                
                result.innerHTML = results.map(r => 
                    `${r.value}: ${r.matches ? '✅ OK' : '❌ Não corresponde'}`
                ).join('<br>');
            } catch (e) {
                result.textContent = '❌ Regex inválido: ' + e.message;
            }
        }
        
        async function saveNomenclature() {
            const type = document.querySelector('input[name="nomenclatureType"]:checked').value;
            
            let nomenclatureConfig = { type };
            
            if (type === 'numeric') {
                nomenclatureConfig = {
                    ...nomenclatureConfig,
                    min: parseInt(document.getElementById('numericMin').value),
                    max: parseInt(document.getElementById('numericMax').value),
                    usePadding: document.getElementById('usePadding').checked,
                    digits: parseInt(document.getElementById('numericDigits').value)
                };
            } else if (type === 'prefix') {
                nomenclatureConfig = {
                    ...nomenclatureConfig,
                    prefixes: document.getElementById('prefixText').value.split(',').map(s => s.trim()),
                    separator: document.getElementById('prefixSeparator').value,
                    useSeparator: document.getElementById('prefixUseSeparator').checked,
                    min: parseInt(document.getElementById('prefixMin').value),
                    max: parseInt(document.getElementById('prefixMax').value)
                };
            } else if (type === 'suffix') {
                nomenclatureConfig = {
                    ...nomenclatureConfig,
                    suffixes: document.getElementById('suffixText').value.split(',').map(s => s.trim()),
                    separator: document.getElementById('suffixSeparator').value,
                    useSeparator: document.getElementById('suffixUseSeparator').checked,
                    min: parseInt(document.getElementById('suffixMin').value),
                    max: parseInt(document.getElementById('suffixMax').value)
                };
            } else if (type === 'prefix-suffix') {
                nomenclatureConfig = {
                    ...nomenclatureConfig,
                    prefixes: document.getElementById('prefixSuffixPrefixText').value.split(',').map(s => s.trim()),
                    suffixes: document.getElementById('prefixSuffixSuffixText').value.split(',').map(s => s.trim()),
                    prefixSeparator: document.getElementById('prefixSuffixPrefixSeparator').value,
                    suffixSeparator: document.getElementById('prefixSuffixSuffixSeparator').value,
                    usePrefixSeparator: document.getElementById('prefixSuffixPrefixUseSeparator').checked,
                    useSuffixSeparator: document.getElementById('prefixSuffixSuffixUseSeparator').checked,
                    min: parseInt(document.getElementById('prefixSuffixMin').value),
                    max: parseInt(document.getElementById('prefixSuffixMax').value)
                };
            } else if (type === 'markers') {
                nomenclatureConfig = {
                    ...nomenclatureConfig,
                    startColor: document.getElementById('startColor').value,
                    endColor: document.getElementById('endColor').value,
                    tolerance: parseInt(document.getElementById('colorTolerance').value)
                };
            } else if (type === 'custom') {
                nomenclatureConfig = {
                    ...nomenclatureConfig,
                    regex: document.getElementById('customRegex').value,
                    examples: document.getElementById('customExamples').value
                };
            }
            
            // Salvar usando o método saveConfiguration
            if (window.supabaseClient) {
                const eventId = currentEvent ? currentEvent.id : null;
                await window.supabaseClient.saveConfiguration('dorsal_nomenclature', nomenclatureConfig, eventId);
                console.log('✅ Nomenclatura guardada:', nomenclatureConfig);
            }
            
            showSuccess('Nomenclatura configurada!');
            showStep(3);
        }
        
        function resetSteps() {
            showStep(1);
        }
        
        function showProgress(text, percentage) {
            const container = document.getElementById('progressContainer');
            const fill = document.getElementById('progressFill');
            const textEl = document.getElementById('progressText');
            
            container.style.display = 'block';
            fill.style.width = `${percentage}%`;
            textEl.textContent = text;
        }
        
        function updateProgress(percentage, text) {
            const fill = document.getElementById('progressFill');
            const textEl = document.getElementById('progressText');
            
            fill.style.width = `${percentage}%`;
            textEl.textContent = text;
        }
        
        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }
        
        function showSuccess(message) {
            showToast(message, 'success');
        }
        
        function showError(message) {
            showToast(message, 'error');
        }
        
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `
                <div class="toast-icon">${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}</div>
                <div class="toast-content">
                    <div class="toast-message">${message}</div>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 3000);
        }
    </script>
    
</body>
</html>

