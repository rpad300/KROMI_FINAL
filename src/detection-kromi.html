<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#fc6b03">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <title>Kromi.online - Detecção de Dorsais</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- KROMI Design System -->
    <link rel="stylesheet" href="/kromi-design-system.css">
    <link rel="stylesheet" href="/kromi-layout-fixes.css">
    <link rel="stylesheet" href="/kromi-mobile.css">
    <link rel="stylesheet" href="/kromi-mobile-ios.css">
    <link rel="stylesheet" href="/kromi-mobile-android.css">
    <link rel="stylesheet" href="/kromi-camera.css">
    
    <!-- Capability Detection -->
    <script src="/kromi-capability-detection.js"></script>
    
    <!-- Logo Integration Styles -->
    <link rel="stylesheet" href="/logo-integration.css?v=2025012701">
    
    <!-- Logo Loader (carregar antes de usar) -->
    <script src="/logo-loader.js?v=2025012702"></script>
    
    <style>
        /* Logo Container - Responsivo */
        .detection-logo-container {
            position: absolute;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .detection-logo-container img {
            width: auto;
            object-fit: contain;
        }
        
        /* Desktop e Mobile: Centro da tela */
        .detection-logo-container {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .detection-logo-container img {
            max-height: 80px;
        }
        
        /* Mobile: Ajustar tamanho */
        @media (max-width: 767px) {
            .detection-logo-container img {
                max-height: 60px;
            }
        }
    </style>
    
    <!-- Additional inline styles kept minimal for runtime overrides -->
</head>
<body data-theme="dark">
    <!-- Logo Container (Responsivo) -->
    <div class="detection-logo-container" id="detectionLogo"></div>
    
    <!-- Camera Container (Fullscreen) -->
    <div class="camera-container" id="cameraContainer">
        <!-- Camera Video -->
        <video id="cameraVideo" class="camera-video" autoplay muted playsinline></video>
        
        <!-- Camera Overlay -->
        <div class="camera-overlay" id="cameraOverlay">
            <!-- Detection areas will be added here -->
        </div>
        
        <!-- Camera Info -->
        <div class="camera-info">
            <div class="detection-stats" id="detectionStats">
                <div style="font-weight: 600; margin-bottom: var(--spacing-1);">📊 Detecções</div>
                <div id="detectionCount">0</div>
            </div>
            
            <div class="event-info" id="eventInfo">
                <div style="font-weight: 600; margin-bottom: var(--spacing-1);">🏃 Evento</div>
                <div id="eventName">Nenhum evento selecionado</div>
                <div id="eventDate" style="font-size: 0.85em; opacity: 0.8; margin-top: 4px;">-</div>
                <div id="checkpointType" style="font-size: 0.85em; opacity: 0.8; margin-top: 4px;">-</div>
                <div id="deviceOrder" style="font-size: 0.85em; opacity: 0.6;">#-</div>
            </div>
            
        </div>
        
        <!-- Bottom Controls (todos na parte inferior) -->
        <div class="bottom-controls">
            <button class="btn btn-sm btn-warning" id="toggleFlash" title="Alternar Flash">
                <i>⚡</i> <span class="btn-text">Flash</span>
            </button>
            <button class="btn btn-sm btn-danger" id="switchCamera" title="Trocar Câmera">
                <i>🔄</i> <span class="btn-text">Trocar</span>
            </button>
            <button class="btn btn-sm" id="toggleSoundBtn" title="Alternar Som" style="display: inline-flex;">
                <i>🔊</i> <span class="btn-text">Som</span>
            </button>
            <button class="btn btn-sm btn-danger" id="endSessionBtn" onclick="endSession()" style="display: none;" title="Terminar Sessão">
                <i>🚪</i> <span class="btn-text">Sair</span>
            </button>
        </div>
        
        <!-- Main Camera Controls (Center Bottom) -->
        <div class="main-camera-controls">
            <button class="btn btn-lg btn-primary" id="startDetection">
                <i>▶️</i> Iniciar Detecção
            </button>
            <button class="btn btn-lg btn-secondary" id="stopDetection" style="display: none;">
                <i>⏹️</i> Parar Detecção
            </button>
        </div>
    </div>
    
    <!-- Permission Panel -->
    <!-- PIN Panel (aparece primeiro) -->
    <div class="permission-panel" id="pinPanel" style="display: none;">
        <div class="permission-content">
            <h3>🔐 PIN de Segurança</h3>
            <p>Digite o PIN do dispositivo para acessar a detecção.</p>
            <form id="pinForm" onsubmit="event.preventDefault(); document.getElementById('validatePin').click();">
                <!-- Campo username oculto para acessibilidade (recomendação do Chrome) -->
                <input type="text" name="username" autocomplete="username" value="device-pin" style="position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0; pointer-events: none;" tabindex="-1" aria-hidden="true">
                
                <div style="margin: var(--spacing-5) 0;">
                    <input type="password" inputmode="numeric" pattern="[0-9]*" maxlength="6" id="pinInput" 
                        placeholder="Digite o PIN"
                        autocomplete="current-password"
                        name="password"
                        style="width: 100%; padding: var(--spacing-4); font-size: var(--font-size-2xl); text-align: center; background: var(--bg-primary); border: 2px solid var(--border-color); border-radius: var(--radius-lg); color: var(--text-primary); font-weight: 700; letter-spacing: 8px;">
                    <div id="pinError" style="color: var(--danger); margin-top: var(--spacing-2); font-size: var(--font-size-sm); text-align: center; display: none;"></div>
                </div>
                <div class="permission-actions">
                    <button type="submit" class="btn btn-primary" id="validatePin">
                        <i>🔓</i> Validar PIN
                    </button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Camera Permission Panel (aparece depois do PIN) -->
    <div class="permission-panel" id="permissionPanel" style="display: none;">
        <div class="permission-content">
            <h3>📷 Acesso à Câmera</h3>
            <p>O Kromi.online precisa acessar sua câmera para detectar dorsais automaticamente.</p>
            <div class="permission-actions">
                <button class="btn btn-primary" id="requestCamera">
                    <i>📷</i> Permitir Câmera
                </button>
            </div>
        </div>
    </div>
    
    <!-- Scripts -->
    <script src="https://unpkg.com/@supabase/supabase-js@2" defer></script>
    <script src="/supabase.js?v=2025102605" defer></script>
    <script src="/auth-client.js?v=2025102616" defer></script>
    <script src="/auth-helper.js?v=2025102620" defer></script>
    
    <!-- Detection Logic -->
    <script>
        // Global variables
        let cameraStream = null;
        let isDetecting = false;
        let detectionCount = 0;
        let currentEvent = null;
        let currentDevice = null;
        let sessionId = null;
        let captureInterval = null;
        let motionCheckInterval = null;
        let currentPosition = null;
        let devicePin = null;
        let pinValidated = false;
        let soundEnabled = true; // Som habilitado por padrão
        let detectionSound = null; // Audio object para som de detecção
        let facingMode = 'environment'; // 'environment' (traseira) ou 'user' (frontal)
        let lastFrame = null; // Para detecção de movimento
        let motionDetected = false; // Flag para indicar se há movimento
        let motionThreshold = 50; // Sensibilidade do movimento (0-255)
        let consecutiveMotionFrames = 0; // Contador de frames com movimento
        let minMotionFrames = 5; // Número mínimo de frames com movimento para considerar detecção
        let wakeLock = null; // Para prevenir suspensão do dispositivo
        
        // Carregar logo
        async function loadDetectionLogo() {
            const logoContainer = document.getElementById('detectionLogo');
            if (!logoContainer) return;
            
            // Aguardar logoLoader estar disponível
            let attempts = 0;
            const maxAttempts = 50;
            
            const tryLoad = async () => {
                if (typeof window.logoLoader !== 'undefined' && window.logoLoader && typeof window.logoLoader.renderLogo === 'function') {
                    try {
                        await window.logoLoader.renderLogo(logoContainer, {
                            type: 'secondary', // Logo monocromático para fundos escuros
                            orientation: 'horizontal',
                            alt: 'Kromi.online',
                            className: 'detection-logo',
                            style: {
                                maxHeight: window.innerWidth >= 768 ? '80px' : '60px',
                                width: 'auto',
                                display: 'block'
                            },
                            fallback: '<h2 style="color: #fc6b03; font-size: 24px; margin: 0;">Kromi.online</h2>'
                        });
                        console.log('[DETECTION] Logo carregado');
                    } catch (error) {
                        console.warn('[DETECTION] Erro ao carregar logo:', error);
                    }
                    return true;
                }
                
                attempts++;
                if (attempts < maxAttempts) {
                    setTimeout(tryLoad, 100);
                }
            };
            
            // Aguardar um pouco antes de começar
            setTimeout(tryLoad, 300);
        }
        
        // Initialize page
        document.addEventListener('DOMContentLoaded', async () => {
            // Carregar logo
            loadDetectionLogo();
            
            // Initialize Supabase
            if (window.supabaseClient) {
                await window.supabaseClient.init();
            }
            
            // Get URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const eventId = urlParams.get('event');
            let deviceId = urlParams.get('device');
            const eventName = urlParams.get('eventName');
            
            console.log('🔗 Parâmetros URL:');
            console.log('  Event:', eventId);
            console.log('  Device:', deviceId);
            console.log('  EventName:', eventName);
            
            // Se não tem deviceId, buscar primeiro dispositivo do evento
            if (eventId && !deviceId) {
                console.log('⚠️ Device ID não especificado, buscando dispositivos do evento...');
                
                const { data: devices, error } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .select('device_id, checkpoint_name, checkpoint_type, checkpoint_order')
                    .eq('event_id', eventId)
                    .order('checkpoint_order', { ascending: true })
                    .limit(1);
                
                if (devices && devices.length > 0) {
                    deviceId = devices[0].device_id;
                    console.log('✅ Usando primeiro dispositivo:', deviceId, devices[0].checkpoint_name);
                    
                    // Atualizar URL
                    const newUrl = new URL(window.location);
                    newUrl.searchParams.set('device', deviceId);
                    window.history.replaceState({}, '', newUrl);
                } else {
                    console.error('❌ Nenhum dispositivo encontrado para este evento');
                    showError('Nenhum dispositivo configurado para este evento. Configure em /devices');
                    setTimeout(() => window.location.href = `/devices?event=${eventId}&eventName=${eventName}`, 3000);
                    return;
                }
            }
            
            currentEvent = { id: eventId, name: eventName || null };
            currentDevice = deviceId;
            sessionId = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            console.log('🔗 Parâmetros finais:');
            console.log('  Event:', eventId);
            console.log('  Device:', deviceId);
            console.log('  Session:', sessionId);
            console.log('  EventName da URL:', eventName);
            
            if (eventId) {
                await loadEventInfo(eventId, eventName);
            }
            
            // Register device
            if (eventId && deviceId) {
                await registerDevice(eventId, deviceId);
            }
            
            // NÃO chamar getCurrentLocation() aqui - será chamado após interação do usuário
            // Isso evita violação de política do navegador
            
            // Setup event listeners
            setupEventListeners();
            
            // Request PIN sempre (se tem device)
            console.log('🔐 Verificando se deve pedir PIN...');
            console.log('  currentDevice:', currentDevice);
            
            if (currentDevice) {
                console.log('✅ Device especificado, pedindo PIN...');
                await requestDevicePin();
            } else {
                console.error('❌ Device não especificado');
                showError('Dispositivo não especificado');
                setTimeout(() => window.location.href = '/events', 3000);
            }
            
            console.log('✅ Inicialização completa');
        });
        
        function setupEventListeners() {
            // PIN validation
            document.getElementById('validatePin')?.addEventListener('click', validatePin);
            document.getElementById('pinInput')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    validatePin();
                }
            });
            
            // Camera permission
            document.getElementById('requestCamera').addEventListener('click', startCamera);
            
            // Detection controls - COM VERIFICAÇÕES DE SEGURANÇA E DELAY
            setTimeout(() => {
                const startDetectionBtn = document.getElementById('startDetection');
                const stopDetectionBtn = document.getElementById('stopDetection');
                const switchCameraBtn = document.getElementById('switchCamera');
                const toggleFlashBtn = document.getElementById('toggleFlash');
                const toggleSoundBtn = document.getElementById('toggleSoundBtn');
                const endSessionBtn = document.getElementById('endSessionBtn');
                
                console.log('🔍 Procurando botões...');
                console.log('startDetectionBtn:', startDetectionBtn);
                console.log('stopDetectionBtn:', stopDetectionBtn);
                console.log('switchCameraBtn:', switchCameraBtn);
                console.log('toggleFlashBtn:', toggleFlashBtn);
                console.log('toggleSoundBtn:', toggleSoundBtn);
                console.log('endSessionBtn:', endSessionBtn);
                
                if (startDetectionBtn) {
                    startDetectionBtn.addEventListener('click', startDetection);
                    console.log('✅ Event listener adicionado: startDetection');
                } else {
                    console.error('❌ Botão startDetection não encontrado');
                }
                
                if (stopDetectionBtn) {
                    stopDetectionBtn.addEventListener('click', stopDetection);
                    console.log('✅ Event listener adicionado: stopDetection');
                } else {
                    console.error('❌ Botão stopDetection não encontrado');
                }
                
                if (switchCameraBtn) {
                    switchCameraBtn.addEventListener('click', switchCamera);
                    console.log('✅ Event listener adicionado: switchCamera');
                } else {
                    console.error('❌ Botão switchCamera não encontrado');
                }
                
                if (toggleFlashBtn) {
                    toggleFlashBtn.addEventListener('click', toggleFlash);
                    console.log('✅ Event listener adicionado: toggleFlash');
                } else {
                    console.error('❌ Botão toggleFlash não encontrado');
                }
                
                if (toggleSoundBtn) {
                    toggleSoundBtn.addEventListener('click', toggleSound);
                    console.log('✅ Event listener adicionado: toggleSound');
                } else {
                    console.error('❌ Botão toggleSound não encontrado');
                }
                
                if (endSessionBtn) {
                    // Remove onclick inline e adiciona event listener
                    endSessionBtn.removeAttribute('onclick');
                    endSessionBtn.addEventListener('click', endSession);
                    console.log('✅ Event listener adicionado: endSessionBtn');
                } else {
                    console.error('❌ Botão endSessionBtn não encontrado');
                }
            }, 100);
            
            // Criar som de detecção
            initDetectionSound();
            
            // Inicializar estado do botão de som
            const soundBtn = document.getElementById('toggleSoundBtn');
            if (soundBtn && soundEnabled) {
                soundBtn.innerHTML = '<i>🔊</i> <span class="btn-text">Som</span>';
                soundBtn.classList.add('btn-success');
            }
            
            // Prevenir suspensão do dispositivo (Wake Lock)
            requestWakeLock();
            
            // Detectar quando a página volta ao foco
            document.addEventListener('visibilitychange', async () => {
                if (document.hidden) {
                    console.log('📱 Página em background - suspendendo Wake Lock');
                    releaseWakeLock();
                } else {
                    console.log('📱 Página visível - reativando Wake Lock');
                    requestWakeLock();
                }
            });
            
            // Fullscreen toggle (removed - no header button)
        }
        
        async function requestDevicePin() {
            try {
                console.log('🔐 requestDevicePin: Iniciando...');
                console.log('  Event ID:', currentEvent.id);
                console.log('  Device ID:', currentDevice);
                
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    console.error('❌ Supabase não disponível');
                    showError('Supabase não conectado');
                    return;
                }
                
                console.log('📊 Buscando dados do dispositivo no Supabase...');
                
                // Carregar dados do dispositivo (PIN e limites de sessão)
                const { data: deviceData, error } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .select('device_pin, checkpoint_name, checkpoint_type, checkpoint_order, max_sessions, active_sessions')
                    .eq('event_id', currentEvent.id)
                    .eq('device_id', currentDevice)
                    .single();
                
                console.log('📊 Resultado:');
                console.log('  Data:', deviceData);
                console.log('  Error:', error);
                
                if (error || !deviceData) {
                    console.warn('⚠️ Device não encontrado, pulando PIN');
                    console.warn('  Possível causa: device não está em event_devices');
                    console.warn('  Execute: SELECT * FROM event_devices WHERE device_id = \'' + currentDevice + '\'');
                    requestCameraPermission();
                    return;
                }
                
                console.log('✅ Device encontrado:', deviceData);
                
                // Verificar limite de sessões
                const activeSessions = deviceData.active_sessions || 0;
                const maxSessions = deviceData.max_sessions || 1;
                
                console.log(`📊 Sessões: ${activeSessions}/${maxSessions}`);
                console.log(`📊 Verificando limite: ${activeSessions} >= ${maxSessions} ?`);
                console.log(`📊 Resultado: ${activeSessions >= maxSessions}`);
                
                devicePin = deviceData.device_pin;
                
                // Se limite atingido, mostrar modal de conflito
                if (activeSessions >= maxSessions) {
                    console.error('❌❌❌ LIMITE DE SESSÕES ATINGIDO! ❌❌❌');
                    console.error(`  Ativas: ${activeSessions}`);
                    console.error(`  Máximo: ${maxSessions}`);
                    
                    // Mostrar modal de confirmação com PIN para libertar sessão
                    await showSessionConflictModal(deviceData);
                    return;
                }
                
                console.log('🔐 PIN requerido para este dispositivo');
                console.log('  PIN existe:', !!devicePin);
                console.log('  PIN valor:', devicePin ? '****' : 'Nenhum');
                console.log('📍 Checkpoint:', deviceData.checkpoint_name || 'Não configurado');
                
                // Se não tem PIN configurado, ir direto para câmera
                if (!devicePin) {
                    console.log('⚠️ Dispositivo sem PIN, pulando validação');
                    requestCameraPermission();
                    return;
                }
                
                // Mostrar tela de PIN
                console.log('🔐 Mostrando tela de PIN...');
                const pinPanel = document.getElementById('pinPanel');
                if (pinPanel) {
                    pinPanel.style.display = 'flex';
                    console.log('✅ Tela de PIN exibida');
                } else {
                    console.error('❌ Elemento pinPanel não encontrado');
                }
                
                // Focus no input
                setTimeout(() => {
                    const pinInput = document.getElementById('pinInput');
                    if (pinInput) {
                        pinInput.focus();
                        console.log('✅ Focus no input PIN');
                    } else {
                        console.error('❌ Input PIN não encontrado');
                    }
                }, 300);
                
            } catch (error) {
                console.error('❌ Erro ao carregar PIN:', error);
                // Se falhar, permitir acesso
                requestCameraPermission();
            }
        }
        
        async function showSessionConflictModal(deviceData) {
            return new Promise((resolve) => {
                // Criar modal de confirmação
                const modal = document.createElement('div');
                modal.id = 'sessionConflictModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.9);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    padding: var(--spacing-4);
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: var(--bg-secondary);
                        border-radius: var(--radius-lg);
                        padding: var(--spacing-6);
                        max-width: 500px;
                        width: 100%;
                        box-shadow: var(--shadow-2xl);
                    ">
                        <h2 style="color: var(--danger); margin: 0 0 var(--spacing-4) 0; display: flex; align-items: center; gap: var(--spacing-2);">
                            <span style="font-size: 2rem;">⚠️</span>
                            Dispositivo em Uso
                        </h2>
                        
                        <p style="color: var(--text-primary); margin: 0 0 var(--spacing-4) 0; line-height: 1.6;">
                            Este dispositivo já tem <strong>${deviceData.active_sessions}</strong> sessão(ões) ativa(s).<br>
                            Limite máximo: <strong>${deviceData.max_sessions}</strong> sessão(ões).
                        </p>
                        
                        <div style="background: rgba(252, 107, 3, 0.1); padding: var(--spacing-4); border-radius: var(--radius-base); border-left: 3px solid var(--primary); margin: 0 0 var(--spacing-5) 0;">
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--font-size-sm);">
                                <strong>🔐 Tem a certeza que deseja assumir este dispositivo?</strong><br><br>
                                Para libertar a sessão atual e criar uma nova, introduza o PIN do dispositivo:
                            </p>
                        </div>
                        
                        <form id="conflictPinForm" onsubmit="event.preventDefault(); document.getElementById('confirmReleaseBtn').click();">
                            <!-- Campo username oculto para acessibilidade (recomendação do Chrome) -->
                            <input type="text" name="username" autocomplete="username" value="device-pin" style="position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0; pointer-events: none;" tabindex="-1" aria-hidden="true">
                            
                            <div style="margin: 0 0 var(--spacing-4) 0;">
                                <input 
                                    type="password" 
                                    id="conflictPinInput"
                                    name="password"
                                    placeholder="Digite o PIN do dispositivo"
                                    autocomplete="current-password"
                                    style="
                                        width: 100%;
                                        padding: var(--spacing-3);
                                        font-size: var(--font-size-lg);
                                        text-align: center;
                                        letter-spacing: 0.5em;
                                        border: 2px solid var(--border-color);
                                        border-radius: var(--radius-base);
                                        background: var(--bg-primary);
                                        color: var(--text-primary);
                                    "
                                />
                                <div id="conflictPinError" style="color: var(--danger); margin-top: var(--spacing-2); display: none;"></div>
                            </div>
                            
                            <div style="display: flex; gap: var(--spacing-3);">
                                <button 
                                    type="submit"
                                    id="confirmReleaseBtn"
                                    class="btn btn-primary"
                                    style="flex: 1;"
                                >
                                    🔓 Libertar e Assumir
                                </button>
                                <button 
                                    type="button"
                                    id="cancelReleaseBtn"
                                    class="btn btn-secondary"
                                    style="flex: 1;"
                                >
                                    ❌ Cancelar
                                </button>
                            </div>
                        </form>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                const pinInput = modal.querySelector('#conflictPinInput');
                const errorDiv = modal.querySelector('#conflictPinError');
                const confirmBtn = modal.querySelector('#confirmReleaseBtn');
                const cancelBtn = modal.querySelector('#cancelReleaseBtn');
                
                pinInput.focus();
                
                // Enter no input = confirmar
                pinInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        confirmBtn.click();
                    }
                });
                
                // Confirmar com PIN
                confirmBtn.addEventListener('click', async () => {
                    const inputPin = pinInput.value.trim();
                    
                    if (!inputPin) {
                        errorDiv.textContent = '⚠️ Digite o PIN do dispositivo';
                        errorDiv.style.display = 'block';
                        return;
                    }
                    
                    if (inputPin !== deviceData.device_pin) {
                        errorDiv.textContent = '❌ PIN incorreto. Tente novamente.';
                        errorDiv.style.display = 'block';
                        pinInput.value = '';
                        pinInput.focus();
                        return;
                    }
                    
                    // PIN correto! Libertar sessões antigas
                    confirmBtn.disabled = true;
                    confirmBtn.innerHTML = '⏳ Libertando sessão...';
                    
                    // Libertar todas as sessões deste dispositivo
                    await releaseAllDeviceSessions();
                    
                    // Remover modal
                    modal.remove();
                    
                    // Continuar com fluxo normal - criar sessão e iniciar câmera
                    console.log('🔄 Após liberação no modal, continuando com fluxo...');
                    
                    // Marcar PIN como validado
                    pinValidated = true;
                    
                    // Criar sessão
                    const sessionCreated = await createDeviceSession();
                    
                    if (sessionCreated) {
                        console.log('✅ Sessão criada após liberação no modal');
                        
                        // Esconder tela de PIN (se estiver visível)
                        document.getElementById('pinPanel').style.display = 'none';
                        
                        // Mostrar botão de terminar sessão
                        const endBtn = document.getElementById('endSessionBtn');
                        if (endBtn) endBtn.style.display = 'inline-flex';
                        
                        // Mostrar tela de permissão de câmera
                        requestCameraPermission();
                        
                        // Iniciar heartbeat
                        startSessionHeartbeat();
                    } else {
                        console.error('❌ Falha ao criar sessão após liberação');
                        showError('Erro ao criar sessão. Tente novamente.');
                    }
                    
                    resolve(true);
                });
                
                // Cancelar
                cancelBtn.addEventListener('click', () => {
                    modal.remove();
                    resolve(false);
                    setTimeout(() => window.history.back(), 500);
                });
            });
        }
        
        async function releaseAllDeviceSessions() {
            try {
                console.log('🔓 Libertando todas as sessões do dispositivo...');
                
                // Zerar contador de sessões ativas
                const { error } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .update({ active_sessions: 0 })
                    .eq('event_id', currentEvent.id)
                    .eq('device_id', currentDevice);
                
                if (error) {
                    console.error('❌ Erro ao libertar sessões:', error);
                } else {
                    console.log('✅ Contador de sessões resetado');
                }
                
                // IMPORTANTE: Limpar tabela device_sessions (sessões órfãs)
                try {
                    console.log('🧹 Limpando sessões órfãs na tabela device_sessions...');
                    const { error: deleteError } = await window.supabaseClient.supabase
                        .from('device_sessions')
                        .delete()
                        .eq('device_id', currentDevice)
                        .eq('event_id', currentEvent.id);
                    
                    if (deleteError) {
                        console.error('❌ Erro ao limpar device_sessions:', deleteError);
                    } else {
                        console.log('✅ Sessões órfãs removidas de device_sessions');
                    }
                } catch (deleteErr) {
                    console.error('❌ Erro ao limpar device_sessions:', deleteErr);
                }
                
                // Se existir função RPC para limpar sessões (opcional)
                // Nota: Esta função pode não existir no Supabase, então não é crítico
                // Verificamos se existe antes de chamar para evitar erro 404 no console
                try {
                    const { data, error } = await window.supabaseClient.supabase
                        .rpc('end_all_device_sessions', {
                            p_device_id: currentDevice,
                            p_event_id: currentEvent.id
                        });
                    
                    if (error) {
                        // Se erro 404 ou função não encontrada, ignorar silenciosamente
                        const isNotFound = error.code === 'P0004' || 
                                         error.code === '42883' || 
                                         error.message?.toLowerCase().includes('function') || 
                                         error.message?.toLowerCase().includes('not found') ||
                                         error.message?.toLowerCase().includes('does not exist');
                        
                        if (isNotFound) {
                            // Função não existe - comportamento esperado, não logar
                            return;
                        } else {
                            // Outro tipo de erro - pode ser relevante
                            console.warn('⚠️ Erro ao executar RPC end_all_device_sessions:', error.message);
                        }
                    } else if (data) {
                        console.log('✅ RPC end_all_device_sessions executada');
                    }
                } catch (rpcError) {
                    // Ignorar silenciosamente se função não existe
                    // Erros de rede ou outros erros críticos já serão tratados acima
                    const errorMsg = rpcError?.message?.toLowerCase() || '';
                    if (!errorMsg.includes('not found') && !errorMsg.includes('function')) {
                        // Só logar se não for erro de função não encontrada
                        console.warn('⚠️ Erro ao chamar RPC:', rpcError.message);
                    }
                }
                
            } catch (error) {
                console.error('❌ Erro ao libertar sessões:', error);
            }
        }
        
        async function validatePin() {
            const inputPin = document.getElementById('pinInput').value;
            const errorDiv = document.getElementById('pinError');
            
            if (!inputPin) {
                errorDiv.textContent = 'Digite o PIN';
                errorDiv.style.display = 'block';
                return;
            }
            
            if (inputPin === devicePin) {
                // PIN correto! Tentar iniciar sessão
                console.log('✅ PIN validado com sucesso');
                pinValidated = true;
                
                // Obter localização GPS após gesto do usuário (validar PIN)
                if (!currentPosition) {
                    await getCurrentLocation();
                }
                
                // Criar sessão no Supabase
                const sessionCreated = await createDeviceSession();
                
                if (!sessionCreated) {
                    errorDiv.textContent = '❌ Limite de sessões atingido. Aguarde.';
                    errorDiv.style.display = 'block';
                    return;
                }
                
                // Esconder tela de PIN
                document.getElementById('pinPanel').style.display = 'none';
                
                // Mostrar botão terminar sessão
                const endBtn = document.getElementById('endSessionBtn');
                if (endBtn) endBtn.style.display = 'inline-flex';
                
                // Mostrar tela de permissão de câmera
                requestCameraPermission();
                
                // Iniciar heartbeat
                startSessionHeartbeat();
                
            } else {
                // PIN errado
                console.error('❌ PIN incorreto');
                errorDiv.textContent = '❌ PIN incorreto. Tente novamente.';
                errorDiv.style.display = 'block';
                
                // Limpar input
                document.getElementById('pinInput').value = '';
                document.getElementById('pinInput').focus();
                
                // Shake animation
                const panel = document.querySelector('#pinPanel .permission-content');
                panel.style.animation = 'shake 0.5s';
                setTimeout(() => {
                    panel.style.animation = '';
                }, 500);
            }
        }
        
        async function cleanupInactiveSessions() {
            try {
                console.log('🧹 Limpando sessões inativas...');
                
                const { data, error } = await window.supabaseClient.supabase
                    .rpc('cleanup_inactive_sessions');
                
                if (error) {
                    console.error('❌ Erro ao limpar:', error);
                    showError('Erro ao limpar sessões');
                    return false;
                }
                
                console.log(`✅ ${data || 0} sessões inativas removidas`);
                alert(`✅ ${data || 0} sessões inativas foram removidas. Tente novamente.`);
                return true;
                
            } catch (error) {
                console.error('❌ Erro:', error);
                showError('Função cleanup não disponível. Execute add-device-sessions.sql');
                return false;
            }
        }
        
        async function createDeviceSession() {
            try {
                console.log('🔄 Criando sessão...');
                
                const { data, error } = await window.supabaseClient.supabase
                    .rpc('start_device_session', {
                        p_event_id: currentEvent.id,
                        p_device_id: currentDevice,
                        p_session_id: sessionId,
                        p_user_agent: navigator.userAgent
                    });
                
                console.log('📊 Resultado criar sessão:');
                console.log('  Data:', data);
                console.log('  Error:', error);
                
                if (error) {
                    console.error('❌ Erro ao criar sessão:', error);
                    console.error('  Possível causa: Função start_device_session não existe');
                    console.error('  Execute: add-device-sessions.sql no Supabase');
                    
                    // Permitir acesso mesmo sem sessões (fallback)
                    console.warn('⚠️ Continuando sem controle de sessões...');
                    return true;
                }
                
                if (!data?.success) {
                    console.error('❌ Sessão não criada:', data);
                    if (data?.error === 'Max sessions exceeded') {
                        // Mostrar modal de conflito para libertar sessões
                        console.log('⚠️ Limite atingido - mostrando modal de conflito...');
                        
                        // Buscar dados completos do dispositivo para o modal
                        const { data: deviceData } = await window.supabaseClient.supabase
                            .from('event_devices')
                            .select('device_pin, checkpoint_name, checkpoint_type, checkpoint_order, max_sessions, active_sessions')
                            .eq('event_id', currentEvent.id)
                            .eq('device_id', currentDevice)
                            .single();
                        
                        if (deviceData) {
                            // Mostrar modal e aguardar confirmação
                            const confirmed = await showSessionConflictModal(deviceData);
                            
                            if (confirmed) {
                                // Usuário confirmou com PIN, tentar criar sessão novamente
                                console.log('🔄 Tentando criar sessão após liberação no modal...');
                                const retryResult = await window.supabaseClient.supabase.rpc('start_device_session', {
                                    p_event_id: currentEvent.id,
                                    p_device_id: currentDevice,
                                    p_session_id: sessionId,
                                    p_user_agent: navigator.userAgent
                                });
                                
                                if (retryResult.data?.success) {
                                    console.log('✅ Sessão criada após liberação!');
                                    return true;
                                } else {
                                    console.error('❌ Ainda falhou:', retryResult.data);
                                    showError(`Limite de ${data.max_allowed} sessões atingido!`);
                                    return false;
                                }
                            } else {
                                // Usuário cancelou
                                console.log('❌ Liberação cancelada pelo usuário');
                                return false;
                            }
                        } else {
                            showError(`Limite de ${data.max_allowed} sessões atingido!`);
                            return false;
                        }
                    }
                    return false;
                }
                
                console.log('✅ Sessão criada com sucesso!');
                console.log(`  Sessão ID: ${data.session_id}`);
                console.log(`  Ativas agora: ${data.current_active}/${data.max_allowed}`);
                return true;
                
            } catch (error) {
                console.error('❌ Erro geral:', error);
                // Permitir acesso em caso de erro (para não bloquear)
                return true;
            }
        }
        
        function startSessionHeartbeat() {
            // Enviar heartbeat a cada 30 segundos
            setInterval(async () => {
                try {
                    await window.supabaseClient.supabase
                        .rpc('update_session_heartbeat', {
                            p_session_id: sessionId
                        });
                    console.log('💓 Heartbeat enviado');
                } catch (error) {
                    console.error('❌ Erro no heartbeat:', error);
                }
            }, 30000);
        }
        
        // Função para prevenir suspensão do dispositivo (Wake Lock API)
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('🔒 Wake Lock ativado - dispositivo não entrará em suspensão');
                    
                    // Detectar quando o Wake Lock é liberado (ex: tela bloqueada)
                    wakeLock.addEventListener('release', () => {
                        console.log('🔓 Wake Lock liberado - dispositivo pode suspender');
                    });
                } else {
                    console.warn('⚠️ Wake Lock API não suportada neste navegador');
                }
            } catch (error) {
                console.warn('⚠️ Não foi possível ativar Wake Lock:', error.message);
            }
        }
        
        // Função para liberar Wake Lock
        async function releaseWakeLock() {
            try {
                if (wakeLock && 'wakeLock' in navigator) {
                    await wakeLock.release();
                    wakeLock = null;
                    console.log('🔓 Wake Lock liberado manualmente');
                }
            } catch (error) {
                console.warn('⚠️ Erro ao liberar Wake Lock:', error.message);
            }
        }
        
        async function endSession() {
            if (!confirm('Tem certeza que deseja terminar a sessão? Isto irá libertar o dispositivo para outro operador.')) {
                return;
            }
            
            // Liberar Wake Lock ao terminar sessão
            await releaseWakeLock();
            
            try {
                console.log('🚪 Encerrando sessão...');
                console.log('  Session ID:', sessionId);
                console.log('  Device ID:', currentDevice);
                console.log('  Event ID:', currentEvent.id);
                
                // Parar detecção se estiver ativa
                if (isDetecting) {
                    stopDetection();
                    console.log('✅ Detecção parada');
                }
                
                // Parar câmera
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                    console.log('✅ Câmera desligada');
                }
                
                // DECREMENTAR active_sessions MANUALMENTE (fallback se função não existir)
                console.log('📉 Decrementando active_sessions...');
                const { error: decrementError } = await window.supabaseClient.supabase
                    .rpc('decrement', {
                        table_name: 'event_devices',
                        column_name: 'active_sessions',
                        row_id: null
                    });
                
                // Alternativa: UPDATE direto
                const { data: currentData } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .select('active_sessions')
                    .eq('event_id', currentEvent.id)
                    .eq('device_id', currentDevice)
                    .single();
                
                const newCount = Math.max(0, (currentData?.active_sessions || 1) - 1);
                
                console.log(`📉 Atualizando: ${currentData?.active_sessions} → ${newCount}`);
                
                const { error: updateError } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .update({ active_sessions: newCount })
                    .eq('event_id', currentEvent.id)
                    .eq('device_id', currentDevice);
                
                if (updateError) {
                    console.error('❌ Erro ao decrementar:', updateError);
                } else {
                    console.log('✅ Contador decrementado');
                }
                
                // Encerrar sessão no Supabase (se função existir)
                if (sessionId && pinValidated) {
                    try {
                        console.log('🔄 Chamando end_device_session com sessionId:', sessionId);
                        const { data, error } = await window.supabaseClient.supabase
                            .rpc('end_device_session', {
                                p_session_id: sessionId
                            });
                        
                        if (error) {
                            console.error('❌ Erro ao encerrar sessão via RPC:', error);
                        } else {
                            console.log('✅ Sessão encerrada via RPC:', data);
                        }
                    } catch (rpcError) {
                        console.error('❌ Erro ao chamar RPC end_device_session:', rpcError);
                    }
                } else {
                    console.warn('⚠️ sessionId ou pinValidated não disponível:', { sessionId, pinValidated });
                }
                
                // Limpar sessões inativas
                try {
                    console.log('🧹 Limpando sessões inativas...');
                    const { data: cleanupData, error: cleanupError } = await window.supabaseClient.supabase
                        .rpc('cleanup_inactive_sessions');
                    
                    if (cleanupError) {
                        console.error('❌ Erro ao limpar sessões inativas:', cleanupError);
                    } else {
                        console.log('✅ Sessões inativas limpas:', cleanupData);
                    }
                } catch (cleanupRpcError) {
                    console.error('❌ Erro ao chamar cleanup_inactive_sessions:', cleanupRpcError);
                }
                
                // Mostrar mensagem
                alert('✅ Sessão encerrada com sucesso! O dispositivo foi libertado.');
                
                // Redirecionar para a página de scanner
                window.location.href = '/detections-kromi.html';
                
            } catch (error) {
                console.error('❌ Erro ao encerrar sessão:', error);
                showError('Erro ao encerrar sessão');
            }
        }
        
        // Encerrar sessão ao sair (automático)
        window.addEventListener('beforeunload', async (e) => {
            if (sessionId && pinValidated) {
                // Libertar dispositivo automaticamente
                await releaseDeviceOnExit();
            }
        });
        
        async function releaseDeviceOnExit() {
            try {
                console.log('🚪 Libertando dispositivo ao sair...');
                
                // Parar detecção
                if (isDetecting) {
                    stopDetection();
                }
                
                // Parar câmera
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                }
                
                // Decrementar sessões ativas usando sendBeacon para garantir
                const updateData = {
                    event_id: currentEvent.id,
                    device_id: currentDevice
                };
                
                // Tentar via sendBeacon primeiro
                try {
                    const { data: currentData } = await window.supabaseClient.supabase
                        .from('event_devices')
                        .select('active_sessions')
                        .eq('event_id', currentEvent.id)
                        .eq('device_id', currentDevice)
                        .single();
                    
                    const newCount = Math.max(0, (currentData?.active_sessions || 1) - 1);
                    
                    await window.supabaseClient.supabase
                        .from('event_devices')
                        .update({ active_sessions: newCount })
                        .eq('event_id', currentEvent.id)
                        .eq('device_id', currentDevice);
                    
                    console.log(`✅ Dispositivo libertado (sessões: ${currentData?.active_sessions} → ${newCount})`);
                } catch (error) {
                    console.error('❌ Erro ao libertar:', error);
                }
                
            } catch (error) {
                console.error('❌ Erro em releaseDeviceOnExit:', error);
            }
        }
        
        function requestCameraPermission() {
            // Show permission panel
            document.getElementById('permissionPanel').style.display = 'flex';
        }
        
        async function startCamera() {
            try {
                // Hide permission panel
                document.getElementById('permissionPanel').style.display = 'none';
                
                console.log('📷 Iniciando câmera com facingMode:', facingMode);
                
                // Request camera access
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: facingMode, // Usar variável global
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                
                // Set video source
                const video = document.getElementById('cameraVideo');
                video.srcObject = cameraStream;
                
                console.log('✅ Câmera iniciada:', facingMode === 'environment' ? 'Traseira' : 'Frontal');
                
                // Show detection area
                setupDetectionArea();
                
            } catch (error) {
                console.error('❌ Erro ao acessar câmera:', error);
                showError('Não foi possível acessar a câmera. Verifique as permissões.');
            }
        }
        
        function setupDetectionArea() {
            const overlay = document.getElementById('cameraOverlay');
            const detectionArea = document.createElement('div');
            detectionArea.className = 'detection-area';
            detectionArea.id = 'detectionArea';
            
            // Não precisa definir posição - CSS já centraliza automaticamente
            // usando left: 50%, top: 50%, transform: translate(-50%, -50%)
            
            overlay.appendChild(detectionArea);
        }
        
        async function startDetection() {
            console.log('🎯 startDetection() chamada');
            
            if (!cameraStream) {
                console.error('❌ Câmera não iniciada');
                showError('Câmera não iniciada');
                return;
            }
            
            // Obter localização GPS após gesto do usuário (iniciar detecção)
            if (!currentPosition) {
                await getCurrentLocation();
            }
            
            isDetecting = true;
            detectionCount = 0;
            motionDetected = false;
            lastFrame = null;
            
            // Update UI
            document.getElementById('startDetection').style.display = 'none';
            document.getElementById('stopDetection').style.display = 'inline-flex';
            
            // Iniciar verificação de movimento (a cada 500ms)
            motionCheckInterval = setInterval(() => {
                detectMotion();
            }, 500);
            
            // Start continuous capture to buffer (every 1 second) - mas só se houver movimento
            captureInterval = setInterval(() => {
                if (motionDetected) {
                    captureToBuffer();
                }
            }, 1000);
            
            console.log('🎯 Detecção iniciada - Monitorando movimento');
            console.log('📊 Apenas capturará quando detectar movimento significativo');
            console.log('⏱️ Intervalo de captura: 1 segundo (quando movimento detectado)');
            console.log('🔒 Wake Lock ativo - dispositivo não entrará em suspensão');
        }
        
        function stopDetection() {
            console.log('⏹️ stopDetection() chamada');
            
            isDetecting = false;
            motionDetected = false;
            
            // Stop capture interval
            if (captureInterval) {
                clearInterval(captureInterval);
                captureInterval = null;
            }
            
            // Stop motion detection interval
            if (motionCheckInterval) {
                clearInterval(motionCheckInterval);
                motionCheckInterval = null;
            }
            
            lastFrame = null;
            consecutiveMotionFrames = 0;
            
            // Update UI
            document.getElementById('startDetection').style.display = 'inline-flex';
            document.getElementById('stopDetection').style.display = 'none';
            
            console.log('⏹️ Detecção parada');
        }
        
        function detectMotion() {
            if (!isDetecting || !cameraStream) return;
            
            try {
                const video = document.getElementById('cameraVideo');
                if (!video.videoWidth || !video.videoHeight) return;
                
                // Capturar frame atual
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const currentFrameData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                if (!lastFrame) {
                    // Primeiro frame, guardar e sair
                    lastFrame = currentFrameData;
                    return;
                }
                
                // Comparar frames - calcular diferença total
                let totalDifference = 0;
                let pixels = currentFrameData.data;
                let lastPixels = lastFrame.data;
                
                // Comparar apenas 1 em cada 4 pixels para performance (1/4 da resolução)
                for (let i = 0; i < pixels.length; i += 16) {
                    // Calcular diferença de brilho
                    const brightness = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
                    const lastBrightness = (lastPixels[i] + lastPixels[i + 1] + lastPixels[i + 2]) / 3;
                    totalDifference += Math.abs(brightness - lastBrightness);
                }
                
                const averageDifference = totalDifference / (pixels.length / 16);
                
                // Verificar se há movimento significativo
                if (averageDifference > motionThreshold) {
                    consecutiveMotionFrames++;
                    
                    if (consecutiveMotionFrames >= minMotionFrames && !motionDetected) {
                        motionDetected = true;
                        console.log('📸 Movimento detectado! Iniciando captura contínua...');
                        
                        // Visual feedback
                        const overlay = document.getElementById('cameraOverlay');
                        overlay.style.border = '3px solid #10b981';
                        setTimeout(() => {
                            overlay.style.border = 'none';
                        }, 1000);
                    }
                } else {
                    // Reset contador se não houver movimento
                    consecutiveMotionFrames = Math.max(0, consecutiveMotionFrames - 1);
                    
                    if (consecutiveMotionFrames === 0 && motionDetected) {
                        motionDetected = false;
                        console.log('💤 Movimento parou. Aguardando novo movimento...');
                    }
                }
                
                // Atualizar último frame
                lastFrame = currentFrameData;
                
            } catch (error) {
                console.error('❌ Erro na detecção de movimento:', error);
            }
        }
        
        async function captureToBuffer() {
            if (!isDetecting || !cameraStream) return;
            
            try {
                // Atualizar localização GPS antes de capturar
                await updateCurrentLocation();
                
                const video = document.getElementById('cameraVideo');
                if (!video.videoWidth || !video.videoHeight) return;
                
                // Capture image from video
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Convert to base64 (optimized for AI)
                const aiVersion = canvas.toDataURL('image/jpeg', 0.7); // 70% quality for AI
                const displayVersion = canvas.toDataURL('image/jpeg', 0.9); // 90% quality for display
                
                const now = new Date();
                
                // Log GPS com cada captura
                console.log(`📍 GPS captura ${detectionCount + 1}:`, currentPosition);
                
                // Create buffer entry
                const bufferEntry = {
                    event_id: currentEvent.id,
                    device_id: currentDevice,
                    session_id: sessionId,
                    image_data: aiVersion,
                    display_image: displayVersion,
                    image_metadata: {
                        width: canvas.width,
                        height: canvas.height,
                        device_type: 'mobile',
                        timestamp: now.toISOString(),
                        gps_updated: true
                    },
                    captured_at: now.toISOString(),
                    latitude: currentPosition?.latitude || null,
                    longitude: currentPosition?.longitude || null,
                    accuracy: currentPosition?.accuracy || null,
                    status: 'pending'
                };
                
                // Send to Supabase buffer
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    console.error('❌ Supabase não disponível');
                    return;
                }
                
                const { data, error } = await window.supabaseClient.supabase
                    .from('image_buffer')
                    .insert([bufferEntry])
                    .select()
                    .single();
                
                if (error) {
                    console.error('❌ Erro ao salvar no buffer:', error);
                } else {
                    detectionCount++;
                    document.getElementById('detectionCount').textContent = detectionCount;
                    
                    // Flash detection area green
                    const overlay = document.getElementById('cameraOverlay');
                    overlay.style.border = '4px solid #10b981';
                    setTimeout(() => {
                        overlay.style.border = 'none';
                    }, 200);
                    
                    // Tocar som de detecção
                    playDetectionSound();
                    
                    console.log(`📸 Imagem ${detectionCount} salva no buffer:`, data.id);
                    console.log(`   GPS: ${currentPosition?.latitude?.toFixed(6)}, ${currentPosition?.longitude?.toFixed(6)} (accuracy: ${currentPosition?.accuracy?.toFixed(0)}m)`);
                }
                
            } catch (error) {
                console.error('❌ Erro na captura:', error);
            }
        }
        
        async function getCurrentLocation() {
            if (!navigator.geolocation) {
                console.log('⚠️ Geolocalização não disponível');
                return;
            }
            
            try {
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    });
                });
                
                currentPosition = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy
                };
                
                console.log('📍 Localização inicial obtida:', currentPosition);
            } catch (error) {
                console.log('⚠️ Erro ao obter localização:', error.message);
                currentPosition = null;
            }
        }
        
        // Função para atualizar localização GPS (chamada antes de cada captura)
        async function updateCurrentLocation() {
            if (!navigator.geolocation) {
                console.log('⚠️ Geolocalização não disponível');
                return;
            }
            
            try {
                // Obter posição atual rapidamente (timeout menor para não atrasar captura)
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 3000, // Timeout mais curto para captura rápida
                        maximumAge: 5000 // Aceitar cache de até 5 segundos
                    });
                });
                
                currentPosition = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy
                };
                
                console.log('📍 GPS atualizado para captura:', currentPosition);
            } catch (error) {
                // Se falhar, usar posição anterior (se existir)
                console.log('⚠️ Erro ao atualizar GPS, usando anterior:', error.message);
                if (!currentPosition) {
                    console.log('⚠️ Nenhuma posição GPS disponível para esta captura');
                }
            }
        }
        
        async function registerDevice(eventId, deviceId) {
            if (!window.supabaseClient || !window.supabaseClient.supabase) {
                console.log('⚠️ Supabase não disponível');
                return;
            }
            
            try {
                // Atualizar last_seen do dispositivo
                const { error } = await window.supabaseClient.supabase
                    .from('devices')
                    .update({ 
                        last_seen: new Date().toISOString(),
                        user_agent: navigator.userAgent
                    })
                    .eq('id', deviceId);
                
                if (error) {
                    console.warn('⚠️ Aviso ao atualizar dispositivo:', error.message);
                } else {
                    console.log('✅ Dispositivo registrado no evento');
                }
            } catch (error) {
                console.warn('⚠️ Erro ao registrar dispositivo:', error.message);
            }
        }
        
        async function switchCamera() {
            console.log('🔄 Trocando câmera...');
            
            try {
                // Alternar entre traseira e frontal
                facingMode = facingMode === 'environment' ? 'user' : 'environment';
                console.log('📍 Modo de câmera:', facingMode === 'environment' ? 'Traseira' : 'Frontal');
                
                // Parar câmera atual
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                }
                
                // Parar detecção se estiver ativa
                if (isDetecting) {
                    await stopDetection();
                }
                
                // Iniciar nova câmera
                await startCamera();
                
                // Se estava detectando, reiniciar detecção
                if (isDetecting) {
                    await startDetection();
                }
                
            } catch (error) {
                console.error('❌ Erro ao trocar câmera:', error);
                showError('Erro ao trocar câmera');
            }
        }
        
        let flashEnabled = false;
        async function toggleFlash() {
            console.log('⚡ toggleFlash() chamada');
            
            try {
                if (!cameraStream) {
                    console.error('❌ Câmera não iniciada');
                    showError('Câmera não iniciada');
                    return;
                }
                
                const track = cameraStream.getVideoTracks()[0];
                const capabilities = track.getCapabilities();
                
                if (!capabilities.torch) {
                    showError('Flash não disponível neste dispositivo');
                    return;
                }
                
                flashEnabled = !flashEnabled;
                await track.applyConstraints({
                    advanced: [{ torch: flashEnabled }]
                });
                
                const flashBtn = document.getElementById('toggleFlash');
                if (flashEnabled) {
                    flashBtn.innerHTML = '<i>🔦</i> Flash ON';
                    flashBtn.classList.remove('btn-warning');
                    flashBtn.classList.add('btn-success');
                    console.log('⚡ Flash ativado');
                } else {
                    flashBtn.innerHTML = '<i>⚡</i> Flash';
                    flashBtn.classList.remove('btn-success');
                    flashBtn.classList.add('btn-warning');
                    console.log('⚡ Flash desativado');
                }
            } catch (error) {
                console.error('❌ Erro ao alternar flash:', error);
                showError('Erro ao controlar o flash');
            }
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        // Função para inicializar som de detecção
        function initDetectionSound() {
            // Criar som usando Web Audio API (beeep simples)
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800; // Frequência do beep
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
                
                console.log('🔊 Som de detecção inicializado');
            } catch (error) {
                console.warn('⚠️ Não foi possível inicializar som:', error);
            }
        }
        
        // Função para tocar som de detecção
        function playDetectionSound() {
            if (!soundEnabled) return;
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
                
                console.log('🔊 Som de detecção tocado');
            } catch (error) {
                console.warn('⚠️ Erro ao tocar som:', error);
            }
        }
        
        // Função para alternar som
        function toggleSound() {
            soundEnabled = !soundEnabled;
            
            const soundBtn = document.getElementById('toggleSoundBtn');
            if (soundEnabled) {
                soundBtn.innerHTML = '<i>🔊</i> <span class="btn-text">Som</span>';
                soundBtn.classList.remove('btn-warning');
                soundBtn.classList.add('btn-success');
                console.log('🔊 Som ativado');
            } else {
                soundBtn.innerHTML = '<i>🔇</i> <span class="btn-text">Mudo</span>';
                soundBtn.classList.remove('btn-success');
                soundBtn.classList.add('btn-warning');
                console.log('🔇 Som desativado');
            }
        }
        
        async function loadEventInfo(eventId, eventName) {
            try {
                console.log('📋 Carregando informações do evento...', eventId);
                
                // Primeiro buscar o dispositivo para obter informações
                const { data: deviceData, error: deviceError } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .select('checkpoint_name, checkpoint_type, checkpoint_order')
                    .eq('event_id', eventId)
                    .eq('device_id', currentDevice)
                    .single();
                
                console.log('📋 DeviceData:', deviceData);
                console.log('📋 DeviceError:', deviceError);
                
                // Buscar dados do evento via API server-side (usa SERVICE_ROLE_KEY)
                let eventNameFromDB = null;
                let eventDateFromDB = null;
                
                try {
                    console.log('🔍 Buscando evento via API server-side...');
                    const response = await fetch(`/api/event/${eventId}`);
                    
                    if (response.ok) {
                        const eventData = await response.json();
                        console.log('📋 EventData da API:', eventData);
                        eventNameFromDB = eventData.name;
                        eventDateFromDB = eventData.event_date;
                        console.log('✅ Nome:', eventNameFromDB, 'Data:', eventDateFromDB);
                    } else {
                        console.log('⚠️ API retornou status:', response.status);
                    }
                } catch (err) {
                    console.error('❌ Erro ao buscar evento via API:', err);
                }
                
                // Update UI com nome do evento
                // Se não conseguiu da DB, usar da URL, senão fallback
                let eventNameDisplay = eventNameFromDB || eventName || 'Evento Teste';
                
                console.log('✅ Exibindo nome do evento:', eventNameDisplay);
                document.getElementById('eventName').textContent = eventNameDisplay;
                
                // Update UI com data do evento
                if (eventDateFromDB) {
                    const formattedDate = new Date(eventDateFromDB).toLocaleDateString('pt-PT', {
                        day: '2-digit',
                        month: 'short',
                        year: 'numeric'
                    });
                    document.getElementById('eventDate').textContent = formattedDate;
                    console.log('✅ Data do evento:', formattedDate);
                } else {
                    document.getElementById('eventDate').textContent = '-';
                }
                
                // Update UI com tipo de checkpoint
                const checkpointType = deviceData?.checkpoint_type || '-';
                const checkpointTypeDisplay = checkpointType === 'start' ? '🏁 Partida' :
                                             checkpointType === 'checkpoint' ? '📍 Checkpoint' :
                                             checkpointType === 'finish' ? '🏆 Chegada' :
                                             '📍 ' + checkpointType;
                document.getElementById('checkpointType').textContent = checkpointTypeDisplay;
                
                // Update UI com ordem do dispositivo
                const deviceOrder = deviceData?.checkpoint_order || '-';
                document.getElementById('deviceOrder').textContent = `#${deviceOrder}`;
                
                // Atualizar currentEvent com nome completo
                if (eventNameFromDB) {
                    currentEvent.name = eventNameFromDB;
                    console.log('✅ currentEvent.name atualizado da DB:', currentEvent.name);
                } else if (eventName) {
                    // Se não conseguiu da DB, usar da URL
                    currentEvent.name = eventName;
                    console.log('✅ currentEvent.name atualizado da URL:', currentEvent.name);
                }
                
            } catch (error) {
                console.error('❌ Erro ao carregar info do evento:', error);
                // Fallback para dados básicos
                const fallbackName = eventName || 'Evento';
                console.log('⚠️ Usando nome fallback:', fallbackName);
                document.getElementById('eventName').textContent = fallbackName;
            }
        }
        
        function showError(message) {
            // Create toast notification
            const toast = document.createElement('div');
            toast.className = 'toast toast-error';
            toast.innerHTML = `
                <div class="toast-icon">❌</div>
                <div class="toast-content">
                    <div class="toast-message">${message}</div>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 5000);
        }
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
    
    <!-- All styles moved to external CSS files -->
</body>
</html>
