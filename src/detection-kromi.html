<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#fc6b03">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- Force no-cache para garantir código atualizado -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>Kromi.online - Detecção Inteligente v3.0</title>
    <!-- VERSION: 2025-01-03-SMART-DETECTION -->
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- KROMI Design System -->
    <link rel="stylesheet" href="/kromi-design-system.css">
    <link rel="stylesheet" href="/kromi-layout-fixes.css">
    <link rel="stylesheet" href="/kromi-mobile.css">
    <link rel="stylesheet" href="/kromi-mobile-ios.css">
    <link rel="stylesheet" href="/kromi-mobile-android.css">
    <link rel="stylesheet" href="/kromi-camera.css">
    
    <!-- Capability Detection -->
    <script src="/kromi-capability-detection.js"></script>
    
    <!-- Logo Integration Styles -->
    <link rel="stylesheet" href="/logo-integration.css?v=2025012701">
    
    <!-- Logo Loader (carregar antes de usar) -->
    <script src="/logo-loader.js?v=2025012702"></script>
    
    <style>
        /* Logo Container - Responsivo */
        .detection-logo-container {
            position: absolute;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .detection-logo-container img {
            width: auto;
            object-fit: contain;
        }
        
        /* Desktop e Mobile: Centro da tela */
        .detection-logo-container {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .detection-logo-container img {
            max-height: 80px;
        }
        
        /* Mobile: Ajustar tamanho */
        @media (max-width: 767px) {
            .detection-logo-container img {
                max-height: 60px;
            }
        }
    </style>
    
    <!-- Additional inline styles kept minimal for runtime overrides -->
</head>
<body data-theme="dark">
    <!-- Logo Container (Responsivo) -->
    <div class="detection-logo-container" id="detectionLogo"></div>
    
    <!-- Camera Container (Fullscreen) -->
    <div class="camera-container" id="cameraContainer">
        <!-- Camera Video -->
        <video id="cameraVideo" class="camera-video" autoplay muted playsinline></video>
        
        <!-- Camera Overlay -->
        <div class="camera-overlay" id="cameraOverlay">
            <!-- Detection areas will be added here -->
        </div>
        
        <!-- Camera Info -->
        <div class="camera-info">
            <div class="detection-stats" id="detectionStats">
                <div style="font-weight: 600; margin-bottom: var(--spacing-1);">📊 Detecções</div>
                <div id="detectionCount">0</div>
            </div>
            
            <div class="event-info" id="eventInfo">
                <div style="font-weight: 600; margin-bottom: var(--spacing-1);">🏃 Evento</div>
                <div id="eventName">Nenhum evento selecionado</div>
                <div id="eventDate" style="font-size: 0.85em; opacity: 0.8; margin-top: 4px;">-</div>
                <div id="checkpointType" style="font-size: 0.85em; opacity: 0.8; margin-top: 4px;">-</div>
                <div id="deviceOrder" style="font-size: 0.85em; opacity: 0.6;">#-</div>
            </div>
            
        </div>
        
        <!-- Bottom Controls (todos na parte inferior) -->
        <div class="bottom-controls">
            <button class="btn btn-sm btn-warning" id="toggleFlash" title="Alternar Flash">
                <i>⚡</i> <span class="btn-text">Flash</span>
            </button>
            <button class="btn btn-sm btn-danger" id="switchCamera" title="Trocar Câmera">
                <i>🔄</i> <span class="btn-text">Trocar</span>
            </button>
            <button class="btn btn-sm" id="toggleSoundBtn" title="Alternar Som" style="display: inline-flex;">
                <i>🔊</i> <span class="btn-text">Som</span>
            </button>
            <button class="btn btn-sm btn-danger" id="endSessionBtn" onclick="endSession()" style="display: none;" title="Terminar Sessão">
                <i>🚪</i> <span class="btn-text">Sair</span>
            </button>
        </div>
        
        <!-- Main Camera Controls (Center Bottom) -->
        <div class="main-camera-controls">
            <button class="btn btn-lg btn-primary" id="startDetection">
                <i>▶️</i> Iniciar Detecção
            </button>
            <button class="btn btn-lg btn-secondary" id="stopDetection" style="display: none;">
                <i>⏹️</i> Parar Detecção
            </button>
        </div>
    </div>
    
    <!-- Permission Panel -->
    <!-- PIN Panel (aparece primeiro) -->
    <div class="permission-panel" id="pinPanel" style="display: none;">
        <div class="permission-content">
            <h3>🔐 PIN de Segurança</h3>
            <p>Digite o PIN do dispositivo para acessar a detecção.</p>
            <form id="pinForm" onsubmit="event.preventDefault(); validatePin(); return false;">
                <!-- Campo username oculto para acessibilidade (recomendação do Chrome) -->
                <input type="text" name="username" autocomplete="username" value="device-pin" style="position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0; pointer-events: none;" tabindex="-1" aria-hidden="true">
                
                <div style="margin: var(--spacing-5) 0;">
                    <input type="password" inputmode="numeric" pattern="[0-9]*" maxlength="6" id="pinInput" 
                        placeholder="Digite o PIN"
                        autocomplete="current-password"
                        name="password"
                        style="width: 100%; padding: var(--spacing-4); font-size: var(--font-size-2xl); text-align: center; background: var(--bg-primary); border: 2px solid var(--border-color); border-radius: var(--radius-lg); color: var(--text-primary); font-weight: 700; letter-spacing: 8px;">
                    <div id="pinError" style="color: var(--danger); margin-top: var(--spacing-2); font-size: var(--font-size-sm); text-align: center; display: none;"></div>
                </div>
                <div class="permission-actions">
                    <button type="submit" class="btn btn-primary" id="validatePin">
                        <i>🔓</i> Validar PIN
                    </button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Camera Permission Panel (aparece depois do PIN) -->
    <div class="permission-panel" id="permissionPanel" style="display: none;">
        <div class="permission-content">
            <h3>📷 Acesso à Câmera</h3>
            <p>O Kromi.online precisa acessar sua câmera para detectar dorsais automaticamente.</p>
            <div class="permission-actions">
                <button class="btn btn-primary" id="requestCamera">
                    <i>📷</i> Permitir Câmera
                </button>
            </div>
        </div>
    </div>
    
    <!-- Scripts -->
    <script src="https://unpkg.com/@supabase/supabase-js@2" defer></script>
    <script src="/supabase.js?v=2025102605" defer></script>
    <script src="/auth-client.js?v=2025102616" defer></script>
    <script src="/auth-helper.js?v=2025102620" defer></script>
    
    <!-- Detection Logic -->
    <script>
        // Global variables
        let cameraStream = null;
        let isDetecting = false;
        let detectionCount = 0;
        let currentEvent = null;
        let currentDevice = null;
        let sessionId = null;
        let captureInterval = null;
        let motionCheckInterval = null;
        let currentPosition = null;
        let devicePin = null;
        let pinValidated = false;
        let soundEnabled = true; // Som habilitado por padrão
        let detectionSound = null; // Audio object para som de detecção
        let facingMode = 'environment'; // 'environment' (traseira) ou 'user' (frontal)
        let lastFrame = null; // Para detecção de movimento
        let motionDetected = false; // Flag para indicar se há movimento
        
        // Sistema de threshold DUPLO: ambiente vs pessoa
        let motionThresholdAmbient = 3; // Movimento ambiente (folhas, sombras) - NÃO captura
        let motionThresholdPerson = 15; // Movimento significativo (pessoa a passar) - CAPTURA
        let consecutiveMotionFrames = 0; // Contador de frames com movimento
        let minMotionFrames = 2; // Número mínimo de frames com movimento para considerar detecção
        
        // SEM cooldown - captura contínua quando há pessoa para pegar todos os dorsais do grupo
        let wakeLock = null; // Para prevenir suspensão do dispositivo
        
        // Canvas reutilizáveis para detecção de movimento (evitar criar em cada ciclo)
        let _motionCanvas, _motionCtx, _analysisCanvas, _analysisCtx;
        
        // Flag para controlar inicialização de áudio (apenas após gesto do utilizador)
        let audioReady = false;
        
        // Carregar logo
        async function loadDetectionLogo() {
            const logoContainer = document.getElementById('detectionLogo');
            if (!logoContainer) return;
            
            // Aguardar logoLoader estar disponível
            let attempts = 0;
            const maxAttempts = 50;
            
            const tryLoad = async () => {
                if (typeof window.logoLoader !== 'undefined' && window.logoLoader && typeof window.logoLoader.renderLogo === 'function') {
                    try {
                        await window.logoLoader.renderLogo(logoContainer, {
                            type: 'secondary', // Logo monocromático para fundos escuros
                            orientation: 'horizontal',
                            alt: 'Kromi.online',
                            className: 'detection-logo',
                            style: {
                                maxHeight: window.innerWidth >= 768 ? '80px' : '60px',
                                width: 'auto',
                                display: 'block'
                            },
                            fallback: '<h2 style="color: #fc6b03; font-size: 24px; margin: 0;">Kromi.online</h2>'
                        });
                        console.log('[DETECTION] Logo carregado');
                    } catch (error) {
                        console.warn('[DETECTION] Erro ao carregar logo:', error);
                    }
                    return true;
                }
                
                attempts++;
                if (attempts < maxAttempts) {
                    setTimeout(tryLoad, 100);
                }
            };
            
            // Aguardar um pouco antes de começar
            setTimeout(tryLoad, 300);
        }
        
        // Initialize page
        document.addEventListener('DOMContentLoaded', async () => {
            // LOG DE VERSÃO - CONFIRMAR QUE CÓDIGO NOVO ESTÁ A CARREGAR
            console.log('🚀🚀🚀 ========================================');
            console.log('🚀🚀🚀 DETECTION-KROMI.HTML v3.0 LOADED');
            console.log('🚀🚀🚀 VERSION: 2025-01-03-SMART-DETECTION');
            console.log('🚀🚀🚀 🎯 DETECÇÃO INTELIGENTE DE PESSOAS');
            console.log('🚀🚀🚀 🟢 Pessoa (>15): CAPTURA CONTÍNUA');
            console.log('🚀🚀🚀 🟡 Ambiente (3-15): IGNORA');
            console.log('🚀🚀🚀 🚴 Captura TODOS dorsais do grupo');
            console.log('🚀🚀🚀 ========================================');
            
            // Carregar logo
            loadDetectionLogo();
            
            // Initialize Supabase
            if (window.supabaseClient) {
                await window.supabaseClient.init();
            }
            
            // Get URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const eventId = urlParams.get('event');
            let deviceId = urlParams.get('device');
            const eventName = urlParams.get('eventName');
            
            console.log('🔗 Parâmetros URL:');
            console.log('  Event:', eventId);
            console.log('  Device:', deviceId);
            console.log('  EventName:', eventName);
            
            // Se não tem deviceId, buscar primeiro dispositivo do evento
            if (eventId && !deviceId) {
                console.log('⚠️ Device ID não especificado, buscando dispositivos do evento via API REST...');
                
                try {
                    const response = await fetch(`/api/devices/by-event?event_id=${encodeURIComponent(eventId)}`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        if (result.success && result.devices && result.devices.length > 0) {
                            deviceId = result.devices[0].device_id;
                            console.log('✅ Usando primeiro dispositivo:', deviceId, result.devices[0].checkpoint_name);
                            
                            // Atualizar URL
                            const newUrl = new URL(window.location);
                            newUrl.searchParams.set('device', deviceId);
                            window.history.replaceState({}, '', newUrl);
                        } else {
                            console.error('❌ Nenhum dispositivo encontrado para este evento');
                            showError('Nenhum dispositivo configurado para este evento. Configure em /devices');
                            setTimeout(() => window.location.href = `/devices?event=${eventId}&eventName=${eventName}`, 3000);
                            return;
                        }
                    } else {
                        console.warn('⚠️ Erro ao buscar dispositivos via API:', response.status);
                        showError('Erro ao buscar dispositivos do evento');
                    }
                } catch (apiError) {
                    console.error('❌ Erro ao buscar dispositivos:', apiError);
                    showError('Erro ao buscar dispositivos do evento');
                }
            }
            
            currentEvent = { id: eventId, name: eventName || null };
            currentDevice = deviceId;
            sessionId = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            console.log('🔗 Parâmetros finais:');
            console.log('  Event:', eventId);
            console.log('  Device:', deviceId);
            console.log('  Session:', sessionId);
            console.log('  EventName da URL:', eventName);
            
            if (eventId) {
                await loadEventInfo(eventId, eventName);
            }
            
            // Register device
            if (eventId && deviceId) {
                await registerDevice(eventId, deviceId);
            }
            
            // NÃO chamar getCurrentLocation() aqui - será chamado após interação do usuário
            // Isso evita violação de política do navegador
            
            // Setup event listeners
            setupEventListeners();
            
            // Request PIN sempre (se tem device)
            console.log('🔐 Verificando se deve pedir PIN...');
            console.log('  currentDevice:', currentDevice);
            
            if (currentDevice) {
                console.log('✅ Device especificado, pedindo PIN...');
                await requestDevicePin();
            } else {
                console.error('❌ Device não especificado');
                showError('Dispositivo não especificado');
                setTimeout(() => window.location.href = '/events', 3000);
            }
            
            console.log('✅ Inicialização completa');
            
            // Expor validatePin globalmente (garantir que está disponível para HTML inline)
            window.validatePin = validatePin;
            console.log('🔧 window.validatePin exposta:', typeof window.validatePin);
            
            // Expor função de debug globalmente
            window.debugDetection = function() {
                console.log('🐛 ========== DEBUG DETECTION ==========');
                console.log('  isDetecting:', isDetecting);
                console.log('  cameraStream:', !!cameraStream);
                console.log('  motionCheckInterval:', !!motionCheckInterval);
                console.log('  captureInterval:', !!captureInterval);
                console.log('  🟢 motionThresholdPerson:', motionThresholdPerson);
                console.log('  🟡 motionThresholdAmbient:', motionThresholdAmbient);
                console.log('  minMotionFrames:', minMotionFrames);
                console.log('  detectMotion exists:', typeof detectMotion);
                console.log('  _detectMotionCallCount:', window._detectMotionCallCount || 0);
                console.log('🐛 =====================================');
                
                // Testar detectMotion manualmente
                if (typeof detectMotion === 'function') {
                    console.log('🧪 Testando detectMotion() agora...');
                    detectMotion();
                } else {
                    console.error('❌ detectMotion não está definida!');
                }
            };
            
            // Função para ajustar thresholds em tempo real
            window.adjustThreshold = function(personThreshold, ambientThreshold) {
                if (personThreshold !== undefined) {
                    motionThresholdPerson = personThreshold;
                    console.log(`✅ Threshold PESSOA ajustado para: ${motionThresholdPerson}`);
                }
                if (ambientThreshold !== undefined) {
                    motionThresholdAmbient = ambientThreshold;
                    console.log(`✅ Threshold AMBIENTE ajustado para: ${motionThresholdAmbient}`);
                }
                console.log('📊 Configuração atual:');
                console.log(`   🟢 Pessoa: >${motionThresholdPerson} → CAPTURA`);
                console.log(`   🟡 Ambiente: ${motionThresholdAmbient}-${motionThresholdPerson} → IGNORA`);
                console.log(`   ⚪ Parado: <${motionThresholdAmbient}`);
            };
            
            console.log('💡 Funções disponíveis na consola:');
            console.log('   window.debugDetection() - mostrar estado');
            console.log('   window.adjustThreshold(pessoa, ambiente) - ex: adjustThreshold(20, 5)');
        });
        
        function setupEventListeners() {
            // PIN validation - remover listener direto no botão, usar apenas form submit
            // document.getElementById('validatePin')?.addEventListener('click', validatePin); // Removido - form já chama
            document.getElementById('pinInput')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    validatePin();
                }
            });
            
            // Camera permission
            document.getElementById('requestCamera').addEventListener('click', startCamera);
            
            // Detection controls - COM VERIFICAÇÕES DE SEGURANÇA E DELAY
            setTimeout(() => {
                const startDetectionBtn = document.getElementById('startDetection');
                const stopDetectionBtn = document.getElementById('stopDetection');
                const switchCameraBtn = document.getElementById('switchCamera');
                const toggleFlashBtn = document.getElementById('toggleFlash');
                const toggleSoundBtn = document.getElementById('toggleSoundBtn');
                const endSessionBtn = document.getElementById('endSessionBtn');
                
                console.log('🔍 Procurando botões...');
                console.log('startDetectionBtn:', startDetectionBtn);
                console.log('stopDetectionBtn:', stopDetectionBtn);
                console.log('switchCameraBtn:', switchCameraBtn);
                console.log('toggleFlashBtn:', toggleFlashBtn);
                console.log('toggleSoundBtn:', toggleSoundBtn);
                console.log('endSessionBtn:', endSessionBtn);
                
                if (startDetectionBtn) {
                    startDetectionBtn.addEventListener('click', startDetection);
                    console.log('✅ Event listener adicionado: startDetection');
                } else {
                    console.error('❌ Botão startDetection não encontrado');
                }
                
                if (stopDetectionBtn) {
                    // Remover listeners anteriores para evitar duplicatas
                    stopDetectionBtn.removeEventListener('click', stopDetection);
                    // Adicionar novo listener
                    stopDetectionBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🖱️ Botão stopDetection clicado pelo usuário');
                        stopDetection();
                    });
                    console.log('✅ Event listener adicionado: stopDetection');
                } else {
                    console.error('❌ Botão stopDetection não encontrado');
                }
                
                if (switchCameraBtn) {
                    switchCameraBtn.addEventListener('click', switchCamera);
                    console.log('✅ Event listener adicionado: switchCamera');
                } else {
                    console.error('❌ Botão switchCamera não encontrado');
                }
                
                if (toggleFlashBtn) {
                    toggleFlashBtn.addEventListener('click', toggleFlash);
                    console.log('✅ Event listener adicionado: toggleFlash');
                } else {
                    console.error('❌ Botão toggleFlash não encontrado');
                }
                
                if (toggleSoundBtn) {
                    toggleSoundBtn.addEventListener('click', toggleSound);
                    console.log('✅ Event listener adicionado: toggleSound');
                } else {
                    console.error('❌ Botão toggleSound não encontrado');
                }
                
                if (endSessionBtn) {
                    // Remove onclick inline e adiciona event listener
                    endSessionBtn.removeAttribute('onclick');
                    endSessionBtn.addEventListener('click', endSession);
                    console.log('✅ Event listener adicionado: endSessionBtn');
                } else {
                    console.error('❌ Botão endSessionBtn não encontrado');
                }
            }, 100);
            
            // NÃO inicializar som aqui - será inicializado no primeiro gesto do utilizador
            // (iOS/Chrome bloqueiam AudioContext sem gesto do utilizador)
            
            // Inicializar estado do botão de som
            const soundBtn = document.getElementById('toggleSoundBtn');
            if (soundBtn && soundEnabled) {
                soundBtn.innerHTML = '<i>🔊</i> <span class="btn-text">Som</span>';
                soundBtn.classList.add('btn-success');
            }
            
            // Prevenir suspensão do dispositivo (Wake Lock)
            requestWakeLock();
            
            // Detectar quando a página volta ao foco
            document.addEventListener('visibilitychange', async () => {
                if (document.hidden) {
                    console.log('📱 Página em background - suspendendo Wake Lock');
                    releaseWakeLock();
                } else {
                    console.log('📱 Página visível - reativando Wake Lock');
                    requestWakeLock();
                }
            });
            
            // Fullscreen toggle (removed - no header button)
        }
        
        async function requestDevicePin() {
            // Se PIN já foi validado, não pedir novamente
            if (pinValidated) {
                console.log('✅ PIN já validado anteriormente, ignorando requestDevicePin');
                return;
            }
            
            try {
                console.log('🔐 requestDevicePin: Iniciando...');
                console.log('  Event ID:', currentEvent.id);
                console.log('  Device ID:', currentDevice);
                
                console.log('📊 Buscando dados do dispositivo via API REST...');
                
                // Carregar dados do dispositivo via API REST (página pública)
                const deviceResponse = await fetch(`/api/devices/by-event-device?event_id=${encodeURIComponent(currentEvent.id)}&device_id=${encodeURIComponent(currentDevice)}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!deviceResponse.ok) {
                    const errorData = await deviceResponse.json().catch(() => ({ error: 'Erro desconhecido' }));
                    console.warn('⚠️ Device não encontrado via API:', errorData);
                    console.warn('  Possível causa: device não está em event_devices');
                    requestCameraPermission();
                    return;
                }
                
                const deviceResult = await deviceResponse.json();
                
                if (!deviceResult.success || !deviceResult.device) {
                    console.warn('⚠️ Device não encontrado, pulando PIN');
                    requestCameraPermission();
                    return;
                }
                
                const deviceData = deviceResult.device;
                
                console.log('📊 Resultado:');
                console.log('  Data:', deviceData);
                
                console.log('✅ Device encontrado:', deviceData);
                
                // Verificar limite de sessões
                const activeSessions = deviceData.active_sessions || 0;
                const maxSessions = deviceData.max_sessions || 1;
                
                console.log(`📊 Sessões: ${activeSessions}/${maxSessions}`);
                console.log(`📊 Verificando limite: ${activeSessions} >= ${maxSessions} ?`);
                console.log(`📊 Resultado: ${activeSessions >= maxSessions}`);
                
                devicePin = deviceData.device_pin;
                
                // Se limite atingido, mostrar modal de conflito
                if (activeSessions >= maxSessions) {
                    console.error('❌❌❌ LIMITE DE SESSÕES ATINGIDO! ❌❌❌');
                    console.error(`  Ativas: ${activeSessions}`);
                    console.error(`  Máximo: ${maxSessions}`);
                    
                    // Mostrar modal de confirmação com PIN para libertar sessão
                    await showSessionConflictModal(deviceData);
                    return;
                }
                
                console.log('🔐 PIN requerido para este dispositivo');
                console.log('  PIN existe:', !!devicePin);
                console.log('  PIN valor:', devicePin ? '****' : 'Nenhum');
                console.log('📍 Checkpoint:', deviceData.checkpoint_name || 'Não configurado');
                
                // Se não tem PIN configurado, ir direto para câmera
                if (!devicePin) {
                    console.log('⚠️ Dispositivo sem PIN, pulando validação');
                    requestCameraPermission();
                    return;
                }
                
                // Mostrar tela de PIN
                console.log('🔐 Mostrando tela de PIN...');
                const pinPanel = document.getElementById('pinPanel');
                if (pinPanel) {
                    pinPanel.style.display = 'flex';
                    console.log('✅ Tela de PIN exibida');
                } else {
                    console.error('❌ Elemento pinPanel não encontrado');
                }
                
                // Focus no input
                setTimeout(() => {
                    const pinInput = document.getElementById('pinInput');
                    if (pinInput) {
                        pinInput.focus();
                        console.log('✅ Focus no input PIN');
                    } else {
                        console.error('❌ Input PIN não encontrado');
                    }
                }, 300);
                
            } catch (error) {
                console.error('❌ Erro ao carregar PIN:', error);
                // Se falhar, permitir acesso
                requestCameraPermission();
            }
        }
        
        async function showSessionConflictModal(deviceData) {
            return new Promise((resolve) => {
                // Criar modal de confirmação
                const modal = document.createElement('div');
                modal.id = 'sessionConflictModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.9);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    padding: var(--spacing-4);
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: var(--bg-secondary);
                        border-radius: var(--radius-lg);
                        padding: var(--spacing-6);
                        max-width: 500px;
                        width: 100%;
                        box-shadow: var(--shadow-2xl);
                    ">
                        <h2 style="color: var(--danger); margin: 0 0 var(--spacing-4) 0; display: flex; align-items: center; gap: var(--spacing-2);">
                            <span style="font-size: 2rem;">⚠️</span>
                            Dispositivo em Uso
                        </h2>
                        
                        <p style="color: var(--text-primary); margin: 0 0 var(--spacing-4) 0; line-height: 1.6;">
                            Este dispositivo já tem <strong>${deviceData.active_sessions}</strong> sessão(ões) ativa(s).<br>
                            Limite máximo: <strong>${deviceData.max_sessions}</strong> sessão(ões).
                        </p>
                        
                        <div style="background: rgba(252, 107, 3, 0.1); padding: var(--spacing-4); border-radius: var(--radius-base); border-left: 3px solid var(--primary); margin: 0 0 var(--spacing-5) 0;">
                            <p style="margin: 0; color: var(--text-secondary); font-size: var(--font-size-sm);">
                                <strong>🔐 Tem a certeza que deseja assumir este dispositivo?</strong><br><br>
                                Para libertar a sessão atual e criar uma nova, introduza o PIN do dispositivo:
                            </p>
                        </div>
                        
                        <form id="conflictPinForm" onsubmit="event.preventDefault(); document.getElementById('confirmReleaseBtn').click();">
                            <!-- Campo username oculto para acessibilidade (recomendação do Chrome) -->
                            <input type="text" name="username" autocomplete="username" value="device-pin" style="position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0; pointer-events: none;" tabindex="-1" aria-hidden="true">
                            
                            <div style="margin: 0 0 var(--spacing-4) 0;">
                                <input 
                                    type="password" 
                                    id="conflictPinInput"
                                    name="password"
                                    placeholder="Digite o PIN do dispositivo"
                                    autocomplete="current-password"
                                    style="
                                        width: 100%;
                                        padding: var(--spacing-3);
                                        font-size: var(--font-size-lg);
                                        text-align: center;
                                        letter-spacing: 0.5em;
                                        border: 2px solid var(--border-color);
                                        border-radius: var(--radius-base);
                                        background: var(--bg-primary);
                                        color: var(--text-primary);
                                    "
                                />
                                <div id="conflictPinError" style="color: var(--danger); margin-top: var(--spacing-2); display: none;"></div>
                            </div>
                            
                            <div style="display: flex; gap: var(--spacing-3);">
                                <button 
                                    type="submit"
                                    id="confirmReleaseBtn"
                                    class="btn btn-primary"
                                    style="flex: 1;"
                                >
                                    🔓 Libertar e Assumir
                                </button>
                                <button 
                                    type="button"
                                    id="cancelReleaseBtn"
                                    class="btn btn-secondary"
                                    style="flex: 1;"
                                >
                                    ❌ Cancelar
                                </button>
                            </div>
                        </form>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                const pinInput = modal.querySelector('#conflictPinInput');
                const errorDiv = modal.querySelector('#conflictPinError');
                const confirmBtn = modal.querySelector('#confirmReleaseBtn');
                const cancelBtn = modal.querySelector('#cancelReleaseBtn');
                
                pinInput.focus();
                
                // Enter no input = confirmar
                pinInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        confirmBtn.click();
                    }
                });
                
                // Confirmar com PIN
                confirmBtn.addEventListener('click', async () => {
                    const inputPin = pinInput.value.trim();
                    
                    if (!inputPin) {
                        errorDiv.textContent = '⚠️ Digite o PIN do dispositivo';
                        errorDiv.style.display = 'block';
                        return;
                    }
                    
                    if (inputPin !== deviceData.device_pin) {
                        errorDiv.textContent = '❌ PIN incorreto. Tente novamente.';
                        errorDiv.style.display = 'block';
                        pinInput.value = '';
                        pinInput.focus();
                        return;
                    }
                    
                    // PIN correto! Libertar sessões antigas
                    confirmBtn.disabled = true;
                    confirmBtn.innerHTML = '⏳ Libertando sessão...';
                    
                    // Libertar todas as sessões deste dispositivo
                    const sessionsReleased = await releaseAllDeviceSessions();
                    
                    if (!sessionsReleased) {
                        console.warn('⚠️ Não foi possível liberar todas as sessões, mas continuando...');
                    }
                    
                    // Aguardar um pouco para garantir que a base de dados foi atualizada
                    // Aumentado para 1 segundo para evitar race condition
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Remover modal
                    modal.remove();
                    
                    // Continuar com fluxo normal - criar sessão e iniciar câmera
                    console.log('🔄 Após liberação no modal, continuando com fluxo...');
                    
                    // Marcar PIN como validado
                    pinValidated = true;
                    
                    // Resetar flag antes de criar sessão após liberar sessões
                    isCreatingSession = false;
                    
                    // Criar sessão
                    const sessionCreated = await createDeviceSession();
                    
                    // Log do sessionId após criar sessão
                    console.log('🔍 SessionId após criar sessão no modal:', sessionId);
                    
                    if (sessionCreated) {
                        console.log('✅ Sessão criada após liberação no modal');
                        
                        // Marcar PIN como validado para prevenir pedido novamente
                        pinValidated = true;
                        
                        // Esconder tela de PIN (se estiver visível)
                        const pinPanel = document.getElementById('pinPanel');
                        if (pinPanel) {
                            pinPanel.style.display = 'none';
                            // Desabilitar o form também
                            const pinForm = document.getElementById('pinForm');
                            if (pinForm) {
                                pinForm.style.display = 'none';
                            }
                        }
                        
                        // Mostrar botão de terminar sessão
                        const endBtn = document.getElementById('endSessionBtn');
                        if (endBtn) endBtn.style.display = 'inline-flex';
                        
                        // Mostrar botão "Iniciar Detecção" (não iniciar automaticamente)
                        const startBtn = document.getElementById('startDetection');
                        if (startBtn) {
                            startBtn.style.display = 'inline-flex';
                            console.log('✅ Botão "Iniciar Detecção" disponível');
                        }
                        
                        // Iniciar heartbeat
                        startSessionHeartbeat();
                    } else {
                        console.error('❌ Falha ao criar sessão após liberação');
                        showError('Erro ao criar sessão. Tente novamente.');
                    }
                    
                    resolve(true);
                });
                
                // Cancelar
                cancelBtn.addEventListener('click', () => {
                    modal.remove();
                    resolve(false);
                    setTimeout(() => window.history.back(), 500);
                });
            });
        }
        
        // Liberar todas as sessões do dispositivo via API REST (página pública)
        async function releaseAllDeviceSessions() {
            try {
                console.log('🔓 Libertando todas as sessões do dispositivo via API REST...');
                
                const response = await fetch('/api/devices/end-all-sessions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        event_id: currentEvent.id,
                        device_id: currentDevice
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    console.error('❌ Erro ao libertar sessões via API:', errorData);
                    return false;
                }
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('✅ Todas as sessões foram encerradas via API REST');
                    return true;
                } else {
                    console.error('❌ Falha ao libertar sessões:', result.error);
                    return false;
                }
                
            } catch (error) {
                console.error('❌ Erro ao libertar sessões:', error);
                return false;
            }
        }
        
        let isValidatingPin = false; // Flag para prevenir chamadas duplicadas
        let pinValidationPromise = null; // Promise para garantir apenas uma validação
        
        async function validatePin() {
            // Prevenir chamadas duplicadas - retornar a mesma promise se já está validando
            if (isValidatingPin) {
                console.log('⚠️ Validação de PIN já em andamento, aguardando resultado existente...');
                return pinValidationPromise;
            }
            
            isValidatingPin = true;
            
            // Criar uma promise que será retornada para chamadas subsequentes
            pinValidationPromise = (async () => {
                try {
                    return await validatePinInternal();
                } finally {
                    isValidatingPin = false;
                    pinValidationPromise = null;
                }
            })();
            
            return pinValidationPromise;
        }
        
        // Expor globalmente para o HTML inline poder chamar
        window.validatePin = validatePin;
        
        async function validatePinInternal() {
            try {
                const inputPin = document.getElementById('pinInput').value;
                const errorDiv = document.getElementById('pinError');
                
                if (!inputPin) {
                    errorDiv.textContent = 'Digite o PIN';
                    errorDiv.style.display = 'block';
                    return;
                }
                
                if (inputPin === devicePin) {
                    // PIN correto! Tentar iniciar sessão
                    console.log('✅ PIN validado com sucesso');
                    pinValidated = true;
                    
                    // Obter localização GPS após gesto do usuário (validar PIN)
                    if (!currentPosition) {
                        await getCurrentLocation();
                    }
                    
                    // Criar sessão no Supabase
                    const sessionCreated = await createDeviceSession();
                
                    if (!sessionCreated) {
                        // Se a sessão não foi criada, verificar se foi criada pelo modal
                        // Se sim, continuar normalmente
                        if (sessionId) {
                            console.log('✅ Sessão foi criada pelo modal, continuando...');
                            // Continuar o fluxo normalmente
                        } else {
                            errorDiv.textContent = '❌ Limite de sessões atingido. Aguarde.';
                            errorDiv.style.display = 'block';
                            return;
                        }
                    }
                
                    // Esconder tela de PIN permanentemente (marcar como já validado)
                    const pinPanel = document.getElementById('pinPanel');
                    if (pinPanel) {
                        pinPanel.style.display = 'none';
                        console.log('✅ Painel de PIN escondido permanentemente');
                    }
                    
                    // Limpar input de PIN
                    const pinInput = document.getElementById('pinInput');
                    if (pinInput) {
                        pinInput.value = '';
                    }
                    
                    // Desabilitar o form para prevenir novos submits
                    const pinForm = document.getElementById('pinForm');
                    if (pinForm) {
                        pinForm.style.display = 'none';
                    }
                    
                    // Mostrar botão terminar sessão
                    const endBtn = document.getElementById('endSessionBtn');
                    if (endBtn) endBtn.style.display = 'inline-flex';
                    
                    // Mostrar botão "Iniciar Detecção" (não iniciar automaticamente)
                    const startBtn = document.getElementById('startDetection');
                    if (startBtn) {
                        startBtn.style.display = 'inline-flex';
                        console.log('✅ Botão "Iniciar Detecção" disponível');
                    }
                    
                    // Iniciar heartbeat
                    startSessionHeartbeat();
                    
                } else {
                    // PIN errado
                    console.error('❌ PIN incorreto');
                    errorDiv.textContent = '❌ PIN incorreto. Tente novamente.';
                    errorDiv.style.display = 'block';
                    
                    // Limpar input
                    document.getElementById('pinInput').value = '';
                    document.getElementById('pinInput').focus();
                    
                    // Shake animation
                    const panel = document.querySelector('#pinPanel .permission-content');
                    panel.style.animation = 'shake 0.5s';
                    setTimeout(() => {
                        panel.style.animation = '';
                    }, 500);
                }
            } catch (error) {
                console.error('❌ Erro na validação de PIN:', error);
                const errorDiv = document.getElementById('pinError');
                if (errorDiv) {
                    errorDiv.textContent = 'Erro ao validar PIN. Tente novamente.';
                    errorDiv.style.display = 'block';
                }
            }
        }
        
        async function cleanupInactiveSessions() {
            try {
                console.log('🧹 Limpando sessões inativas via API REST...');
                
                const response = await fetch('/api/devices/cleanup-inactive-sessions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    console.error('❌ Erro ao limpar:', errorData);
                    showError('Erro ao limpar sessões');
                    return false;
                }
                
                const result = await response.json();
                
                if (result.success) {
                    console.log(`✅ ${result.cleaned || 0} sessões inativas removidas`);
                    alert(`✅ ${result.cleaned || 0} sessões inativas foram removidas. Tente novamente.`);
                    return true;
                } else {
                    console.error('❌ Falha ao limpar sessões:', result.error);
                    showError(result.error || 'Erro ao limpar sessões');
                    return false;
                }
                
            } catch (error) {
                console.error('❌ Erro:', error);
                showError('Erro ao limpar sessões. Tente novamente.');
                return false;
            }
        }
        
        let isCreatingSession = false; // Flag para prevenir chamadas duplicadas
        
        async function createDeviceSession() {
            // Gerar um novo sessionId único para cada tentativa de criar sessão
            // Gerar um session_id único usando timestamp + random + counter para garantir unicidade
            const timestamp = Date.now();
            const random = Math.random().toString(36).substr(2, 9);
            const counter = (window._sessionCounter = (window._sessionCounter || 0) + 1);
            const newSessionId = `session-${timestamp}-${random}-${counter}`;
            
            // Prevenir chamadas duplicadas - mas permitir retry após liberar sessões
            if (isCreatingSession) {
                console.log('⚠️ Criação de sessão já em andamento, aguardando...');
                // Aguardar um pouco e tentar novamente
                await new Promise(resolve => setTimeout(resolve, 500));
                // Se ainda estiver criando, retornar false para permitir que o modal seja mostrado
                if (isCreatingSession) {
                    return false;
                }
            }
            
            isCreatingSession = true;
            
            try {
                console.log('🔄 Criando sessão via API REST...');
                
                const sessionResponse = await fetch('/api/devices/start-session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        event_id: currentEvent.id,
                        device_id: currentDevice,
                        session_id: newSessionId,
                        user_agent: navigator.userAgent
                    })
                });
                
                let data = null;
                let error = null;
                
                if (sessionResponse.ok) {
                    const sessionResult = await sessionResponse.json();
                    data = sessionResult;
                    
                    // Se a sessão foi criada com sucesso, atualizar o sessionId global com o ID retornado ou o novo gerado
                    if (data.success && data.session_id) {
                        sessionId = data.session_id;
                        console.log('✅ SessionId atualizado globalmente:', sessionId);
                    } else if (data.success) {
                        sessionId = newSessionId;
                        console.log('✅ SessionId atualizado globalmente (usando novo gerado):', sessionId);
                    }
                    
                    console.log('📊 Resultado criar sessão:');
                    console.log('  Data:', data);
                } else {
                    const errorData = await sessionResponse.json().catch(() => ({ error: 'Erro desconhecido' }));
                    error = errorData;
                    console.error('❌ Erro ao criar sessão:', error);
                }
                
                if (error) {
                    console.error('❌ Erro ao criar sessão:', error);
                    // Permitir acesso mesmo sem sessões (fallback)
                    console.warn('⚠️ Continuando sem controle de sessões...');
                    return true;
                }
                
                if (!data || !data.success) {
                    console.error('❌ Sessão não criada:', data);
                    
                    // Verificar se é limite de sessões
                    const errorMessage = data?.error || (typeof data === 'string' ? data : 'Erro desconhecido');
                    if (errorMessage.includes('Max sessions') || errorMessage.includes('limite') || errorMessage.includes('exceeded')) {
                        // Mostrar modal de conflito para libertar sessões
                        console.log('⚠️ Limite atingido - mostrando modal de conflito...');
                        
                        // Buscar dados completos do dispositivo para o modal via API REST
                        const deviceResponse = await fetch(`/api/devices/by-event-device?event_id=${encodeURIComponent(currentEvent.id)}&device_id=${encodeURIComponent(currentDevice)}`, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        let deviceData = null;
                        if (deviceResponse.ok) {
                            const deviceResult = await deviceResponse.json();
                            if (deviceResult.success && deviceResult.device) {
                                deviceData = deviceResult.device;
                            }
                        }
                        
                        if (deviceData) {
                            // Mostrar modal e aguardar confirmação
                            const confirmed = await showSessionConflictModal(deviceData);
                            
                            if (confirmed) {
                                // O modal já criou a sessão, apenas verificar se foi criada
                                // Guardar o sessionId antes do modal para comparar
                                const sessionIdBeforeModal = sessionId;
                                
                                // Aguardar um pouco para garantir que o modal completou
                                await new Promise(resolve => setTimeout(resolve, 1500));
                                
                                // Verificar se sessionId mudou (foi atualizado pelo modal)
                                console.log('🔍 Verificando sessionId após modal:');
                                console.log('  Antes do modal:', sessionIdBeforeModal);
                                console.log('  Depois do modal:', sessionId);
                                
                                // Se o sessionId foi atualizado e contém um UUID válido, significa que foi criado pelo modal
                                if (sessionId && sessionId !== sessionIdBeforeModal && sessionId.includes('-') && sessionId.length > 20) {
                                    console.log('✅ Sessão já foi criada pelo modal! SessionId:', sessionId);
                                    // Resetar flag antes de retornar
                                    isCreatingSession = false;
                                    return true;
                                }
                                
                                // Verificar diretamente na API se existe uma sessão ativa para este dispositivo
                                try {
                                    const checkResponse = await fetch(`/api/devices/by-event-device?event_id=${encodeURIComponent(currentEvent.id)}&device_id=${encodeURIComponent(currentDevice)}`);
                                    if (checkResponse.ok) {
                                        const checkResult = await checkResponse.json();
                                        if (checkResult.success && checkResult.device && checkResult.device.active_sessions > 0) {
                                            console.log('✅ Sessão ativa encontrada na API, modal já criou!');
                                            // Resetar flag antes de retornar
                                            isCreatingSession = false;
                                            return true;
                                        }
                                    }
                                } catch (err) {
                                    console.warn('⚠️ Erro ao verificar sessões ativas:', err);
                                }
                                
                                // Se não foi criada pelo modal, tentar criar agora
                                // Gerar um novo sessionId para a retry
                                const retrySessionId = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                                console.log('🔄 Tentando criar sessão após liberação no modal (modal não criou)...');
                                const retryResponse = await fetch('/api/devices/start-session', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        event_id: currentEvent.id,
                                        device_id: currentDevice,
                                        session_id: retrySessionId,
                                        user_agent: navigator.userAgent
                                    })
                                });
                                
                                if (retryResponse.ok) {
                                    const retryResult = await retryResponse.json();
                                    if (retryResult.success) {
                                        // Atualizar sessionId global com o ID retornado ou o novo gerado
                                        if (retryResult.session_id) {
                                            sessionId = retryResult.session_id;
                                        } else {
                                            sessionId = retrySessionId;
                                        }
                                        console.log('✅ Sessão criada após liberação! SessionId:', sessionId);
                                        // Resetar flag antes de retornar
                                        isCreatingSession = false;
                                        return true;
                                    }
                                }
                                
                                console.error('❌ Ainda falhou ao criar sessão');
                                showError(`Limite de ${deviceData.max_sessions} sessões atingido!`);
                                // Resetar flag antes de retornar
                                isCreatingSession = false;
                                return false;
                            }
                        } else {
                            // Usuário cancelou
                            console.log('❌ Liberação cancelada pelo usuário');
                            // Resetar flag antes de retornar
                            isCreatingSession = false;
                            return false;
                        }
                    } else {
                        showError('Limite de sessões atingido!');
                        // Resetar flag antes de retornar
                        isCreatingSession = false;
                        return false;
                    }
                }
                
                console.log('✅ Sessão criada com sucesso!');
                console.log(`  Sessão ID: ${data.session?.session_id || data.session_id || sessionId}`);
                if (data.current_active !== undefined && data.max_allowed !== undefined) {
                    console.log(`  Ativas agora: ${data.current_active}/${data.max_allowed}`);
                } else if (data.session) {
                    console.log(`  Sessão criada: ${data.session.id || data.session.session_id}`);
                }
                
                // Resetar flag antes de retornar
                isCreatingSession = false;
                return true;
                
            } catch (error) {
                console.error('❌ Erro geral:', error);
                // Resetar flag antes de retornar
                isCreatingSession = false;
                // Permitir acesso em caso de erro (para não bloquear)
                return true;
            }
        }
        
        function startSessionHeartbeat() {
            if (!sessionId) {
                console.warn('⚠️ sessionId não disponível, heartbeat não iniciado');
                return;
            }
            
            // Enviar heartbeat a cada 30 segundos via API REST
            setInterval(async () => {
                try {
                    const response = await fetch('/api/devices/update-heartbeat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: sessionId
                        })
                    });
                    
                    if (response.ok) {
                        console.log('💓 Heartbeat enviado via API REST');
                    } else {
                        console.error('❌ Erro no heartbeat:', await response.text());
                    }
                } catch (error) {
                    console.error('❌ Erro no heartbeat:', error);
                }
            }, 30000);
        }
        
        // Função para prevenir suspensão do dispositivo (Wake Lock API)
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('🔒 Wake Lock ativado - dispositivo não entrará em suspensão');
                    
                    // Detectar quando o Wake Lock é liberado (ex: tela bloqueada)
                    wakeLock.addEventListener('release', () => {
                        console.log('🔓 Wake Lock liberado - dispositivo pode suspender');
                    });
                } else {
                    console.warn('⚠️ Wake Lock API não suportada neste navegador');
                }
            } catch (error) {
                console.warn('⚠️ Não foi possível ativar Wake Lock:', error.message);
            }
        }
        
        // Função para liberar Wake Lock
        async function releaseWakeLock() {
            try {
                if (wakeLock && 'wakeLock' in navigator) {
                    await wakeLock.release();
                    wakeLock = null;
                    console.log('🔓 Wake Lock liberado manualmente');
                }
            } catch (error) {
                console.warn('⚠️ Erro ao liberar Wake Lock:', error.message);
            }
        }
        
        async function endSession() {
            if (!confirm('Tem certeza que deseja terminar a sessão? Isto irá libertar o dispositivo para outro operador.')) {
                return;
            }
            
            // Liberar Wake Lock ao terminar sessão
            await releaseWakeLock();
            
            try {
                console.log('🚪 Encerrando sessão...');
                console.log('  Session ID:', sessionId);
                console.log('  Device ID:', currentDevice);
                console.log('  Event ID:', currentEvent.id);
                
                // Parar detecção se estiver ativa
                if (isDetecting) {
                    stopDetection();
                    console.log('✅ Detecção parada');
                }
                
                // Parar câmera
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                    console.log('✅ Câmera desligada');
                }
                
                // Encerrar sessão via API REST
                if (sessionId && pinValidated) {
                    try {
                        console.log('🔄 Encerrando sessão via API REST...', sessionId);
                        const endSessionResponse = await fetch('/api/devices/end-session', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                session_id: sessionId,
                                event_id: currentEvent.id,
                                device_id: currentDevice
                            })
                        });
                        
                        if (endSessionResponse.ok) {
                            const endSessionResult = await endSessionResponse.json();
                            console.log('✅ Sessão encerrada via API REST:', endSessionResult);
                        } else {
                            console.error('❌ Erro ao encerrar sessão via API:', await endSessionResponse.text());
                        }
                    } catch (apiError) {
                        console.error('❌ Erro ao chamar API end-session:', apiError);
                    }
                } else {
                    console.warn('⚠️ sessionId ou pinValidated não disponível:', { sessionId, pinValidated });
                }
                
                // Limpar sessões inativas via API REST
                try {
                    console.log('🧹 Limpando sessões inativas via API REST...');
                    const cleanupResponse = await fetch('/api/devices/cleanup-inactive-sessions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (cleanupResponse.ok) {
                        const cleanupResult = await cleanupResponse.json();
                        console.log('✅ Sessões inativas limpas via API:', cleanupResult);
                    } else {
                        console.error('❌ Erro ao limpar sessões inativas via API:', await cleanupResponse.text());
                    }
                } catch (cleanupApiError) {
                    console.error('❌ Erro ao chamar API cleanup-inactive-sessions:', cleanupApiError);
                }
                
                // Mostrar mensagem
                alert('✅ Sessão encerrada com sucesso! O dispositivo foi libertado.');
                
                // Redirecionar para a página de scanner
                window.location.href = '/detections-kromi.html';
                
            } catch (error) {
                console.error('❌ Erro ao encerrar sessão:', error);
                showError('Erro ao encerrar sessão');
            }
        }
        
        // Encerrar sessão ao sair (automático)
        window.addEventListener('beforeunload', async (e) => {
            if (sessionId && pinValidated) {
                // Libertar dispositivo automaticamente
                await releaseDeviceOnExit();
            }
        });
        
        async function releaseDeviceOnExit() {
            try {
                console.log('🚪 Libertando dispositivo ao sair...');
                
                // Parar detecção
                if (isDetecting) {
                    stopDetection();
                }
                
                // Parar câmera
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                }
                
                // Decrementar sessões ativas usando sendBeacon para garantir
                const updateData = {
                    event_id: currentEvent.id,
                    device_id: currentDevice
                };
                
                // Encerrar sessão via API REST (usando sendBeacon para garantir envio)
                if (sessionId) {
                    try {
                        const sessionData = JSON.stringify({
                            session_id: sessionId,
                            event_id: currentEvent.id,
                            device_id: currentDevice
                        });
                        
                        // Tentar usar sendBeacon para garantir envio mesmo se página fechar
                        if (navigator.sendBeacon) {
                            const blob = new Blob([sessionData], { type: 'application/json' });
                            navigator.sendBeacon('/api/devices/end-session', blob);
                            console.log('✅ Sessão encerrada via sendBeacon');
                        } else {
                            // Fallback para fetch normal
                            await fetch('/api/devices/end-session', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: sessionData,
                                keepalive: true
                            });
                            console.log('✅ Sessão encerrada via fetch');
                        }
                    } catch (error) {
                        console.error('❌ Erro ao libertar:', error);
                    }
                }
                
            } catch (error) {
                console.error('❌ Erro em releaseDeviceOnExit:', error);
            }
        }
        
        function requestCameraPermission() {
            // Show permission panel
            document.getElementById('permissionPanel').style.display = 'flex';
        }
        
        async function startCamera() {
            try {
                // Hide permission panel
                const permissionPanel = document.getElementById('permissionPanel');
                if (permissionPanel) {
                    permissionPanel.style.display = 'none';
                }
                
                console.log('📷 [startCamera] Iniciando câmera com facingMode:', facingMode);
                console.log('📷 [startCamera] cameraStream atual:', !!cameraStream);
                
                // Parar câmera anterior se existir
                if (cameraStream) {
                    console.log('📷 [startCamera] Parando câmera anterior...');
                    cameraStream.getTracks().forEach(track => track.stop());
                    cameraStream = null;
                }
                
                // Request camera access with ideal facingMode and fallback
                console.log('📷 [startCamera] Pedindo permissão getUserMedia...');
                const constraints = {
                    video: {
                        facingMode: { ideal: facingMode }, // Usar ideal para permitir fallback
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };
                
                try {
                    cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (err) {
                    console.warn('⚠️ Erro com constraints específicos:', err);
                    console.log('🔄 Tentando fallback genérico...');
                    // Fallback genérico se facingMode falhar
                    cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
                }
                
                console.log('📷 [startCamera] getUserMedia retornou:', !!cameraStream);
                if (!cameraStream) {
                    throw new Error('getUserMedia retornou null');
                }
                
                // Set video source
                const video = document.getElementById('cameraVideo');
                if (!video) {
                    throw new Error('Elemento cameraVideo não encontrado');
                }
                
                video.srcObject = cameraStream;
                console.log('📷 [startCamera] srcObject atribuído ao video');
                
                // Garantir que o vídeo está tocando (crítico para iOS e alguns Chrome)
                try {
                    await video.play();
                    console.log('📷 [startCamera] video.play() chamado com sucesso');
                } catch (e) {
                    console.warn('⚠️ video.play() falhou:', e);
                }
                
                // Aguardar o video estar pronto - polling simples ao invés de evento
                console.log('📷 [startCamera] Aguardando vídeo ficar pronto...');
                let attempts = 0;
                const maxAttempts = 50; // 5 segundos (50 x 100ms)
                
                while (attempts < maxAttempts) {
                    if (video.videoWidth > 0 && video.videoHeight > 0) {
                        console.log('📷 [startCamera] Video metadata carregada:', video.videoWidth, 'x', video.videoHeight);
                        break;
                    }
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                    
                    if (attempts % 10 === 0) {
                        console.log(`📷 [startCamera] Aguardando... tentativa ${attempts}/${maxAttempts}`);
                    }
                }
                
                // Se ainda não tiver dimensões, avisar mas continuar mesmo assim
                if (video.videoWidth === 0 || video.videoHeight === 0) {
                    console.warn('⚠️ [startCamera] Vídeo ainda sem dimensões após timeout, mas continuando...');
                    console.warn('⚠️ [startCamera] Pode levar mais alguns segundos para estabilizar');
                }
                
                console.log('✅ Câmera iniciada:', facingMode === 'environment' ? 'Traseira' : 'Frontal');
                console.log('✅ Video dimensões:', video.videoWidth, 'x', video.videoHeight);
                
                // Show detection area
                setupDetectionArea();
                
            } catch (error) {
                console.error('❌ Erro ao acessar câmera:', error);
                console.error('❌ Stack:', error.stack);
                cameraStream = null;
                showError('Não foi possível acessar a câmera. Verifique as permissões.');
                throw error; // Re-throw para que o chamador saiba que falhou
            }
        }
        
        function setupDetectionArea() {
            const overlay = document.getElementById('cameraOverlay');
            const detectionArea = document.createElement('div');
            detectionArea.className = 'detection-area';
            detectionArea.id = 'detectionArea';
            
            // Garantir estilos mínimos inline (caso CSS externo não carregue)
            detectionArea.style.position = 'absolute';
            detectionArea.style.left = '50%';
            detectionArea.style.top = '50%';
            detectionArea.style.transform = 'translate(-50%, -50%)';
            detectionArea.style.width = '80%';
            detectionArea.style.height = '60%';
            detectionArea.style.border = '2px dashed rgba(255,255,255,0.3)';
            detectionArea.style.pointerEvents = 'none'; // Não interferir com cliques
            
            overlay.appendChild(detectionArea);
        }
        
        let isStartingDetection = false; // Prevenir chamadas duplicadas
        
        async function startDetection() {
            // Inicializar áudio no primeiro gesto do utilizador
            initDetectionSound();
            
            // Prevenir chamadas duplicadas
            if (isStartingDetection) {
                console.log('⚠️ startDetection já em andamento, ignorando chamada duplicada...');
                return;
            }
            
            if (isDetecting) {
                console.log('⚠️ Detecção já está em andamento');
                return;
            }
            
            isStartingDetection = true;
            console.log('🎯 [startDetection] Função chamada');
            
            try {
                console.log('🔍 [startDetection] Verificando estado inicial...');
                console.log('🔍 [startDetection] cameraStream:', !!cameraStream);
                console.log('🔍 [startDetection] isDetecting:', isDetecting);
                console.log('🔍 [startDetection] isStartingDetection:', isStartingDetection);
                
                // Se a câmera não está iniciada, pedir permissão e iniciar primeiro
                if (!cameraStream) {
                    console.log('📷 [startDetection] Câmera não iniciada, pedindo permissão primeiro...');
                    try {
                        await startCamera();
                        console.log('📷 [startDetection] startCamera() completou, cameraStream:', !!cameraStream);
                    } catch (cameraError) {
                        console.error('❌ [startDetection] Erro ao iniciar câmera:', cameraError);
                        showError('Não foi possível acessar a câmera. Verifique as permissões.');
                        isStartingDetection = false;
                        return;
                    }
                    
                    // Se ainda não conseguiu iniciar a câmera, abortar
                    if (!cameraStream) {
                        console.error('❌ [startDetection] Câmera ainda não iniciada após startCamera()');
                        showError('Não foi possível acessar a câmera. Verifique as permissões.');
                        isStartingDetection = false;
                        return;
                    }
                    console.log('✅ [startDetection] Câmera confirmada como ativa');
                } else {
                    console.log('✅ [startDetection] Câmera já está iniciada');
                }
            
                // Obter localização GPS após gesto do usuário (iniciar detecção)
                if (!currentPosition) {
                    await getCurrentLocation();
                }
                
                // CRÍTICO: Definir isDetecting como true ANTES de qualquer outra coisa
                // e usar flag de proteção para prevenir alterações acidentais durante a inicialização
                window._isDetectingLocked = true;
                
                isDetecting = true;
                detectionCount = 0;
                motionDetected = false;
                lastFrame = null;
                consecutiveMotionFrames = 0; // Reset contador ao iniciar
                
                // Reset contadores de debug
                window._motionCheckCount = 0;
                window._captureCheckCount = 0;
                window._videoReadyCount = 0;
                
                console.log('✅ [startDetection] isDetecting definido como true e protegido temporariamente');
                
                // Update UI - usar setTimeout para evitar cliques acidentais
                document.getElementById('startDetection').style.display = 'none';
                // Pequeno delay antes de mostrar botão stop para evitar cliques acidentais
                await new Promise(resolve => setTimeout(resolve, 100));
                const stopBtn = document.getElementById('stopDetection');
                if (stopBtn) {
                    stopBtn.style.display = 'inline-flex';
                    // Adicionar pequeno delay adicional antes de permitir cliques
                    stopBtn.style.pointerEvents = 'none';
                    setTimeout(() => {
                        stopBtn.style.pointerEvents = 'auto';
                    }, 200);
                }
                
                // Aguardar um pouco para garantir que o video esteja pronto
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Verificar se video está pronto antes de iniciar detecção
                const video = document.getElementById('cameraVideo');
                if (!video || !video.videoWidth || !video.videoHeight) {
                    console.warn('⚠️ Video ainda não está pronto, aguardando...');
                    // Aguardar mais um pouco
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                console.log('✅ Iniciando detecção de movimento...');
                console.log(`   Video: ${video?.videoWidth}x${video?.videoHeight}`);
                console.log(`   Threshold PESSOA: ${motionThresholdPerson}, AMBIENTE: ${motionThresholdAmbient}`);
                console.log(`   MinFrames: ${minMotionFrames}`);
                console.log(`   isDetecting ANTES de criar intervalos:`, isDetecting);
                console.log(`   cameraStream ANTES de criar intervalos:`, !!cameraStream);
                
                // Verificar se está tudo ok antes de criar intervalos
                if (!isDetecting) {
                    console.error('❌ ERRO: isDetecting é false antes de criar intervalos!');
                    throw new Error('isDetecting não está true');
                }
                if (!cameraStream) {
                    console.error('❌ ERRO: cameraStream é null antes de criar intervalos!');
                    throw new Error('câmera não está disponível');
                }
                
                // Limpar intervalos anteriores se existirem (segurança)
                if (motionCheckInterval) {
                    console.warn('⚠️ Limpando intervalo anterior de movimento...');
                    clearInterval(motionCheckInterval);
                    motionCheckInterval = null;
                }
                if (captureInterval) {
                    console.warn('⚠️ Limpando intervalo anterior de captura...');
                    clearInterval(captureInterval);
                    captureInterval = null;
                }
                
                // Iniciar verificação de movimento (a cada 500ms)
                console.log('🔄 Criando intervalo de verificação de movimento...');
                try {
                    motionCheckInterval = setInterval(() => {
                        console.log('🔄 [INTERVALO] Chamado - isDetecting:', isDetecting);
                        if (!isDetecting) {
                            console.log('⚠️ Intervalo chamado mas isDetecting=false, limpando...');
                            clearInterval(motionCheckInterval);
                            motionCheckInterval = null;
                            return;
                        }
                        if (!cameraStream) {
                            console.log('⚠️ Intervalo chamado mas cameraStream=null, limpando...');
                            clearInterval(motionCheckInterval);
                            motionCheckInterval = null;
                            return;
                        }
                        console.log('🔄 [INTERVALO] Chamando detectMotion()...');
                        detectMotion();
                    }, 500);
                    console.log('✅ Intervalo criado:', motionCheckInterval);
                    if (!motionCheckInterval) {
                        throw new Error('setInterval retornou null/undefined');
                    }
                } catch (intervalError) {
                    console.error('❌ ERRO ao criar motionCheckInterval:', intervalError);
                    throw intervalError;
                }
                
                // Start continuous capture to buffer (every 1 second) - SEM cooldown para pegar todos os dorsais do grupo
                captureInterval = setInterval(() => {
                    if (motionDetected && isDetecting) {
                        // CAPTURA CONTÍNUA quando há pessoa - importante para grupos/pelotões
                        console.log('📸 Capturando (pessoa/grupo no quadro)...');
                        captureToBuffer();
                    } else if (isDetecting) {
                        // Log periódico se não há movimento de pessoa
                        if (!window._captureCheckCount) window._captureCheckCount = 0;
                        window._captureCheckCount++;
                        if (window._captureCheckCount % 10 === 0) {
                            console.log(`⏸️ Aguardando pessoa/grupo passar... (check #${window._captureCheckCount})`);
                        }
                    }
                }, 1000);
                
                // Verificar se os intervalos foram criados corretamente
                if (!motionCheckInterval) {
                    console.error('❌ ERRO CRÍTICO: motionCheckInterval não foi criado!');
                    throw new Error('Falha ao criar intervalo de detecção de movimento');
                }
                if (!captureInterval) {
                    console.error('❌ ERRO CRÍTICO: captureInterval não foi criado!');
                    throw new Error('Falha ao criar intervalo de captura');
                }
                
                // Verificar novamente antes de finalizar
                if (!isDetecting) {
                    console.error('❌ ERRO CRÍTICO: isDetecting foi alterado para false após criar intervalos!');
                    throw new Error('isDetecting foi alterado durante a inicialização');
                }
                if (!cameraStream) {
                    console.error('❌ ERRO CRÍTICO: cameraStream foi alterado para null após criar intervalos!');
                    throw new Error('cameraStream foi alterado durante a inicialização');
                }
                
                // Log final confirmando que tudo foi iniciado
                console.log('🎯 ========== DETECÇÃO INTELIGENTE INICIADA ==========');
                console.log('📊 Sistema de Detecção de PESSOAS/GRUPOS:');
                console.log(`   🟢 Threshold PESSOA: ${motionThresholdPerson} (ciclista/corredor) → CAPTURA`);
                console.log(`   🟡 Threshold AMBIENTE: ${motionThresholdAmbient} (folhas/vento) → IGNORA`);
                console.log(`   ⚪ Abaixo de ${motionThresholdAmbient}: sem movimento`);
                console.log(`   📏 minMotionFrames: ${minMotionFrames} frames consecutivos`);
                console.log(`   🔍 step: 4 (analisa 1 em cada 4 pixels)`);
                console.log(`   📐 Resolução análise: 640x480`);
                console.log(`   📸 Captura: CONTÍNUA a cada 1s quando há pessoa/grupo`);
                console.log('📊 Captura TODOS os dorsais do grupo (SEM cooldown)');
                console.log('🍃 IGNORA movimento ambiente (3-15): vento, folhas, sombras');
                console.log('🚴 Ideal para pelotões e grupos de corredores');
                console.log('🔒 Wake Lock ativo - dispositivo não entrará em suspensão');
                console.log('✅ Intervalos criados - motionCheckInterval:', motionCheckInterval, 'captureInterval:', captureInterval);
                console.log('✅ Estado FINAL: isDetecting=', isDetecting, 'cameraStream=', !!cameraStream, 'videoReady=', !!(video?.videoWidth && video?.videoHeight));
                console.log('✅ Variáveis globais: motionCheckInterval=', !!motionCheckInterval, 'captureInterval=', !!captureInterval);
                console.log('🎯 =========================================');
                
                // Testar imediatamente se detectMotion funciona - testar várias vezes
                console.log('🧪 Testando detectMotion() imediatamente...');
                setTimeout(() => {
                    console.log('🧪 [TESTE] Verificando estado antes de testar...');
                    console.log('   isDetecting:', isDetecting);
                    console.log('   cameraStream:', !!cameraStream);
                    console.log('   motionCheckInterval:', !!motionCheckInterval);
                    
                    if (isDetecting && cameraStream) {
                        console.log('🧪 [TESTE 1] Executando detectMotion() manualmente para teste...');
                        detectMotion();
                        
                        // Testar novamente após 1 segundo
                        setTimeout(() => {
                            if (isDetecting && cameraStream) {
                                console.log('🧪 [TESTE 2] Executando detectMotion() manualmente novamente...');
                                detectMotion();
                            } else {
                                console.warn('🧪 [TESTE 2] ⚠️ Estado alterado - isDetecting:', isDetecting, 'cameraStream:', !!cameraStream);
                            }
                        }, 1000);
                    } else {
                        console.warn('🧪 ⚠️ Não é possível testar - isDetecting:', isDetecting, 'cameraStream:', !!cameraStream);
                        if (!isDetecting) {
                            console.error('🧪 ❌ ERRO: isDetecting foi alterado para false! Alguém chamou stopDetection()?');
                        }
                        if (!cameraStream) {
                            console.error('🧪 ❌ ERRO: cameraStream foi alterado para null! A câmera foi parada?');
                        }
                    }
                }, 1000);
                
                // Log de confirmação periódico
                setTimeout(() => {
                    console.log('📊 [STATUS APÓS 3s] isDetecting:', isDetecting, 'motionCheckInterval:', !!motionCheckInterval, 'captureInterval:', !!captureInterval);
                    if (!isDetecting) {
                        console.error('📊 ❌ PROBLEMA: isDetecting é false após 3 segundos! Algo parou a detecção.');
                    }
                    if (!motionCheckInterval) {
                        console.error('📊 ❌ PROBLEMA: motionCheckInterval foi limpo! Algo parou o intervalo.');
                    }
                }, 3000);
                
                // Desbloquear proteção após inicialização completa
                setTimeout(() => {
                    if (window._isDetectingLocked) {
                        delete window._isDetectingLocked;
                        console.log('🔓 Proteção de isDetecting removida após inicialização completa');
                    }
                }, 5000);
                
            } catch (error) {
                console.error('❌ Erro ao iniciar detecção:', error);
                console.error('❌ Stack trace:', error.stack);
                showError('Erro ao iniciar detecção: ' + error.message);
                isDetecting = false;
                delete window._isDetectingLocked;
                document.getElementById('startDetection').style.display = 'inline-flex';
                document.getElementById('stopDetection').style.display = 'none';
            } finally {
                isStartingDetection = false;
                delete window._isDetectingLocked;
            }
        }
        
        function stopDetection() {
            // Log stack trace para descobrir quem está chamando
            console.log('⏹️ stopDetection() chamada');
            console.trace('Stack trace de stopDetection:');
            
            // Verificar se está protegido durante inicialização
            if (window._isDetectingLocked) {
                console.warn('⚠️ stopDetection() chamada durante inicialização protegida! Ignorando...');
                console.warn('⚠️ Se esta chamada for legítima, aguarde a conclusão da inicialização.');
                return; // Prevenir parada durante inicialização
            }
            
            isDetecting = false;
            motionDetected = false;
            
            // Stop capture interval
            if (captureInterval) {
                clearInterval(captureInterval);
                captureInterval = null;
            }
            
            // Stop motion detection interval
            if (motionCheckInterval) {
                clearInterval(motionCheckInterval);
                motionCheckInterval = null;
            }
            
            lastFrame = null;
            consecutiveMotionFrames = 0;
            
            // Update UI
            document.getElementById('startDetection').style.display = 'inline-flex';
            document.getElementById('stopDetection').style.display = 'none';
            
            console.log('⏹️ Detecção parada');
        }
        
        // Função para garantir que as canvas estão criadas e com tamanho correto
        function ensureCanvases(video) {
            if (!_motionCanvas) {
                _motionCanvas = document.createElement('canvas');
                _motionCtx = _motionCanvas.getContext('2d', { willReadFrequently: true });
                console.log('🖼️ Canvas de movimento criada');
            }
            if (!_analysisCanvas) {
                _analysisCanvas = document.createElement('canvas');
                _analysisCtx = _analysisCanvas.getContext('2d', { willReadFrequently: true });
                console.log('🖼️ Canvas de análise criada');
            }
            _motionCanvas.width = video.videoWidth;
            _motionCanvas.height = video.videoHeight;
            
            // Usar resolução maior para análise (640x480 ou metade do vídeo, o que for menor)
            // Isso permite detectar movimento em mais detalhes mantendo performance
            const aw = Math.min(video.videoWidth, 640);
            const ah = Math.min(video.videoHeight, 480);
            _analysisCanvas.width = aw;
            _analysisCanvas.height = ah;
            
            console.log(`🖼️ Canvas configuradas: Motion=${_motionCanvas.width}x${_motionCanvas.height}, Analysis=${aw}x${ah}`);
        }
        
        function detectMotion() {
            // Log SEMPRE na primeira chamada para debug
            if (!window._detectMotionCallCount) {
                window._detectMotionCallCount = 0;
                console.log('🔴 detectMotion() PRIMEIRA CHAMADA - iniciando contagem');
            }
            window._detectMotionCallCount++;
            
            // Log a cada 3 chamadas para debug
            if (window._detectMotionCallCount % 3 === 0) {
                console.log(`🔵 detectMotion() #${window._detectMotionCallCount} - isDetecting=${isDetecting}, cameraStream=${!!cameraStream}`);
            }
            
            if (!isDetecting || !cameraStream) {
                if (!isDetecting) {
                    if (!window._skipIsDetectingLog) {
                        console.log('⚠️ detectMotion: isDetecting=false - parando verificação');
                        window._skipIsDetectingLog = true;
                        setTimeout(() => { window._skipIsDetectingLog = false; }, 5000);
                    }
                }
                if (!cameraStream) {
                    if (!window._skipCameraStreamLog) {
                        console.log('⚠️ detectMotion: cameraStream=null - câmera não disponível');
                        window._skipCameraStreamLog = true;
                        setTimeout(() => { window._skipCameraStreamLog = false; }, 5000);
                    }
                }
                return;
            }
            
            try {
                const video = document.getElementById('cameraVideo');
                if (!video) {
                    console.error('❌ detectMotion: elemento video não encontrado');
                    return;
                }
                
                if (!video.videoWidth || !video.videoHeight) {
                    // Log periódico se video ainda não está pronto
                    if (!window._videoReadyCount) window._videoReadyCount = 0;
                    window._videoReadyCount++;
                    if (window._videoReadyCount % 10 === 0) {
                        console.log(`⏳ detectMotion: video ainda não pronto (width=${video.videoWidth}, height=${video.videoHeight}, check #${window._videoReadyCount})`);
                    }
                    return;
                }
                
                // Garantir que as canvas estão criadas e com tamanho correto
                ensureCanvases(video);
                
                // Capturar frame atual usando canvas reutilizável
                _motionCtx.drawImage(video, 0, 0, _motionCanvas.width, _motionCanvas.height);
                
                // Reduzir resolução para análise de movimento usando canvas reutilizável
                _analysisCtx.drawImage(_motionCanvas, 0, 0, _analysisCanvas.width, _analysisCanvas.height);
                
                const currentFrameData = _analysisCtx.getImageData(0, 0, _analysisCanvas.width, _analysisCanvas.height);
                
                // Log periódico para confirmar que está a processar frames
                if (window._detectMotionCallCount % 5 === 0) {
                    console.log(`🎬 Frame capturado #${window._detectMotionCallCount} (${_analysisCanvas.width}x${_analysisCanvas.height})`);
                }
                
                if (!lastFrame) {
                    // Primeiro frame, guardar e sair
                    lastFrame = currentFrameData;
                    console.log('📸 Primeiro frame capturado para referência:', _analysisCanvas.width, 'x', _analysisCanvas.height);
                    console.log('   Aguardando segundo frame para iniciar comparação...');
                    console.log(`   Total de pixels a analisar: ${currentFrameData.data.length / 4}`);
                    return;
                }
                
                // Log periódico após o primeiro frame
                if (window._detectMotionCallCount && window._detectMotionCallCount % 10 === 0) {
                    console.log(`✅ Comparando frames... (chamada #${window._detectMotionCallCount})`);
                }
                
                // Comparar frames - calcular diferença total
                let totalDifference = 0;
                let pixels = currentFrameData.data;
                let lastPixels = lastFrame.data;
                
                // Comparar 1 em cada 4 pixels para melhor detecção (ajustado para maior sensibilidade)
                const step = 4;
                let pixelCount = 0;
                for (let i = 0; i < pixels.length; i += step * 4) {
                    // Calcular diferença de brilho
                    const brightness = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
                    const lastBrightness = (lastPixels[i] + lastPixels[i + 1] + lastPixels[i + 2]) / 3;
                    totalDifference += Math.abs(brightness - lastBrightness);
                    pixelCount++;
                }
                
                const averageDifference = pixelCount > 0 ? totalDifference / pixelCount : 0;
                
                // Log SEMPRE as primeiras 5 comparações e depois a cada 10 para debug
                if (!window._motionCheckCount) window._motionCheckCount = 0;
                window._motionCheckCount++;
                if (window._motionCheckCount <= 5 || window._motionCheckCount % 10 === 0) {
                    const status = averageDifference > motionThresholdPerson ? '🟢 PESSOA' : 
                                   averageDifference > motionThresholdAmbient ? '🟡 Ambiente' : '⚪ Parado';
                    console.log(`🔍 #${window._motionCheckCount}: diff=${averageDifference.toFixed(2)} ${status} | pessoa>${motionThresholdPerson}, ambiente>${motionThresholdAmbient} | consecutive=${consecutiveMotionFrames}/${minMotionFrames}, detected=${motionDetected}`);
                }
                
                // SISTEMA INTELIGENTE: Só deteta PESSOAS, ignora movimento ambiente
                if (averageDifference > motionThresholdPerson) {
                    // MOVIMENTO SIGNIFICATIVO (pessoa a passar)
                    consecutiveMotionFrames++;
                    
                    // Log quando movimento é detectado mas ainda não atingiu o mínimo
                    if (consecutiveMotionFrames > 0 && consecutiveMotionFrames < minMotionFrames) {
                        console.log(`🚶 Movimento de PESSOA detectado: ${consecutiveMotionFrames}/${minMotionFrames} frames (diff=${averageDifference.toFixed(2)})`);
                    }
                    
                    if (consecutiveMotionFrames >= minMotionFrames && !motionDetected) {
                        motionDetected = true;
                        console.log('📸 ✅✅✅ PESSOA/GRUPO DETECTADO! Captura contínua iniciada...');
                        console.log(`   Diferença: ${averageDifference.toFixed(2)}, Threshold Pessoa: ${motionThresholdPerson}`);
                        console.log(`   Frames consecutivos: ${consecutiveMotionFrames}`);
                        console.log(`   🎯 Ciclista(s)/Corredor(es) a passar!`);
                        console.log(`   📸 Capturando a cada 1s para pegar TODOS os dorsais`);
                        
                        // Visual feedback VERDE (pessoa/grupo)
                        const overlay = document.getElementById('cameraOverlay');
                        if (overlay) {
                            overlay.style.border = '4px solid #10b981';
                            overlay.style.boxShadow = '0 0 20px rgba(16, 185, 129, 0.5)';
                            setTimeout(() => {
                                overlay.style.border = 'none';
                                overlay.style.boxShadow = 'none';
                            }, 1500);
                        }
                    }
                } else if (averageDifference > motionThresholdAmbient) {
                    // MOVIMENTO AMBIENTE (folhas, sombras, vento) - IGNORA
                    // Log periódico para debug
                    if (window._motionCheckCount % 20 === 0) {
                        console.log(`🍃 Movimento ambiente ignorado (diff=${averageDifference.toFixed(2)}, threshold pessoa=${motionThresholdPerson})`);
                    }
                    // Reduzir contador gradualmente
                    if (consecutiveMotionFrames > 0) {
                        consecutiveMotionFrames = Math.max(0, consecutiveMotionFrames - 1);
                    }
                } else {
                    // SEM MOVIMENTO - Reset completo
                    if (consecutiveMotionFrames > 0) {
                        consecutiveMotionFrames = Math.max(0, consecutiveMotionFrames - 1);
                    }
                    
                    if (consecutiveMotionFrames === 0 && motionDetected) {
                        motionDetected = false;
                        console.log('💤 Pessoa/Grupo saiu do quadro. Aguardando próxima passagem...');
                    }
                }
                
                // Atualizar último frame
                lastFrame = currentFrameData;
                
            } catch (error) {
                console.error('❌ Erro na detecção de movimento:', error);
            }
        }
        
        async function captureToBuffer() {
            if (!isDetecting || !cameraStream) return;
            
            try {
                // Atualizar localização GPS antes de capturar
                await updateCurrentLocation();
                
                const video = document.getElementById('cameraVideo');
                if (!video.videoWidth || !video.videoHeight) return;
                
                // Capture image from video com resolução reduzida (para evitar 413 Payload Too Large)
                const canvas = document.createElement('canvas');
                
                // Reduzir resolução para máximo 1280x720 (HD ready) para reduzir payload
                const maxWidth = 1280;
                const maxHeight = 720;
                let width = video.videoWidth;
                let height = video.videoHeight;
                
                if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width = Math.floor(width * ratio);
                    height = Math.floor(height * ratio);
                }
                
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, width, height);
                
                // Convert to base64 com qualidade reduzida para AI (evitar payload grande)
                const aiVersion = canvas.toDataURL('image/jpeg', 0.5); // 50% quality - suficiente para AI
                const displayVersion = canvas.toDataURL('image/jpeg', 0.7); // 70% quality para display
                
                console.log(`📸 Imagem capturada: ${width}x${height}, qualidade AI: 50%, display: 70%`);
                
                const now = new Date();
                
                // Log GPS com cada captura
                console.log(`📍 GPS captura ${detectionCount + 1}:`, currentPosition);
                
                // Create buffer entry
                const bufferEntry = {
                    event_id: currentEvent.id,
                    device_id: currentDevice,
                    session_id: sessionId,
                    image_data: aiVersion,
                    display_image: displayVersion,
                    image_metadata: {
                        width: canvas.width,
                        height: canvas.height,
                        device_type: 'mobile',
                        timestamp: now.toISOString(),
                        gps_updated: true
                    },
                    captured_at: now.toISOString(),
                    latitude: currentPosition?.latitude || null,
                    longitude: currentPosition?.longitude || null,
                    accuracy: currentPosition?.accuracy || null,
                    status: 'pending'
                };
                
                // Enviar detecção via API REST
                try {
                    const response = await fetch('/api/detections', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(bufferEntry)
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                        console.error('❌ Erro ao salvar detecção via API:', errorData);
                    } else {
                        const result = await response.json();
                        console.log('✅ Detecção salva via API REST:', result.detection?.id);
                        
                        detectionCount++;
                        document.getElementById('detectionCount').textContent = detectionCount;
                        
                        // Flash detection area green
                        const overlay = document.getElementById('cameraOverlay');
                        overlay.style.border = '4px solid #10b981';
                        setTimeout(() => {
                            overlay.style.border = 'none';
                        }, 200);
                    }
                } catch (error) {
                    console.error('❌ Erro ao enviar detecção:', error);
                }
                
                // Tocar som de detecção (sempre, independente do sucesso da API)
                playDetectionSound();
                
            } catch (error) {
                console.error('❌ Erro na captura:', error);
            }
        }
        
        async function getCurrentLocation() {
            if (!navigator.geolocation) {
                console.log('⚠️ Geolocalização não disponível');
                return;
            }
            
            try {
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    });
                });
                
                currentPosition = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy
                };
                
                console.log('📍 Localização inicial obtida:', currentPosition);
            } catch (error) {
                console.log('⚠️ Erro ao obter localização:', error.message);
                currentPosition = null;
            }
        }
        
        // Função para atualizar localização GPS (chamada antes de cada captura)
        async function updateCurrentLocation() {
            if (!navigator.geolocation) {
                console.log('⚠️ Geolocalização não disponível');
                return;
            }
            
            try {
                // Obter posição atual rapidamente (timeout menor para não atrasar captura)
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 3000, // Timeout mais curto para captura rápida
                        maximumAge: 5000 // Aceitar cache de até 5 segundos
                    });
                });
                
                currentPosition = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy
                };
                
                console.log('📍 GPS atualizado para captura:', currentPosition);
            } catch (error) {
                // Se falhar, usar posição anterior (se existir)
                console.log('⚠️ Erro ao atualizar GPS, usando anterior:', error.message);
                if (!currentPosition) {
                    console.log('⚠️ Nenhuma posição GPS disponível para esta captura');
                }
            }
        }
        
        async function registerDevice(eventId, deviceId) {
            if (!deviceId) {
                console.warn('⚠️ deviceId não disponível');
                return;
            }
            
            try {
                // Atualizar last_seen do dispositivo via API REST
                const response = await fetch(`/api/devices/${deviceId}/last-seen`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_agent: navigator.userAgent
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    console.warn('⚠️ Aviso ao atualizar dispositivo via API:', errorData);
                } else {
                    console.log('✅ Dispositivo registrado no evento via API REST');
                }
            } catch (error) {
                console.warn('⚠️ Erro ao registrar dispositivo:', error.message);
            }
        }
        
        async function switchCamera() {
            console.log('🔄 Trocando câmera...');
            
            try {
                // Alternar entre traseira e frontal
                facingMode = facingMode === 'environment' ? 'user' : 'environment';
                console.log('📍 Modo de câmera:', facingMode === 'environment' ? 'Traseira' : 'Frontal');
                
                // Parar câmera atual
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                }
                
                // Parar detecção se estiver ativa
                if (isDetecting) {
                    await stopDetection();
                }
                
                // Iniciar nova câmera
                await startCamera();
                
                // Se estava detectando, reiniciar detecção
                if (isDetecting) {
                    await startDetection();
                }
                
            } catch (error) {
                console.error('❌ Erro ao trocar câmera:', error);
                showError('Erro ao trocar câmera');
            }
        }
        
        let flashEnabled = false;
        async function toggleFlash() {
            console.log('⚡ toggleFlash() chamada');
            
            try {
                if (!cameraStream) {
                    console.error('❌ Câmera não iniciada');
                    showError('Câmera não iniciada');
                    return;
                }
                
                const track = cameraStream.getVideoTracks()[0];
                const capabilities = track.getCapabilities();
                
                if (!capabilities.torch) {
                    showError('Flash não disponível neste dispositivo');
                    return;
                }
                
                flashEnabled = !flashEnabled;
                await track.applyConstraints({
                    advanced: [{ torch: flashEnabled }]
                });
                
                const flashBtn = document.getElementById('toggleFlash');
                if (flashEnabled) {
                    flashBtn.innerHTML = '<i>🔦</i> Flash ON';
                    flashBtn.classList.remove('btn-warning');
                    flashBtn.classList.add('btn-success');
                    console.log('⚡ Flash ativado');
                } else {
                    flashBtn.innerHTML = '<i>⚡</i> Flash';
                    flashBtn.classList.remove('btn-success');
                    flashBtn.classList.add('btn-warning');
                    console.log('⚡ Flash desativado');
                }
            } catch (error) {
                console.error('❌ Erro ao alternar flash:', error);
                showError('Erro ao controlar o flash');
            }
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        // Função para inicializar som de detecção (apenas no primeiro gesto)
        function initDetectionSound() {
            if (audioReady) return; // Já foi inicializado
            
            // Criar som usando Web Audio API (beeep simples)
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800; // Frequência do beep
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
                
                audioReady = true; // Marcar como inicializado
                console.log('🔊 Som de detecção inicializado');
            } catch (error) {
                console.warn('⚠️ Não foi possível inicializar som:', error);
            }
        }
        
        // Função para tocar som de detecção
        function playDetectionSound() {
            if (!soundEnabled) return;
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
                
                console.log('🔊 Som de detecção tocado');
            } catch (error) {
                console.warn('⚠️ Erro ao tocar som:', error);
            }
        }
        
        // Função para alternar som
        function toggleSound() {
            // Inicializar áudio no primeiro gesto do utilizador
            initDetectionSound();
            
            soundEnabled = !soundEnabled;
            
            const soundBtn = document.getElementById('toggleSoundBtn');
            if (soundEnabled) {
                soundBtn.innerHTML = '<i>🔊</i> <span class="btn-text">Som</span>';
                soundBtn.classList.remove('btn-warning');
                soundBtn.classList.add('btn-success');
                console.log('🔊 Som ativado');
            } else {
                soundBtn.innerHTML = '<i>🔇</i> <span class="btn-text">Mudo</span>';
                soundBtn.classList.remove('btn-success');
                soundBtn.classList.add('btn-warning');
                console.log('🔇 Som desativado');
            }
        }
        
        async function loadEventInfo(eventId, eventName) {
            try {
                console.log('📋 Carregando informações do evento...', eventId);
                
                // Buscar dispositivo via API REST (página pública)
                let deviceData = null;
                try {
                    const deviceResponse = await fetch(`/api/devices/by-event-device?event_id=${encodeURIComponent(eventId)}&device_id=${encodeURIComponent(currentDevice)}`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (deviceResponse.ok) {
                        const deviceResult = await deviceResponse.json();
                        if (deviceResult.success && deviceResult.device) {
                            deviceData = deviceResult.device;
                            console.log('✅ DeviceData carregado via API:', deviceData);
                        }
                    } else {
                        console.warn('⚠️ Erro ao buscar device via API:', deviceResponse.status);
                    }
                } catch (deviceErr) {
                    console.warn('⚠️ Erro ao buscar device:', deviceErr);
                }
                
                // Buscar dados do evento via API server-side (usa SERVICE_ROLE_KEY)
                let eventNameFromDB = null;
                let eventDateFromDB = null;
                
                try {
                    console.log('🔍 Buscando evento via API server-side...');
                    const response = await fetch(`/api/event/${eventId}`);
                    
                    if (response.ok) {
                        const eventData = await response.json();
                        console.log('📋 EventData da API:', eventData);
                        eventNameFromDB = eventData.name;
                        eventDateFromDB = eventData.event_date;
                        console.log('✅ Nome:', eventNameFromDB, 'Data:', eventDateFromDB);
                    } else {
                        console.log('⚠️ API retornou status:', response.status);
                    }
                } catch (err) {
                    console.error('❌ Erro ao buscar evento via API:', err);
                }
                
                // Update UI com nome do evento
                // Se não conseguiu da DB, usar da URL, senão fallback
                let eventNameDisplay = eventNameFromDB || eventName || 'Evento Teste';
                
                console.log('✅ Exibindo nome do evento:', eventNameDisplay);
                document.getElementById('eventName').textContent = eventNameDisplay;
                
                // Update UI com data do evento
                if (eventDateFromDB) {
                    const formattedDate = new Date(eventDateFromDB).toLocaleDateString('pt-PT', {
                        day: '2-digit',
                        month: 'short',
                        year: 'numeric'
                    });
                    document.getElementById('eventDate').textContent = formattedDate;
                    console.log('✅ Data do evento:', formattedDate);
                } else {
                    document.getElementById('eventDate').textContent = '-';
                }
                
                // Update UI com tipo de checkpoint
                const checkpointType = deviceData?.checkpoint_type || '-';
                const checkpointTypeDisplay = checkpointType === 'start' ? '🏁 Partida' :
                                             checkpointType === 'checkpoint' ? '📍 Checkpoint' :
                                             checkpointType === 'finish' ? '🏆 Chegada' :
                                             '📍 ' + checkpointType;
                document.getElementById('checkpointType').textContent = checkpointTypeDisplay;
                
                // Update UI com ordem do dispositivo
                const deviceOrder = deviceData?.checkpoint_order || '-';
                document.getElementById('deviceOrder').textContent = `#${deviceOrder}`;
                
                // Atualizar currentEvent com nome completo
                if (eventNameFromDB) {
                    currentEvent.name = eventNameFromDB;
                    console.log('✅ currentEvent.name atualizado da DB:', currentEvent.name);
                } else if (eventName) {
                    // Se não conseguiu da DB, usar da URL
                    currentEvent.name = eventName;
                    console.log('✅ currentEvent.name atualizado da URL:', currentEvent.name);
                }
                
            } catch (error) {
                console.error('❌ Erro ao carregar info do evento:', error);
                // Fallback para dados básicos
                const fallbackName = eventName || 'Evento';
                console.log('⚠️ Usando nome fallback:', fallbackName);
                document.getElementById('eventName').textContent = fallbackName;
            }
        }
        
        function showError(message) {
            // Create toast notification
            const toast = document.createElement('div');
            toast.className = 'toast toast-error';
            toast.innerHTML = `
                <div class="toast-icon">❌</div>
                <div class="toast-content">
                    <div class="toast-message">${message}</div>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 5000);
        }
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
    
    <!-- All styles moved to external CSS files -->
</body>
</html>
