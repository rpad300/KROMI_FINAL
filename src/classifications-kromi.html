<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#fc6b03">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <title>Kromi.online - Classifica√ß√µes</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- KROMI Design System -->
    <link rel="stylesheet" href="/kromi-design-system.css">
    <link rel="stylesheet" href="/kromi-layout-fixes.css">
    
    <!-- Sistema de Navega√ß√£o Unificado -->
    <link rel="stylesheet" href="/navigation-component.css?v=2025102601">
    <link rel="stylesheet" href="/unified-sidebar-styles.css?v=2025102601">
    <link rel="stylesheet" href="/logo-integration.css?v=2025012701">
    
    <style>
        /* Classifications specific styles */
        .classifications-grid {
            display: grid;
            gap: var(--spacing-5);
            margin-bottom: var(--spacing-6);
        }
        
        .event-selector-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-xl);
            padding: var(--spacing-6);
        }
        
        .event-info-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-xl);
            padding: var(--spacing-6);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--spacing-4);
            margin-bottom: var(--spacing-6);
        }
        
        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-4);
            text-align: center;
        }
        
        .stat-value {
            font-size: var(--font-size-2xl);
            font-weight: 700;
            color: var(--primary);
            margin-bottom: var(--spacing-1);
        }
        
        .stat-label {
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .classifications-table {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-xl);
            overflow: hidden;
        }
        
        .table-header {
            background: var(--bg-tertiary);
            padding: var(--spacing-4);
            border-bottom: 1px solid var(--border-color);
        }
        
        .table-title {
            font-size: var(--font-size-xl);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .table-container {
            overflow-x: auto;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .data-table th {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: 600;
            padding: var(--spacing-3) var(--spacing-4);
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            font-size: var(--font-size-sm);
        }
        
        .data-table td {
            padding: var(--spacing-3) var(--spacing-4);
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: var(--font-size-sm);
        }
        
        .data-table tr:hover {
            background: var(--bg-tertiary);
        }
        
        .rank-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-weight: 600;
            font-size: var(--font-size-sm);
        }
        
        .rank-1 { background: var(--warning); color: white; }
        .rank-2 { background: var(--text-tertiary); color: white; }
        .rank-3 { background: var(--danger); color: white; }
        .rank-other { background: var(--bg-tertiary); color: var(--text-secondary); }
        
        .time-display {
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }
        
        .controls {
            display: flex;
            gap: var(--spacing-3);
            margin-bottom: var(--spacing-6);
            flex-wrap: wrap;
        }
        
        .empty-state {
            text-align: center;
            padding: var(--spacing-12);
            color: var(--text-secondary);
        }
        
        .empty-state i {
            font-size: 4rem;
            margin-bottom: var(--spacing-4);
            opacity: 0.5;
        }
        
        .empty-state h3 {
            font-size: var(--font-size-xl);
            font-weight: 600;
            margin-bottom: var(--spacing-2);
            color: var(--text-primary);
        }
        
        .empty-state p {
            font-size: var(--font-size-base);
            line-height: 1.6;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .controls {
                flex-direction: column;
            }
            
            .data-table th,
            .data-table td {
                padding: var(--spacing-2) var(--spacing-3);
                font-size: var(--font-size-xs);
            }
        }
        
        /* Layout with Sidebar Structure */
        .layout-with-sidebar {
            display: flex;
            min-height: 100vh;
            background: var(--bg-primary);
            position: relative;
        }
        
        /* Sidebar styles */
        .layout-with-sidebar .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            z-index: 1050;
            overflow-y: auto;
            transition: transform var(--transition-slow);
        }
        
        /* Header styles */
        .layout-with-sidebar .header {
            position: fixed;
            top: 0;
            left: 280px;
            right: 0;
            height: 60px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            z-index: 1040;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-5);
            transition: left var(--transition-slow);
        }
        
        /* Main content area */
        .layout-with-sidebar .main {
            margin-left: 280px;
            margin-top: 60px;
            width: calc(100% - 280px);
            min-height: calc(100vh - 60px);
            transition: margin-left var(--transition-slow), width var(--transition-slow);
        }
        
        /* Mobile adjustments */
        @media (max-width: 1024px) {
            body {
                overflow-x: hidden;
            }
            
            .layout-with-sidebar .sidebar {
                transform: translateX(-100%);
            }
            
            .layout-with-sidebar .sidebar.sidebar-open {
                transform: translateX(0);
            }
            
            .layout-with-sidebar .header {
                left: 0;
            }
            
            .layout-with-sidebar .main {
                margin-left: 0 !important;
                margin-top: 60px !important;
                width: 100% !important;
                min-height: calc(100vh - 60px) !important;
                padding-bottom: 80px !important;
            }
            
            /* Ensure content fills the screen */
            #mainContent {
                min-height: calc(100vh - 60px - 80px);
                padding: var(--spacing-4);
            }
            
            #menuToggle {
                display: block !important;
            }
            
            .app-bottom-nav {
                display: flex !important;
            }
        }
    </style>
</head>
<body data-theme="dark">
    <!-- App Container -->
    <div class="layout-with-sidebar">
        <!-- Sidebar -->
        <!-- Sidebar (renderizada automaticamente pelo NavigationComponent) -->
        <div class="sidebar" id="sidebar"></div>
        
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <h1 class="header-title">üèÜ Classifica√ß√µes em Tempo Real</h1>
            </div>
            <div class="header-right">
                <button class="btn btn-sm btn-primary" id="refreshData">
                    <i>üîÑ</i> Atualizar
                </button>
                <button class="btn btn-sm btn-secondary" id="exportData">
                    <i>üìä</i> Exportar
                </button>
            </div>
        </header>
        
        <!-- Main Content -->
        <main class="main">
            <div style="flex: 1; overflow-y: auto; padding: var(--spacing-5);" id="mainContent">
                
                <!-- Event Selector -->
                <div class="classifications-grid event-selector-container">
                    <div class="event-selector-card">
                        <h3 style="margin: 0 0 var(--spacing-4) 0; font-size: var(--font-size-lg); font-weight: 600; color: var(--text-primary);">
                            üìã Selecionar Evento
                        </h3>
                        <div class="form-group">
                            <select id="eventSelector" class="form-select">
                                <option value="">-- Selecionar Evento --</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Event Info -->
                <div class="event-info-card event-info-container" id="eventInfoCard" style="display: none;">
                    <h3 style="margin: 0 0 var(--spacing-4) 0; font-size: var(--font-size-lg); font-weight: 600; color: var(--text-primary);">
                        ‚ÑπÔ∏è Informa√ß√µes do Evento
                    </h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value" id="eventName">--</div>
                            <div class="stat-label">Evento</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="eventStatus">--</div>
                            <div class="stat-label">Status</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="eventStartTime">--:--</div>
                            <div class="stat-label">In√≠cio</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="eventDuration">00:00:00</div>
                            <div class="stat-label">Dura√ß√£o</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalAthletes">0</div>
                            <div class="stat-label">Atletas</div>
                        </div>
                    </div>
                </div>
                
                <!-- Controls -->
                <div class="controls">
                    <button class="btn btn-primary" id="startEvent">
                        <i>‚ñ∂Ô∏è</i> Iniciar Evento
                    </button>
                    <button class="btn btn-secondary" id="pauseEvent" style="display: none;">
                        <i>‚è∏Ô∏è</i> Pausar Evento
                    </button>
                    <button class="btn btn-danger" id="stopEvent" style="display: none;">
                        <i>‚èπÔ∏è</i> Finalizar Evento
                    </button>
                    <button class="btn btn-secondary" id="resetEvent">
                        <i>üîÑ</i> Resetar
                    </button>
                </div>
                
                <!-- Classifications Table -->
                <div class="classifications-table" id="classificationsTable" style="display: none;">
                    <div class="table-header">
                        <h3 class="table-title">üèÜ Ranking Geral</h3>
                    </div>
                    <div class="table-container">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Pos</th>
                                    <th>Dorsal</th>
                                    <th>Nome</th>
                                    <th>Tempo</th>
                                    <th>Diferen√ßa</th>
                                    <th>Velocidade</th>
                                    <th id="lapColumnsHeader" style="display: none;">
                                        <span id="lapColumnsText">Voltas</span>
                                    </th>
                                    <th id="activityColumnsHeader" style="display: none;">
                                        <span id="activityColumnsText">Atividades</span>
                                    </th>
                                    <th>Status</th>
                                    <th>Imagem</th>
                                </tr>
                            </thead>
                            <tbody id="classificationsBody">
                                <!-- Ser√° preenchido dinamicamente -->
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Empty State -->
                <div class="empty-state" id="emptyState">
                    <div>üèÜ</div>
                    <h3>Nenhum Evento Selecionado</h3>
                    <p>Selecione um evento para visualizar as classifica√ß√µes em tempo real.</p>
                </div>
                
            </div>
        </main>
        
        <!-- Bottom Navigation (Mobile) -->
        <nav class="app-bottom-nav">
            <button class="nav-btn" onclick="window.location.href='/'">
                <i>üè†</i>
                <span>Home</span>
            </button>
            <button class="nav-btn" onclick="window.location.href='/events'">
                <i>üèÉ</i>
                <span>Eventos</span>
            </button>
            <button class="nav-btn" onclick="window.location.href='/detection'">
                <i>üì±</i>
                <span>Detec√ß√£o</span>
            </button>
            <button class="nav-btn active">
                <i>üèÜ</i>
                <span>Rankings</span>
            </button>
        </nav>
    </div>
    
    <!-- Scripts -->
    <!-- Scripts de Autentica√ß√£o -->
    <script src="https://unpkg.com/@supabase/supabase-js@2" defer></script>
    <script src="/supabase.js?v=2025102605" defer></script>
    <script src="/auth-client.js?v=2025102616" defer></script>
    <script src="/auth-helper.js?v=2025102620" defer></script>
    
    <!-- Sistema de Navega√ß√£o Unificado -->
    <script src="/navigation-config.js?v=2025102601" defer></script>
    <script src="/navigation-service.js?v=2025102601" defer></script>
    <!-- Logo Loader (carregar ANTES da navega√ß√£o, SEM defer para garantir ordem) -->
    <script src="/logo-loader.js?v=2025012702"></script>
    <script src="/navigation-component.js?v=2025102601" defer></script>
    <script src="/navigation-init.js?v=2025102601" defer></script>
    
    <!-- Prote√ß√£o de Rotas -->
    <script src="/universal-route-protection.js?v=2025102618" defer></script>
    
    <!-- Classifications Logic -->
    <script>
        // Fun√ß√£o para aguardar AuthSystem
        async function waitForAuthSystem() {
            const maxWaitTime = 10000;
            const startTime = Date.now();
            
            return new Promise((resolve, reject) => {
                const checkInterval = setInterval(() => {
                    const elapsedTime = Date.now() - startTime;
                    
                    // Verificar se authSystem existe (n√£o precisa verificar supabase especificamente)
                    if (window.authSystem && window.authSystem.currentUser !== undefined) {
                        clearInterval(checkInterval);
                        console.log(`‚úÖ AuthSystem pronto ap√≥s ${elapsedTime}ms`);
                        resolve();
                        return;
                    }
                    
                    if (elapsedTime > maxWaitTime) {
                        clearInterval(checkInterval);
                        console.error('‚ùå Timeout ao aguardar AuthSystem');
                        reject(new Error('Timeout ao aguardar AuthSystem'));
                    }
                }, 100);
            });
        }
        
        // Global variables
        let currentEvent = null;
        
        // Aguardar navega√ß√£o estar pronta
        async function waitForNavigation() {
            return new Promise((resolve) => {
                if (window.NavigationUtils) {
                    resolve();
                } else {
                    window.addEventListener('navigationReady', resolve);
                }
            });
        }
        let classifications = [];
        let eventStatus = 'stopped'; // stopped, running, paused, finished
        
        // Initialize page
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üîê Verificando autentica√ß√£o...');
            
            try {
                await waitForAuthSystem();
                
                // Verificar se √© admin, moderator, event_manager, participant ou user
                const userProfile = window.authSystem.userProfile;
                const role = userProfile?.role || userProfile?.profile_type;
                const allowedRoles = ['admin', 'moderator', 'event_manager', 'participant', 'user'];
                
                if (!role || !allowedRoles.includes(role)) {
                    console.warn('‚ö†Ô∏è Sem permiss√£o - redirecionando para login');
                    window.location.href = './login.html';
                    return;
                }
                
                console.log('‚úÖ Autentica√ß√£o validada');
                
            } catch (error) {
                console.error('‚ùå Erro na autentica√ß√£o:', error);
                window.location.href = './login.html';
                return;
            }
            
            // Aguardar navega√ß√£o estar pronta
            await waitForNavigation();
            console.log('‚úÖ Navega√ß√£o pronta');
            
            // Get event from URL
            const urlParams = new URLSearchParams(window.location.search);
            const eventId = urlParams.get('event');
            const eventName = urlParams.get('eventName');
            
            // Atualizar contexto de evento
            if (eventId && window.navigationService) {
                window.navigationService.setEventContext(eventId, eventName);
            }
            
            // Aguardar Supabase estar pronto
            if (window.supabaseClient) {
                console.log('‚è≥ Aguardando Supabase inicializar...');
                await window.supabaseClient.init();
                await window.supabaseClient.ready();
                console.log('‚úÖ Supabase pronto');
            }
            
            if (eventId) {
                console.log('üìã Evento na URL:', eventId);
                // Se temos evento na URL, carregar automaticamente
                try {
                    await loadEventInfo(eventId);
                } catch (error) {
                    console.error('‚ùå Erro ao carregar evento:', error);
                }
                
                // Esconder dropdown de sele√ß√£o de evento
                const eventSelectorContainer = document.querySelector('.event-selector-container');
                if (eventSelectorContainer) {
                    eventSelectorContainer.style.display = 'none';
                }
                
                // Mostrar info do evento selecionado
                const eventInfoContainer = document.querySelector('.event-info-container');
                if (eventInfoContainer) {
                    eventInfoContainer.style.display = 'block';
                }
            } else {
                console.log('‚ö†Ô∏è Nenhum evento especificado na URL');
            }
            
            // Setup event listeners
            setupEventListeners();
            
            // Load events
            await loadEvents();
            
            console.log('‚úÖ P√°gina inicializada completamente');
        });
        
        function setupEventListeners() {
            // Event selector
            document.getElementById('eventSelector').addEventListener('change', (e) => {
                if (e.target.value) {
                    loadEventInfo(e.target.value);
                } else {
                    hideEventInfo();
                }
            });
            
            // Event controls
            document.getElementById('startEvent').addEventListener('click', startEvent);
            document.getElementById('pauseEvent').addEventListener('click', pauseEvent);
            document.getElementById('stopEvent').addEventListener('click', stopEvent);
            document.getElementById('resetEvent').addEventListener('click', resetEvent);
            
            // Header actions
            document.getElementById('refreshData').addEventListener('click', refreshData);
            document.getElementById('exportData').addEventListener('click', exportData);
            
            // Menu toggle mobile
            const menuToggle = document.getElementById('menuToggle');
            const sidebar = document.getElementById('sidebar');
            
            if (menuToggle && sidebar) {
                menuToggle.addEventListener('click', () => {
                    sidebar.classList.toggle('active');
                });
            }
        }
        
        async function loadEvents() {
            try {
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    console.error('Supabase n√£o dispon√≠vel');
                    showError('Supabase n√£o dispon√≠vel');
                    return;
                }
                
                const { data: events, error } = await window.supabaseClient.supabase
                    .from('events')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) {
                    console.error('‚ùå Erro ao carregar eventos:', error);
                    showError('Erro ao carregar eventos');
                    return;
                }
                
                const selector = document.getElementById('eventSelector');
                selector.innerHTML = '<option value="">-- Selecionar Evento --</option>';
                
                events.forEach(event => {
                    const option = document.createElement('option');
                    option.value = event.id;
                    option.textContent = `${event.name} (${event.is_active ? 'Ativo' : 'Inativo'})`;
                    selector.appendChild(option);
                });
                
            } catch (error) {
                console.error('‚ùå Erro ao carregar eventos:', error);
                showError('Erro ao carregar eventos');
            }
        }
        
        async function loadEventInfo(eventId) {
            try {
                console.log('üîç loadEventInfo chamado com eventId:', eventId);
                console.log('üîç window.supabaseClient:', !!window.supabaseClient);
                console.log('üîç window.supabaseClient?.supabase:', !!window.supabaseClient?.supabase);
                
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    console.error('‚ùå Supabase n√£o dispon√≠vel');
                    console.error('   - window.supabaseClient:', window.supabaseClient);
                    console.error('   - window.supabaseClient?.supabase:', window.supabaseClient?.supabase);
                    return;
                }
                
                console.log('‚úÖ Supabase dispon√≠vel, fazendo query...');
                
                // Usar API REST em vez de query direta (para evitar problemas de RLS)
                console.log('üåê Tentando carregar evento via API REST...');
                const apiRes = await fetch(`/api/events/list`, {
                    credentials: 'include'
                });
                
                if (apiRes.ok) {
                    const apiData = await apiRes.json();
                    console.log('üìä API resposta:', apiData);
                    
                    if (apiData.success && apiData.events) {
                        // Procurar o evento espec√≠fico na lista
                        const event = apiData.events.find(e => e.id === eventId);
                        if (event) {
                            console.log('‚úÖ Evento encontrado via API:', event.name);
                            
                            // Usar esse evento e pular para o resto do c√≥digo
                            // (n√£o precisa da query Supabase agora)
                            console.log('‚úÖ Evento carregado via API:', event.name);
                            
                            // Atualizar UI com o evento
                            currentEvent = event;
                            eventStatus = event.is_active ? 'running' : 'stopped';
                            
                            // Update UI with null checks
                            const eventNameEl = document.getElementById('eventName');
                            if (eventNameEl) eventNameEl.textContent = event.name;
                            
                            const eventStatusEl = document.getElementById('eventStatus');
                            if (eventStatusEl) eventStatusEl.textContent = event.is_active ? 'Ativo' : 'Inativo';
                            
                            // Mostrar data/hora de in√≠cio
                            const eventStartTimeEl = document.getElementById('eventStartTime');
                            if (eventStartTimeEl) {
                                const startTime = event.event_started_at || event.event_date;
                                if (startTime) {
                                    const startDate = new Date(startTime);
                                    eventStartTimeEl.textContent = startDate.toLocaleString('pt-PT', { 
                                        day: '2-digit',
                                        month: '2-digit',
                                        hour: '2-digit', 
                                        minute: '2-digit'
                                    });
                                } else {
                                    eventStartTimeEl.textContent = 'N√£o iniciado';
                                }
                            }
                            
                            // Iniciar contador de dura√ß√£o em tempo real
                            startDurationCounter();
                            
                            // Show event info
                            const eventInfoCard = document.getElementById('eventInfoCard');
                            if (eventInfoCard) eventInfoCard.style.display = 'block';
                            
                            const classificationsTable = document.getElementById('classificationsTable');
                            if (classificationsTable) classificationsTable.style.display = 'block';
                            
                            const emptyState = document.getElementById('emptyState');
                            if (emptyState) emptyState.style.display = 'none';
                            
                            // Update sidebar
                            const eventInfoPanel = document.getElementById('eventInfoPanel');
                            if (eventInfoPanel) eventInfoPanel.style.display = 'block';
                            
                            const currentEventInfo = document.getElementById('currentEventInfo');
                            if (currentEventInfo) {
                                currentEventInfo.innerHTML = `
                                    <strong>${event.name}</strong><br>
                                    Status: ${event.is_active ? 'Ativo' : 'Inativo'}
                                `;
                            }
                            
                            // Update controls based on status
                            updateControls();
                            
                            // Load classifications
                            loadClassifications();
                            return;
                        }
                    }
                }
                
                // Se a API n√£o funcionou, tentar query direta do Supabase como fallback
                console.log('‚ö†Ô∏è API n√£o retornou evento, tentando query direta...');
                const { data: event, error: eventError } = await window.supabaseClient.supabase
                    .from('events')
                    .select('*')
                    .eq('id', eventId)
                    .single();
                
                console.log('üìä Query resultado:', { error: eventError, data: event ? 'event loaded' : 'no data' });
                
                if (eventError) {
                    console.error('‚ùå Erro ao carregar evento:', eventError);
                    
                    if (eventError.code === 'PGRST116') {
                        // Evento n√£o encontrado
                        console.error('‚ùå Evento n√£o existe na base de dados');
                        alert('‚ùå Evento n√£o encontrado!\n\nO evento com o ID fornecido n√£o existe na base de dados. Redirecionando para eventos...');
                        
                        setTimeout(() => {
                            window.location.href = '/events-kromi.html';
                        }, 2000);
                    } else {
                        showError('Erro ao carregar evento: ' + eventError.message);
                    }
                    return;
                }
                
                if (!event) {
                    console.error('‚ùå Evento n√£o retornado da query');
                    alert('‚ùå Evento n√£o encontrado!\n\nRedirecionando para eventos...');
                    setTimeout(() => {
                        window.location.href = '/events-kromi.html';
                    }, 2000);
                    return;
                }
                
                console.log('‚úÖ Evento carregado:', event.name);
                
                // Carregar estat√≠sticas do evento via API REST
                const statsRes = await fetch(`/api/events/${eventId}/stats`, {
                    credentials: 'include'
                });
                
                let totalAthletes = 0;
                let totalDetections = 0;
                
                if (statsRes.ok) {
                    const { success, stats } = await statsRes.json();
                    if (success && stats) {
                        totalAthletes = stats.totalParticipants || stats.total_participants || 0;
                        totalDetections = stats.totalDetections || stats.total_detections || 0;
                    }
                } else {
                    console.warn('‚ö†Ô∏è Erro ao carregar stats, usando valores padr√£o');
                }
                
                currentEvent = event;
                eventStatus = event.is_active ? 'running' : 'stopped';
                
                // Update UI with null checks
                const eventNameEl = document.getElementById('eventName');
                if (eventNameEl) eventNameEl.textContent = event.name;
                
                const eventStatusEl = document.getElementById('eventStatus');
                if (eventStatusEl) eventStatusEl.textContent = event.is_active ? 'Ativo' : 'Inativo';
                
                // Mostrar data/hora de in√≠cio
                const eventStartTimeEl = document.getElementById('eventStartTime');
                if (eventStartTimeEl) {
                    const startTime = event.event_started_at || event.event_date;
                    if (startTime) {
                        const startDate = new Date(startTime);
                        eventStartTimeEl.textContent = startDate.toLocaleString('pt-PT', { 
                            day: '2-digit',
                            month: '2-digit',
                            hour: '2-digit', 
                            minute: '2-digit'
                        });
                    } else {
                        eventStartTimeEl.textContent = 'N√£o iniciado';
                    }
                }
                
                const totalAthletesEl = document.getElementById('totalAthletes');
                if (totalAthletesEl) {
                    // Fallback: se stats n√£o retornou, usar contagem de participantes carregados
                    if (totalAthletes === 0 && window.participants && window.participants.length > 0) {
                        totalAthletes = window.participants.length;
                    }
                    totalAthletesEl.textContent = totalAthletes;
                }
                
                // Iniciar contador de dura√ß√£o em tempo real
                startDurationCounter();
                
                // Show event info
                const eventInfoCard = document.getElementById('eventInfoCard');
                if (eventInfoCard) eventInfoCard.style.display = 'block';
                
                const classificationsTable = document.getElementById('classificationsTable');
                if (classificationsTable) classificationsTable.style.display = 'block';
                
                const emptyState = document.getElementById('emptyState');
                if (emptyState) emptyState.style.display = 'none';
                
                // Update sidebar
                const eventInfoPanel = document.getElementById('eventInfoPanel');
                if (eventInfoPanel) eventInfoPanel.style.display = 'block';
                
                const currentEventInfo = document.getElementById('currentEventInfo');
                if (currentEventInfo) {
                    currentEventInfo.innerHTML = `
                        <strong>${event.name}</strong><br>
                        Status: ${event.is_active ? 'Ativo' : 'Inativo'}<br>
                        Atletas: ${totalAthletes}
                    `;
                }
                
                // Update controls based on status
                updateControls();
                
                // Load classifications
                loadClassifications();
                
            } catch (error) {
                console.error('‚ùå Erro ao carregar evento:', error);
                showError('Erro ao carregar evento');
            }
        }
        
        function hideEventInfo() {
            currentEvent = null;
            
            // Hide event info with null checks
            const eventInfoCard = document.getElementById('eventInfoCard');
            if (eventInfoCard) eventInfoCard.style.display = 'none';
            
            const classificationsTable = document.getElementById('classificationsTable');
            if (classificationsTable) classificationsTable.style.display = 'none';
            
            const emptyState = document.getElementById('emptyState');
            if (emptyState) emptyState.style.display = 'block';
            
            // Hide sidebar info
            const eventInfoPanel = document.getElementById('eventInfoPanel');
            if (eventInfoPanel) eventInfoPanel.style.display = 'none';
        }
        
        function updateControls() {
            const startBtn = document.getElementById('startEvent');
            const pauseBtn = document.getElementById('pauseEvent');
            const stopBtn = document.getElementById('stopEvent');
            
            // Reset all buttons
            startBtn.style.display = 'none';
            pauseBtn.style.display = 'none';
            stopBtn.style.display = 'none';
            
            // Show appropriate buttons based on status
            switch (eventStatus) {
                case 'stopped':
                    startBtn.style.display = 'inline-flex';
                    break;
                case 'running':
                    pauseBtn.style.display = 'inline-flex';
                    stopBtn.style.display = 'inline-flex';
                    break;
                case 'paused':
                    startBtn.style.display = 'inline-flex';
                    stopBtn.style.display = 'inline-flex';
                    break;
                case 'finished':
                    // No active controls for finished events
                    break;
            }
        }
        
        async function loadClassifications() {
            try {
                if (!currentEvent || !window.supabaseClient || !window.supabaseClient.supabase) {
                    console.log('Sem evento selecionado ou Supabase n√£o dispon√≠vel');
                    return;
                }
                
                console.log('üìä Carregando classifica√ß√µes...');
                
                // Carregar participantes para ter os nomes
                const { data: participants, error: partError } = await window.supabaseClient.supabase
                    .from('participants')
                    .select('dorsal_number, full_name')
                    .eq('event_id', currentEvent.id);
                
                console.log('üë• Participantes:', participants);
                
                // Guardar para uso global (contagem de atletas)
                window.participants = participants || [];
                
                // Atualizar contador de atletas
                const totalAthletesEl = document.getElementById('totalAthletes');
                if (totalAthletesEl && window.participants.length > 0) {
                    totalAthletesEl.textContent = window.participants.length;
                }
                
                const participantMap = {};
                (participants || []).forEach(p => {
                    participantMap[p.dorsal_number] = p.full_name;
                });
                
                console.log('üìã Mapa de participantes:', participantMap);
                
                // Carregar detections para ter as proof_images
                const { data: detections, error: detError } = await window.supabaseClient.supabase
                    .from('detections')
                    .select('*')
                    .eq('event_id', currentEvent.id);
                
                console.log('üì∏ Detections:', detections);
                console.log('üì∏ Error:', detError);
                
                const imageMap = {};
                (detections || []).forEach((d, i) => {
                    console.log(`Detection ${i}:`, {
                        number: d.number,
                        has_proof_image: !!d.proof_image,
                        proof_image_length: d.proof_image?.length || 0
                    });
                    
                    const dorsal = d.number; // Campo correto √© 'number' n√£o 'dorsal_number'
                    const image = d.proof_image;
                    
                    if (dorsal && image && !imageMap[dorsal]) {
                        imageMap[dorsal] = image;
                        console.log(`  ‚úÖ Imagem para dorsal ${dorsal}:`, image.substring(0, 50) + '...');
                    } else if (dorsal) {
                        console.log(`  ‚ùå Dorsal ${dorsal} sem proof_image`);
                    }
                });
                
                console.log('üì∏ Mapa de imagens:', imageMap);
                console.log('üì∏ Total imagens mapeadas:', Object.keys(imageMap).length);
                
                // Carregar classifica√ß√µes via API REST (contornar RLS)
                console.log('üåê Carregando classifica√ß√µes via API REST...');
                const apiRes = await fetch(`/api/classifications/list?event=${currentEvent.id}`, {
                    credentials: 'include'
                });
                
                let classData = null;
                let classError = null;
                
                if (apiRes.ok) {
                    const apiData = await apiRes.json();
                    console.log('üìä API resposta:', apiData);
                    
                    if (apiData.success) {
                        classData = apiData.classifications;
                    } else {
                        classError = { message: apiData.error };
                    }
                } else {
                    classError = { message: `API error: ${apiRes.status}` };
                }
                
                console.log('üìä Classifications:', classData);
                console.log('üìä Error:', classError);

                if (classError) {
                    console.error('‚ùå Erro ao carregar classifications:', classError);
                    showError('Erro ao carregar dados');
                    return;
                }
                
                if (classData && classData.length > 0) {
                    // Usar dados das classifications
                    console.log(`‚úÖ ${classData.length} classifica√ß√µes carregadas`);
                    
            classifications = classData.map((c, index) => {
                const name = participantMap[c.dorsal_number] || `Dorsal ${c.dorsal_number}`;
                const proofImage = imageMap[c.dorsal_number]; // imageMap usa 'number' da tabela detections
                
                console.log(`Classification ${index}: Dorsal ${c.dorsal_number}, Nome: ${name}, Imagem: ${proofImage ? 'SIM (' + proofImage.length + ' chars)' : 'N√ÉO'}`);
                
                return {
                    position: c.position || index + 1,
                    dorsal: c.dorsal_number,
                    name: name,
                    time: c.total_time_formatted || formatInterval(c.total_time),
                    difference: index === 0 ? '--' : (c.gap_to_leader_formatted ? '+' + c.gap_to_leader_formatted : '+' + formatInterval(c.gap_to_leader || c.total_time)),
                    speed: c.avg_speed_kmh ? (typeof c.avg_speed_kmh === 'string' ? `${c.avg_speed_kmh} km/h` : `${parseFloat(c.avg_speed_kmh).toFixed(1)} km/h`) : '--',
                    status: c.is_penalty ? 'PENALTY' : 'FINISHED',
                    proof_image: proofImage,
                    // Dados de voltas
                    has_lap_counter: c.has_lap_counter,
                    total_laps: c.total_laps,
                    fastest_lap: c.fastest_lap,
                    slowest_lap: c.slowest_lap,
                    avg_lap_time: c.avg_lap_time,
                    avg_lap_speed: c.avg_lap_speed,
                    fastest_lap_speed: c.fastest_lap_speed,
                    total_lap_time: c.total_lap_time,
                    // Dados de atividades espec√≠ficas
                    swimming_time: c.swimming_time,
                    cycling_time: c.cycling_time,
                    running_time: c.running_time,
                    final_time: c.final_time
                };
            });
                    
                    renderClassifications();
                    return;
                }
                
                // Se n√£o h√° classifica√ß√µes, mostrar vazio
                console.log('‚ö†Ô∏è Nenhuma classifica√ß√£o encontrada');
                classifications = [];
                renderClassifications();
                
            } catch (error) {
                console.error('‚ùå Erro ao carregar classifica√ß√µes:', error);
                showError('Erro ao carregar classifica√ß√µes');
            }
        }
        
        function formatInterval(interval) {
            if (!interval) return '--:--:--';
            
            // PostgreSQL interval: "HH:MM:SS" ou "HH:MM:SS.microseconds"
            const str = interval.toString();
            
            // Extrair HH:MM:SS
            const match = str.match(/(\d+):(\d+):(\d+(?:\.\d+)?)/);
            if (match) {
                const [_, hours, minutes, seconds] = match;
                const sec = Math.floor(parseFloat(seconds));
                return `${hours.padStart(2, '0')}:${minutes.padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
            }
            
            return str;
        }
        
        function renderClassifications() {
            const tbody = document.getElementById('classificationsBody');
            tbody.innerHTML = '';
            
            if (classifications.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; padding: var(--spacing-8); color: var(--text-secondary);">Nenhuma classifica√ß√£o dispon√≠vel</td></tr>';
                return;
            }
            
            // Verificar se o evento tem contador de voltas
            const hasLapCounter = classifications.length > 0 && classifications[0].has_lap_counter;
            const lapColumnsHeader = document.getElementById('lapColumnsHeader');
            const lapColumnsText = document.getElementById('lapColumnsText');
            
            // Verificar se o evento tem atividades multi-disciplinares
            const hasActivities = classifications.length > 0 && (
                classifications[0].swimming_time !== undefined || 
                classifications[0].cycling_time !== undefined || 
                classifications[0].running_time !== undefined
            );
            const activityColumnsHeader = document.getElementById('activityColumnsHeader');
            const activityColumnsText = document.getElementById('activityColumnsText');
            
            if (hasLapCounter) {
                if (lapColumnsHeader) lapColumnsHeader.style.display = 'table-cell';
                if (lapColumnsText) lapColumnsText.textContent = 'Voltas';
            } else {
                if (lapColumnsHeader) lapColumnsHeader.style.display = 'none';
            }
            
            if (hasActivities) {
                if (activityColumnsHeader) activityColumnsHeader.style.display = 'table-cell';
                if (activityColumnsText) activityColumnsText.textContent = 'Atividades';
            } else {
                if (activityColumnsHeader) activityColumnsHeader.style.display = 'none';
            }
            
            classifications.forEach(athlete => {
                const row = document.createElement('tr');
                
                // Position badge
                const positionClass = athlete.position <= 3 ? `rank-${athlete.position}` : 'rank-other';
                
                // Dados de voltas (se dispon√≠veis)
                let lapData = '';
                if (hasLapCounter && athlete.total_laps !== undefined) {
                    const fastestLap = athlete.fastest_lap ? formatInterval(athlete.fastest_lap) : '--';
                    const avgLapSpeed = athlete.avg_lap_speed ? (typeof athlete.avg_lap_speed === 'string' ? `${athlete.avg_lap_speed} km/h` : `${parseFloat(athlete.avg_lap_speed).toFixed(1)} km/h`) : '--';
                    
                    lapData = `
                        <td>
                            <div style="display: flex; flex-direction: column; gap: var(--spacing-1);">
                                <span style="font-weight: 600; color: var(--primary);">${athlete.total_laps || 0}</span>
                                <span style="font-size: var(--font-size-xs); color: var(--text-secondary);">
                                    Melhor: ${fastestLap}
                                </span>
                                <span style="font-size: var(--font-size-xs); color: var(--text-secondary);">
                                    Vel: ${avgLapSpeed}
                                </span>
                            </div>
                        </td>
                    `;
                } else {
                    lapData = '<td style="display: none;"></td>';
                }
                
                // Dados de atividades (se dispon√≠veis)
                let activityData = '';
                if (hasActivities) {
                    const swimmingTime = athlete.swimming_time ? formatInterval(athlete.swimming_time) : '--';
                    const cyclingTime = athlete.cycling_time ? formatInterval(athlete.cycling_time) : '--';
                    const runningTime = athlete.running_time ? formatInterval(athlete.running_time) : '--';
                    
                    activityData = `
                        <td>
                            <div style="display: flex; flex-direction: column; gap: var(--spacing-1);">
                                ${athlete.swimming_time ? `<span style="font-size: var(--font-size-xs); color: #06b6d4;">üèä ${swimmingTime}</span>` : ''}
                                ${athlete.cycling_time ? `<span style="font-size: var(--font-size-xs); color: #3b82f6;">üö¥ ${cyclingTime}</span>` : ''}
                                ${athlete.running_time ? `<span style="font-size: var(--font-size-xs); color: #10b981;">üèÉ ${runningTime}</span>` : ''}
                            </div>
                        </td>
                    `;
                } else {
                    activityData = '<td style="display: none;"></td>';
                }
                
                row.innerHTML = `
                    <td><span class="rank-badge ${positionClass}">${athlete.position}</span></td>
                    <td><strong>${athlete.dorsal}</strong></td>
                    <td>${athlete.name}</td>
                    <td><span class="time-display">${athlete.time}</span></td>
                    <td>${athlete.difference}</td>
                    <td>${athlete.speed}</td>
                    ${lapData}
                    ${activityData}
                    <td><span class="badge ${athlete.status === 'FINISHED' || athlete.status === 'finished' ? 'badge-success' : athlete.status === 'PENALTY' ? 'badge-danger' : 'badge-warning'}">${athlete.status}</span></td>
                    <td>
                        ${athlete.proof_image ? `<a href="#" onclick="viewImage('${athlete.proof_image}'); return false;" title="Ver imagem de prova" style="font-size: 20px; text-decoration: none;">üì∏</a>` : '<span style="color: var(--text-secondary);">--</span>'}
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            console.log(`‚úÖ ${classifications.length} classifica√ß√µes renderizadas${hasLapCounter ? ' (com dados de voltas)' : ''}${hasActivities ? ' (com dados de atividades)' : ''}`);
        }
        
        let durationInterval = null;
        
        function startDurationCounter() {
            // Limpar intervalo anterior se existir
            if (durationInterval) {
                clearInterval(durationInterval);
            }
            
            // Atualizar dura√ß√£o a cada segundo
            durationInterval = setInterval(() => {
                updateDuration();
            }, 1000);
            
            // Atualizar imediatamente
            updateDuration();
        }
        
        function updateDuration() {
            const durationElement = document.getElementById('eventDuration');
            if (!durationElement) return;
            
            if (!currentEvent || !currentEvent.event_started_at) {
                durationElement.textContent = '00:00:00';
                return;
            }
            
            const startTime = new Date(currentEvent.event_started_at);
            const endTime = currentEvent.event_ended_at ? new Date(currentEvent.event_ended_at) : new Date();
            
            const diff = endTime - startTime;
            
            if (diff < 0) {
                durationElement.textContent = '00:00:00';
                return;
            }
            
            // Calcular dias, horas, minutos, segundos
            const totalSeconds = Math.floor(diff / 1000);
            const days = Math.floor(totalSeconds / 86400);
            const hours = Math.floor((totalSeconds % 86400) / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            // Formato: "X days HH:MM:SS" ou "HH:MM:SS"
            if (days > 0) {
                durationElement.textContent = `${days} days ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                durationElement.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
        function startEvent() {
            eventStatus = 'running';
            
            // Atualizar evento com hora de in√≠cio
            if (currentEvent && window.supabaseClient) {
                const now = new Date().toISOString();
                
                window.supabaseClient.supabase
                    .from('events')
                    .update({ 
                        event_started_at: now,
                        is_active: true,
                        status: 'running'
                    })
                    .eq('id', currentEvent.id)
                    .then(() => {
                        currentEvent.event_started_at = now;
                        updateControls();
                        showSuccess('Evento iniciado!');
                        startDurationCounter();
                        startRealTimeUpdates();
                    });
            } else {
                updateControls();
                showSuccess('Evento iniciado');
                startRealTimeUpdates();
            }
        }
        
        function pauseEvent() {
            eventStatus = 'paused';
            updateControls();
            showSuccess('Evento pausado');
        }
        
        function stopEvent() {
            eventStatus = 'finished';
            
            // Atualizar evento com hora de fim
            if (currentEvent && window.supabaseClient) {
                const now = new Date().toISOString();
                
                window.supabaseClient.supabase
                    .from('events')
                    .update({ 
                        event_ended_at: now,
                        is_active: false,
                        status: 'finished'
                    })
                    .eq('id', currentEvent.id)
                    .then(() => {
                        currentEvent.event_ended_at = now;
                        updateControls();
                        showSuccess('Evento finalizado!');
                        
                        // Parar contador (usa event_ended_at)
                        if (durationInterval) {
                            clearInterval(durationInterval);
                            updateDuration(); // Atualizar uma √∫ltima vez
                        }
                    });
            } else {
                updateControls();
                showSuccess('Evento finalizado');
            }
        }
        
        async function resetEvent() {
            if (!currentEvent) {
                showError('Nenhum evento selecionado');
                return;
            }
            
            const confirmMessage = `‚ö†Ô∏è ATEN√á√ÉO! Esta a√ß√£o ir√° APAGAR PERMANENTEMENTE:

‚Ä¢ Todas as detec√ß√µes deste evento
‚Ä¢ Todas as classifica√ß√µes
‚Ä¢ Todas as imagens do buffer
‚Ä¢ Todo o hist√≥rico de dados

Esta a√ß√£o N√ÉO PODE SER DESFEITA!

Tem certeza que deseja resetar o evento "${currentEvent.name}"?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Confirma√ß√£o dupla
            const finalConfirm = prompt('Digite "RESETAR" (em mai√∫sculas) para confirmar:');
            if (finalConfirm !== 'RESETAR') {
                showError('Reset cancelado');
                return;
            }
            
            try {
                if (!window.supabaseClient || !window.supabaseClient.supabase) {
                    showError('Supabase n√£o conectado');
                    return;
                }
                
                showSuccess('Iniciando reset do evento...');
                
                // 1. Apagar classifica√ß√µes
                console.log('üóëÔ∏è Apagando classifica√ß√µes...');
                const { data: deletedClass, error: classError, count: classCount } = await window.supabaseClient.supabase
                    .from('classifications')
                    .delete({ count: 'exact' })
                    .eq('event_id', currentEvent.id);
                
                if (classError) {
                    console.error('‚ùå Erro ao apagar classifica√ß√µes:', classError);
                    throw new Error('Erro ao apagar classifica√ß√µes');
                }
                
                console.log(`‚úÖ ${classCount || 0} classifica√ß√µes apagadas`);
                
                // 2. Apagar detec√ß√µes
                console.log('üóëÔ∏è Apagando detec√ß√µes...');
                const { data: deletedDet, error: detError, count: detCount } = await window.supabaseClient.supabase
                    .from('detections')
                    .delete({ count: 'exact' })
                    .eq('event_id', currentEvent.id);
                
                if (detError) {
                    console.error('‚ùå Erro ao apagar detec√ß√µes:', detError);
                    throw new Error('Erro ao apagar detec√ß√µes');
                }
                
                console.log(`‚úÖ ${detCount || 0} detec√ß√µes apagadas`);
                
                // 3. N√ÉO APAGAR PARTICIPANTES - S√£o inscri√ß√µes permanentes do evento
                console.log('‚ÑπÔ∏è Participantes mantidos (inscri√ß√µes do evento)');
                
                // 4. Apagar imagens do buffer
                console.log('üóëÔ∏è Apagando buffer de imagens...');
                const { error: bufferError, count: bufferCount } = await window.supabaseClient.supabase
                    .from('image_buffer')
                    .delete({ count: 'exact' })
                    .eq('event_id', currentEvent.id);
                
                if (bufferError) {
                    console.warn('‚ö†Ô∏è Erro ao apagar buffer:', bufferError);
                } else {
                    console.log(`‚úÖ ${bufferCount || 0} imagens do buffer apagadas`);
                }
                
                // 5. Apagar sess√µes de dispositivos
                console.log('üóëÔ∏è Apagando sess√µes de dispositivos...');
                const { error: sessionsError, count: sessionsCount } = await window.supabaseClient.supabase
                    .from('device_sessions')
                    .delete({ count: 'exact' })
                    .eq('event_id', currentEvent.id);
                
                if (sessionsError && sessionsError.code !== '42P01') {
                    console.warn('‚ö†Ô∏è Erro ao apagar sess√µes:', sessionsError);
                } else {
                    console.log(`‚úÖ ${sessionsCount || 0} sess√µes apagadas`);
                }
                
                // 6. Resetar contadores de sess√µes ativas
                console.log('üîÑ Resetando contadores de sess√µes...');
                const { error: resetSessionsError } = await window.supabaseClient.supabase
                    .from('event_devices')
                    .update({ active_sessions: 0 })
                    .eq('event_id', currentEvent.id);
                
                if (resetSessionsError) {
                    console.warn('‚ö†Ô∏è Erro ao resetar contadores:', resetSessionsError);
                } else {
                    console.log('‚úÖ Contadores de sess√µes resetados');
                }
                
                // 4. Resetar status do evento
                const { error: eventError } = await window.supabaseClient.supabase
                    .from('events')
                    .update({ 
                        status: 'active',
                        event_started_at: null,
                        event_ended_at: null,
                        is_active: false
                    })
                    .eq('id', currentEvent.id);
                
                if (eventError) {
                    console.error('Erro ao resetar status:', eventError);
                    // Continuar mesmo com erro
                }
                
                console.log('‚úÖ Status do evento resetado');
                
                // Verificar se realmente apagou via API REST
                const verifyRes = await fetch(`/api/events/${currentEvent.id}/stats`, {
                    credentials: 'include'
                });
                
                let verifyCounts = { classifications: 0, detections: 0, images: 0 };
                
                if (verifyRes.ok) {
                    const { stats } = await verifyRes.json();
                    verifyCounts = {
                        classifications: stats.totalClassifications || 0,
                        detections: stats.totalDetections || 0,
                        images: 0 // API stats n√£o retorna images, assumir 0 ap√≥s reset
                    };
                }
                
                console.log('üîç Verifica√ß√£o p√≥s-reset:');
                console.log('  Classifications:', verifyCounts.classifications);
                console.log('  Detections:', verifyCounts.detections);
                console.log('  Buffer:', verifyCounts.images);
                
                // Limpar UI local
                eventStatus = 'stopped';
                classifications = [];
                updateControls();
                renderClassifications();
                
                // Esconder tabela, mostrar empty state
                const table = document.getElementById('classificationsTable');
                const emptyState = document.getElementById('emptyState');
                if (table) table.style.display = 'none';
                if (emptyState) emptyState.style.display = 'block';
                
                const msg = `‚úÖ Evento Resetado com Sucesso!

üìä Dados Apagados:
‚Ä¢ Classifications: ${classCount || 0} apagadas ‚Üí ${verifyCounts.classifications} restantes
‚Ä¢ Detections: ${detCount || 0} apagadas ‚Üí ${verifyCounts.detections} restantes
‚Ä¢ Buffer Imagens: ${bufferCount || 0} apagadas ‚Üí ${verifyCounts.images} restantes
‚Ä¢ Sess√µes: ${sessionsCount || 0} encerradas
‚Ä¢ Contadores de sess√µes: resetados

‚úÖ Participantes MANTIDOS (inscri√ß√µes permanecem)

‚úÖ O evento est√° pronto para novas detec√ß√µes!
${verifyCounts.classifications > 0 || verifyCounts.detections > 0 ? '\n‚ö†Ô∏è AVISO: Ainda h√° dados! Poss√≠vel problema de RLS.' : ''}

A p√°gina ser√° recarregada em 3 segundos...`;
                
                console.log('üìä Mensagem de sucesso:', msg);
                showSuccess(msg);
                
                // Recarregar dados
                setTimeout(() => {
                    console.log('üîÑ Recarregando p√°gina...');
                    window.location.reload();
                }, 3000);
                
            } catch (error) {
                console.error('‚ùå Erro ao resetar evento:', error);
                showError(`Erro ao resetar evento: ${error.message}`);
            }
        }
        
        function startRealTimeUpdates() {
            // Simulate real-time updates (replace with actual WebSocket/SSE)
            if (eventStatus === 'running') {
                // Simulate new athlete finishing
                if (Math.random() < 0.3) {
                    const newAthlete = {
                        position: classifications.length + 1,
                        dorsal: Math.floor(Math.random() * 999) + 1,
                        name: `Atleta ${classifications.length + 1}`,
                        time: generateRandomTime(),
                        difference: '+00:00',
                        speed: `${(Math.random() * 5 + 15).toFixed(1)} km/h`,
                        status: 'finished'
                    };
                    
                    classifications.push(newAthlete);
                    renderClassifications();
                }
                
                // Continue updates
                setTimeout(startRealTimeUpdates, 2000);
            }
        }
        
        function generateRandomTime() {
            const hours = Math.floor(Math.random() * 3) + 2;
            const minutes = Math.floor(Math.random() * 60);
            const seconds = Math.floor(Math.random() * 60);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function refreshData() {
            if (currentEvent) {
                loadClassifications();
                showSuccess('Dados atualizados');
            }
        }
        
        function exportData() {
            if (currentEvent && classifications.length > 0) {
                // Create CSV data
                const csvData = [
                    ['Posi√ß√£o', 'Dorsal', 'Nome', 'Tempo', 'Diferen√ßa', 'Velocidade', 'Status'],
                    ...classifications.map(athlete => [
                        athlete.position,
                        athlete.dorsal,
                        athlete.name,
                        athlete.time,
                        athlete.difference,
                        athlete.speed,
                        athlete.status
                    ])
                ].map(row => row.join(',')).join('\n');
                
                // Download CSV
                const blob = new Blob([csvData], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `classificacoes_${currentEvent.name.replace(/\s+/g, '_')}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                showSuccess('Dados exportados');
            } else {
                showError('Nenhum dado para exportar');
            }
        }
        
        async function viewImage(imageData) {
            if (!imageData) return;
            
            // Criar modal para mostrar imagem (carregamento inicial)
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            `;
            
            modal.innerHTML = `
                <div style="max-width: 90%; max-height: 90%; position: relative;">
                    <div style="color: white; text-align: center; padding: 20px;">A carregar imagem...</div>
                    <button onclick="event.stopPropagation(); this.parentElement.parentElement.remove();" style="position: absolute; top: 10px; right: 10px; background: var(--danger); color: white; border: none; padding: 10px 20px; border-radius: var(--radius-full); cursor: pointer; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                        ‚úï Fechar
                    </button>
                </div>
            `;
            
            modal.onclick = () => modal.remove();
            document.body.appendChild(modal);
            
            try {
                // Processar imagem com overlay do logo
                const imageWithLogo = await addLogoOverlayToImage(imageData);
                
                // Atualizar modal com imagem processada
                modal.innerHTML = `
                    <div style="max-width: 90%; max-height: 90%; position: relative;">
                        <img src="${imageWithLogo}" style="max-width: 100%; max-height: 90vh; border-radius: var(--radius-lg); box-shadow: 0 8px 32px rgba(0,0,0,0.5);">
                        <button onclick="event.stopPropagation(); this.parentElement.parentElement.remove();" style="position: absolute; top: 10px; right: 10px; background: var(--danger); color: white; border: none; padding: 10px 20px; border-radius: var(--radius-full); cursor: pointer; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                            ‚úï Fechar
                        </button>
                    </div>
                `;
            } catch (error) {
                console.error('Erro ao adicionar logo:', error);
                // Se falhar, mostrar imagem original sem logo
                modal.innerHTML = `
                    <div style="max-width: 90%; max-height: 90%; position: relative;">
                        <img src="${imageData}" style="max-width: 100%; max-height: 90vh; border-radius: var(--radius-lg); box-shadow: 0 8px 32px rgba(0,0,0,0.5);">
                        <button onclick="event.stopPropagation(); this.parentElement.parentElement.remove();" style="position: absolute; top: 10px; right: 10px; background: var(--danger); color: white; border: none; padding: 10px 20px; border-radius: var(--radius-full); cursor: pointer; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                            ‚úï Fechar
                        </button>
                    </div>
                `;
            }
        }
        
        async function addLogoOverlayToImage(imageData) {
            return new Promise(async (resolve, reject) => {
                try {
                    // Normalizar dados da imagem
                    let cleanImageData = imageData;
                    if (!imageData.startsWith('data:image/')) {
                        cleanImageData = `data:image/jpeg;base64,${imageData}`;
                    }
                    
                    // Carregar logo da Kromi (usar logo prim√°rio horizontal)
                    const logoResponse = await fetch('/api/branding/logo/primary/horizontal', {
                        credentials: 'include'
                    });
                    
                    let logoUrl = null;
                    if (logoResponse.ok) {
                        const logoData = await logoResponse.json();
                        if (logoData.success && logoData.data && logoData.data.url) {
                            logoUrl = logoData.data.url;
                        }
                    }
                    
                    // Se n√£o conseguir logo, retornar imagem original
                    if (!logoUrl) {
                        console.warn('Logo n√£o encontrado, mostrando imagem sem overlay');
                        resolve(cleanImageData);
                        return;
                    }
                    
                    // Criar canvas para processar imagem
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Carregar imagem original
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = async () => {
                        try {
                            // Definir tamanho do canvas igual √† imagem
                            canvas.width = img.width;
                            canvas.height = img.height;
                            
                            // Desenhar imagem original
                            ctx.drawImage(img, 0, 0);
                            
                            // Carregar logo
                            const logo = new Image();
                            logo.crossOrigin = 'anonymous';
                            
                            logo.onload = () => {
                                try {
                                    // Calcular tamanho do logo adaptativo conforme orienta√ß√£o
                                    // Para imagens horizontais: usa 25% da largura
                                    // Para imagens verticais: usa 25% da largura (menor dimens√£o)
                                    // Isso garante que o logo seja proporcional em ambas orienta√ß√µes
                                    const isVertical = img.height > img.width;
                                    const logoWidth = img.width * 0.25;
                                    const logoHeight = (logo.height / logo.width) * logoWidth;
                                    
                                    // Posi√ß√£o: centro no topo com margem de 3% da altura
                                    const marginTop = img.height * 0.03;
                                    const marginBottom = img.height * 0.03; // Margem inferior igual √† superior
                                    const logoX = (img.width - logoWidth) / 2;
                                    const logoY = marginTop;
                                    
                                    // Desenhar tira branca semi-transparente atr√°s do logo
                                    // A tira vai do topo da imagem at√© a parte inferior do logo com margem
                                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Branco com 70% de opacidade
                                    ctx.fillRect(0, 0, img.width, logoY + logoHeight + marginBottom);
                                    
                                    // Adicionar sombra sutil ao logo para melhor visibilidade
                                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                                    ctx.shadowBlur = 10;
                                    ctx.shadowOffsetX = 0;
                                    ctx.shadowOffsetY = 2;
                                    
                                    // Desenhar logo com opacidade (90% para manter visibilidade)
                                    ctx.globalAlpha = 0.9;
                                    ctx.drawImage(logo, logoX, logoY, logoWidth, logoHeight);
                                    ctx.globalAlpha = 1.0;
                                    
                                    // Converter canvas para data URL
                                    const resultDataUrl = canvas.toDataURL('image/jpeg', 0.95);
                                    resolve(resultDataUrl);
                                } catch (error) {
                                    console.error('Erro ao desenhar logo:', error);
                                    // Se falhar ao desenhar logo, retornar imagem original
                                    const originalDataUrl = canvas.toDataURL('image/jpeg', 0.95);
                                    resolve(originalDataUrl);
                                }
                            };
                            
                            logo.onerror = (error) => {
                                console.error('Erro ao carregar logo:', error);
                                // Se falhar ao carregar logo, retornar imagem original
                                const originalDataUrl = canvas.toDataURL('image/jpeg', 0.95);
                                resolve(originalDataUrl);
                            };
                            
                            logo.src = logoUrl;
                            
                        } catch (error) {
                            console.error('Erro ao processar imagem:', error);
                            reject(error);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error('Erro ao carregar imagem:', error);
                        reject(error);
                    };
                    
                    img.src = cleanImageData;
                    
                } catch (error) {
                    console.error('Erro em addLogoOverlayToImage:', error);
                    reject(error);
                }
            });
        }
        
        function showSuccess(message) {
            showToast(message, 'success');
        }
        
        function showError(message) {
            showToast(message, 'error');
        }
        
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `
                <div class="toast-icon">${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è'}</div>
                <div class="toast-content">
                    <div class="toast-message">${message}</div>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 3000);
        }
    </script>
    
    <style>
        /* Layout adaptations */
        .layout-with-sidebar {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex-shrink: 0;
        }
        
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .header {
            flex-shrink: 0;
        }
        
        /* Mobile */
        @media (max-width: 1023px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100%;
                transform: translateX(-100%);
                z-index: var(--z-modal);
                box-shadow: var(--shadow-2xl);
                transition: transform 0.3s ease;
            }
            
            .sidebar.active {
                transform: translateX(0);
            }
            
            #menuToggle {
                display: flex !important;
            }
            
            .main #mainContent {
                padding-bottom: 80px;
            }
        }
    </style>
</body>
</html>
